<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.bioprinting.site</id>
    <title>Li Zhenzhu, Ph.D</title>
    <updated>2019-05-20T14:18:23.277Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.bioprinting.site"/>
    <link rel="self" href="https://blog.bioprinting.site/atom.xml"/>
    <subtitle>Binzhou Medical University Hospital, Email: timeanddoctor@gmail.com.</subtitle>
    <logo>https://blog.bioprinting.site/images/avatar.png</logo>
    <icon>https://blog.bioprinting.site/favicon.ico</icon>
    <rights>All rights reserved 2019, Li Zhenzhu, Ph.D</rights>
    <entry>
        <title type="html"><![CDATA[IKPY]]></title>
        <id>https://blog.bioprinting.site/post/9J9NEqOgl</id>
        <link href="https://blog.bioprinting.site/post/9J9NEqOgl">
        </link>
        <updated>2019-05-20T14:11:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="入门">入门</h1>
<p>本教程将向您介绍IKPy的基本概念。您可以在相应的<a href="https://github.com/Phylliade/ikpy/blob/master/tutorials/Quickstart.ipynb">IPython Notebook中</a>测试实时版本。</p>
<h1 id=""><a href="https://github.com/Phylliade/ikpy/wiki#the-chain-object"></a>Chain对象</h1>
<p>这<a href="https://github.com/Phylliade/ikpy/blob/dev/src/ikpy/chain.py"><code>Chain</code></a>是您将使用的主要对象：它是您可以移动，检查和绘制的链接列表。</p>
<h2 id="-2"><a href="https://github.com/Phylliade/ikpy/wiki#creating-a-chain-from-a-urdf-file"></a>从URDF文件创建链</h2>
<p>IKPy的一个重要特性是您可以从URDF文件创建链。如果您的文件符合URDF，它将起作用！</p>
<p><code>my_chain = Chain.from_urdf_file(&quot;poppy_ergo.URDF&quot;)</code></p>
<p>要发现URDF解析的更多高级功能，请转到专用<a href="https://github.com/Phylliade/ikpy/wiki/URDF">页面</a>。</p>
<h2 id="-3"><a href="https://github.com/Phylliade/ikpy/wiki#creating-a-chain-manually"></a>手动创建链</h2>
<p>如果你不想弄乱URDF文件（还），你可以手动创建你的链：</p>
<p>来自 ikpy.link 进口链
从 ikpy.link 导入 OriginLink，URDFLink</p>
<p>left_arm_chain = Chain（name = ' left_arm '，links = [
OriginLink（）
URDFLink（
命名= “肩”，
translation_vector = [ - 10，0，5 ]，
取向= [ 0，1.57，0 ]，
转动= [ 0，1，0 ]，
）
URDFLink（
命名= “肘”，
translation_vector = [ 25，0，0 ]，
取向= [ 0，0，0 ]，
转动= [ 0，1，0 ]，
）
URDFLink（
命名= “手腕”，
translation_vector = [ 22，0，0 ]，
取向= [ 0，0，0 ]，
转动= [ 0，1，0 ]，
）
]）</p>
<h1 id="-4"><a href="https://github.com/Phylliade/ikpy/wiki#getting-the-position-of-your-chain-aka-forward-kinematics-aka-fk"></a>获得你的链的位置（又名前进运动学，又名FK）</h1>
<p>只需<code>forward_kinematics</code>使用每个关节的位置调用链的方法即可。</p>
<p><code>my_chain.forward_kinematics([0] * 7)</code></p>
<p>这将返回一个4x4变换矩阵，给出空间位置和链尖的方向。如果您不知道这些矩阵，请转到下面的“使用齐次坐标”部分。</p>
<h1 id="-5"><a href="https://github.com/Phylliade/ikpy/wiki#setting-the-position-of-your-chain-aka-inverse-kinematics-aka-ik"></a>设置链条的位置（又名反向运动学，又称IK）</h1>
<p>只需将框架矩阵（4x4 <a href="https://en.wikipedia.org/wiki/Transformation_matrix#Other_kinds_of_transformations">方向+平移矩阵</a>）传递<code>inverse_kinematics</code>给链的方法即可。</p>
<p>例如，目标位置为[2,2,2]，方向矩阵为标识：</p>
<p><code>my_chain.inverse_kinematics([[1, 0, 0, 2],
[0, 1, 0, 2],
[0, 0, 1, 2],
[0, 0, 0, 1]])</code></p>
<p>会回来：</p>
<p><code>[  0.00000000e+00,  -7.85169183e-01, -9.71977343e-01, 8.39302626e-01,   7.03536053e-05,   7.31439909e-01,  0.00000000e+00]</code></p>
<p>要获得有关Inverse Kinematics选项的更多信息，请单击此<a href="https://github.com/Phylliade/ikpy/wiki/Inverse-Kinematics">链接</a>。</p>
<h2 id="-6"><a href="https://github.com/Phylliade/ikpy/wiki#using-homogeneous-coordinates"></a>使用齐次坐标</h2>
<p>如果您不知道这些坐标并且4x4矩阵似乎排斥，则此部分适合您！</p>
<p>该矩阵只是存储平移和旋转的简单方法。要使用这样的矩阵，有一个辅助<code>geometry_utils.to_transformation_matrix(translation_vector, orientation_matrix)</code>函数可以为您计算这个矩阵：</p>
<p><code>my_chain.inverse_kinematics(geometry_utils.to_transformation_matrix(
[2, 2, 2],
[[1, 0, 0],
[0, 1, 0],
[0, 0, 1]]))</code></p>
<p>将返回与上一节完全相同的内容。</p>
<p>请注意，orientation_matrix参数是可选的。</p>
<h1 id="-7"><a href="https://github.com/Phylliade/ikpy/wiki#plotting-your-chain"></a>绘制链条</h1>
<p>您可以使用<code>plot</code>链对象的方法显示运动链，并传递链的每个关节的位置。</p>
<p>这里我们使用以下给出的位置<code>inverse_kinematics</code>：</p>
<p><code>import matplotlib.pyplot
from mpl_toolkits.mplot3d import Axes3D
ax = matplotlib.pyplot.figure().add_subplot(111, projection='3d')</p>
<p>my_chain.plot(my_chain.inverse_kinematics([
[1, 0, 0, 2],
[0, 1, 0, 2],
[0, 0, 1, 2],
[0, 0, 0, 1]
]), ax)
matplotlib.pyplot.show()</code></p>
<p>例如 ： <img src="https://github.com/Phylliade/ikpy/raw/master/tutorials/ikpy/plotting.png" alt=""></p>
<p>要使用高级绘图功能，例如在同一图形上显示多个链，请遵循<a href="https://github.com/Phylliade/ikpy/wiki/Plotting">本指南</a>。</p>
<p>&quot;&quot;&quot;
反向运动学
Pierre Manceron编辑了此页面 on 22 Jan 2016 · 3次修订
反向运动学
活动链接
在IKPy中，您可以随意激活或停用某些功能</p>
<p>例如，在这4个链接链中，通过指定掩码：</p>
<p>[True, True, False, True]
您将激活每个链接，但第三个链接：</p>
<p>要使用链接掩码，请active_links_mask在创建Chain对象时使用该参数。</p>
<p>初始位置
要计算反向运动学，算法将需要链的初始位置。您可以使用方法的initial_position参数传递它inverse_kinematics。预期的数据类型是完全一样的预期值joints的的forward_kinematics方法。</p>
<p>这是一个非常重要的参数，并且可能对计算产生巨大影响（在持续时间和返回的解决方案方面）如果您不提供它，IKPy将使用填充零的数组作为初始位置。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DRR配准相关]]></title>
        <id>https://blog.bioprinting.site/post/_81f-aeda</id>
        <link href="https://blog.bioprinting.site/post/_81f-aeda">
        </link>
        <updated>2019-05-15T04:53:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="使用模型代替体积的数字重建射线照相"><a href="https://discourse.slicer.org/t/digitally-reconstructed-radiograph-using-models-instead-of-volumes/3309">使用模型代替体积的数字重建射线照相</a></h1>
<p>是否可以使用切片器创建模拟的X射线图像，类似于数字重建的射线照片，将3D模型作为输入而不是体积数据（即CT扫描）？我想象一个场景，其中一个或多个骨骼/植入物/工具等的3D模型（例如STL文件）可以放置在3D场景中，分配X射线衰减值，并模拟X射线图像？需要使用python的解决方案对我来说是可行的选择。</p>
<p>我知道可以根据下面链接的帖子从CT扫描生成数字重建的射线照片，但是不确定是否可以使用更简化的有限数量结构的模型来进行，每个结构都有不断的X射线衰减。我知道可以将表面模型转换为体积数据，然后生成这些体积的DRR，但与直接计算射线三角形交叉点的东西相比，这似乎是一种相当低效的解决方案（计算上）。</p>
<p>在此先感谢您的帮助！</p>
<p><a href="https://sjc2.discourse-cdn.com/standard17/uploads/slicer/original/2X/c/cac1fb6dfe1d070cfc5b7e795b4cdbe3671aabc6.png" title="屏幕截图2018-06-26 at 9.00.22 PM.png"><img src="https://sjc2.discourse-cdn.com/standard17/uploads/slicer/optimized/2X/c/cac1fb6dfe1d070cfc5b7e795b4cdbe3671aabc6_2_562x500.png" alt="22％20PM"></a>
屏幕截图2018-06-26 at 9.00.22 PM.png1432×1274 148 KB</p>
<p>尝试一下......似乎工作得相当好，但不确定它是否有资格作为“模拟”。</p>
<p>使用Image Maker模块创建空图像卷。然后导入.stl文件或其他任何内容并转换为分段（分段模块 - &gt;导入模型）。使用线性衰减系数的值填充空图像体积中的体素（查看这些对于例如您感兴趣的光子能量的骨骼，软组织，肺组织......在这里我使用10 kVp并查找来自NIST数据库），用于每个组织; 您可以在GUI中编写脚本或使用Segmentations - &gt;“Mask Volume”和Add Scalar Volumes模块的组合。最后，完成线性衰减系数贴图（图像）后，使用简单滤镜模块 - &gt; MeanProjectionImageFilter或SumProjectionImageFilter。</p>
<p>结果在右下角。</p>
<p>最好，</p>
<p>如何做到这一点有很多选择。理想的解决方案取决于您的要求（您拥有多少输入模型，您需要的分辨率，物体移动的速度，几何体的复杂程度，可用的CPU和GPU等）。</p>
<p><a href="https://discourse.slicer.org/u/hamburgerfinger">@Hamburgerfinger</a>的建议很好。生成二进制或分数卷并使用GPU渲染它也很好（在生成卷之后，GPU渲染器可能会以高帧速率渲染DRR图像）。</p>
<p>获取类似DRR图像的最简单方法可能是使用Python设置厚切片显示。例如，将此代码片段复制粘贴到Python控制台中即可开始：</p>
<p>最大强度投影：</p>
<p><code>sliceNode = slicer.mrmlScene.GetNodeByID('vtkMRMLSliceNodeRed')
appLogic = slicer.app.applicationLogic()
sliceLogic = appLogic.GetSliceLogic(sliceNode)
sliceLayerLogic = sliceLogic.GetBackgroundLayer()
reslice = sliceLayerLogic.GetReslice()
reslice.SetSlabModeToMax()
reslice.SetSlabNumberOfSlices(600)
reslice.SetSlabSliceSpacingFraction(0.5)
sliceNode.Modified()</code></p>
<p>CTChest示例数据集的结果：</p>
<p><img src="https://sjc2.discourse-cdn.com/standard17/uploads/slicer/original/1X/c9eec191b459a546649043480efe82c708c1be57.png" alt="image_00036"></p>
<p>如果将slab模式更改为mean而不是max（<code>reslice.SetSlabModeToMean()</code>），则可以获得更多类似DRR的图像，但通常会使细节更难以查看。</p>
<p>具有类似DRR的平均板模式的相同数据集：</p>
<p><img src="https://sjc2.discourse-cdn.com/standard17/uploads/slicer/original/1X/a3202605d9b9d3621af76f9e347b6e423b7a71ce.png" alt="image_00035"></p>
<p><a href="http://slicer-devel-archive.65872.n3.nabble.com/Faster-slice-view-thick-slices-and-MIP-slice-view-mode-td4033264.html">在这里 </a>查看更多示例<a href="http://slicer-devel-archive.65872.n3.nabble.com/Faster-slice-view-thick-slices-and-MIP-slice-view-mode-td4033264.html">43</a>。</p>
<p>为了在3D视图中更快地更新和显示，您可以配置体积渲染模块以显示最大强度投影（MIP）。对于最逼真的DRR渲染，您可以尝试使用Plastimatch扩展。</p>
<h1 id="vtk中光线投射法实现体绘制转"><a href="https://www.cnblogs.com/yxnchinahlj/archive/2011/04/12/2013330.html">VTK中光线投射法实现体绘制【转】</a></h1>
<p>VTK中光线投射法实现体绘制</p>
<p><img src="http://hiphotos.baidu.com/hnulilei/pic/item/034f3116810e852f972b43ef.jpg" alt=""></p>
<p>1、体绘制函数
VTK 为使用者提供了三种用于光线投射法的函数分别是：
等值面绘制函数（vtkVolumeRayCastIsosurfaceFunction）；
最大密度投影函数（vtkVolumeRayCastMIPFunction）；
合成体绘制函数（vtkVolumeRayCastCompositeFunction）
其中最常用的是合成体绘制函数，最大密度投影函数在显示血管影像方面有比较好的作用。但是如图所看到的，MIP函数没有空间立体感，也就是不能提供深度的信息。</p>
<p><img src="http://hiphotos.baidu.com/hnulilei/pic/item/187de82391787879925807e9.jpg" alt=""></p>
<p>2、不透明度映射函数
不透明度映射函数是设置光线方向上的灰度值及其不透明度映射。
vtkPiecewiseFunction *opacityTransferFunction = vtkPiecewiseFunction::New();
opacityTransferFunction-&gt;AddPoint(10, 0.0);//灰度值及不透明度值
opacityTransferFunction-&gt;AddPoint(50,0.1);
opacityTransferFunction-&gt;AddPoint(200 ,0.1);
opacityTransferFunction-&gt;AddPoint(2900,0.1);
opacityTransferFunction-&gt;AddPoint(2950,0.8);
opacityTransferFunction-&gt;AddPoint(3050,1);//不透明度值为1则为完全不透明
opacityTransferFunction-&gt;ClampingOff();</p>
<p>3、颜色映射函数
颜色映射函数是设置灰度值与RGB颜色的映射。
vtkColorTransferFunction *colorTransferFunction = vtkColorTransferFunction::New();
colorTransferFunction-&gt;AddRGBPoint(0.0, 0.91, 0.65, 0.66); //灰度值及RGB颜色值
colorTransferFunction-&gt;AddRGBPoint(30.0, 0.91, 0.65, 0.66);
colorTransferFunction-&gt;AddRGBPoint(128.0, 0.91, 0.65, 0.66);
colorTransferFunction-&gt;AddRGBPoint(1200.0, 0.43, 0.43, 0.43);
colorTransferFunction-&gt;AddRGBPoint(1800.0, 0.43, 0.43, 0.43);
colorTransferFunction-&gt;AddRGBPoint(2950, .9, 0.0, 0.0);
colorTransferFunction-&gt;AddRGBPoint(3050, .9, 0.0, 0.0);
colorTransferFunction-&gt;ClampingOff();</p>
<p>4、梯度变换函数
梯度变换函数设置灰度值变换的大小与不透明度之间的映射。
vtkPiecewiseFunction *gradient=vtkPiecewiseFunction::New();
gradient-&gt;AddPoint(50,.2);//灰度值变化梯度与不透明度的关系
gradient-&gt;AddPoint(1500,.7);
gradient-&gt;AddPoint(2000,.1);
5、体数据属性设置
vtkVolumeProperty <em>volumeProperty = vtkVolumeProperty::New();
volumeProperty-&gt;SetColor(colorTransferFunction);//载入颜色映射函数
volumeProperty-&gt;SetScalarOpacity(opacityTransferFunction);//载入不透明度映射
volumeProperty-&gt;SetGradientOpacity(gradient);//载入梯度映射
volumeProperty-&gt;ShadeOn();
volumeProperty-&gt;SetInterpolationTypeToLinear();//采用线性插值
6、光线投射函数设置及体绘制映射
本程序采用合成体绘制函数：
vtkVolumeRayCastCompositeFunction</em>compositeFunction=
vtkVolumeRayCastCompositeFunction::New();
vtkVolumeRayCastMapper *volumeMapper = vtkVolumeRayCastMapper::New();
volumeMapper-&gt;SetVolumeRayCastFunction(compositeFunction);//载入体绘制方法
volumeMapper-&gt;SetInput(append-&gt;GetOutput());//载入图像数据
volumeMapper-&gt;SetSampleDistance(.5);
vtkVolume *volume = vtkVolume::New();
volume-&gt;SetMapper(volumeMapper);//设置映射
volume-&gt;SetProperty(volumeProperty);//设置属性</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Maddux机器人库]]></title>
        <id>https://blog.bioprinting.site/post/z21-pFg7m</id>
        <link href="https://blog.bioprinting.site/post/z21-pFg7m">
        </link>
        <updated>2019-05-13T10:46:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="maddux文档">Maddux文档</h1>
<p>Maddux是一个用于创建机器人手臂模拟和实验的python库。</p>
<p>Maddux支持：</p>
<ul>
<li>任意长度的武器</li>
<li>正向运动学</li>
<li>反向运动学</li>
<li>模拟环境（包括球，目标，障碍物等对象）</li>
<li>3D环境动画</li>
<li>3D手臂动画</li>
<li>末端效应器位置和速度</li>
<li>碰撞检测（武器和物体）</li>
</ul>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 发布： | 0.1 |
| 日期： | 2016年4月24日 |
<ul>
<li><a href="http://bencaine.me/maddux/overview.html">概观</a>
<ul>
<li><a href="http://bencaine.me/maddux/overview.html#goal">目标</a></li>
<li><a href="http://bencaine.me/maddux/overview.html#why-the-name">为什么这个名字？</a></li>
</ul>
</li>
<li><a href="http://bencaine.me/maddux/tutorial.html">教程</a>
<ul>
<li><a href="http://bencaine.me/maddux/tutorial.html#creating-arms">创造武器</a></li>
<li><a href="http://bencaine.me/maddux/tutorial.html#setting-up-and-plotting-an-environment">设置和绘制环境</a></li>
<li><a href="http://bencaine.me/maddux/tutorial.html#inverse-kinematics-and-animations">反向运动学和动画</a></li>
<li><a href="http://bencaine.me/maddux/tutorial.html#saving-paths-and-creating-videos">保存路径和创建视频</a></li>
<li><a href="http://bencaine.me/maddux/tutorial.html#conclusion">结论</a></li>
</ul>
</li>
<li><a href="http://bencaine.me/maddux/maddux.html">maddux包</a>
<ul>
<li><a href="http://bencaine.me/maddux/maddux.html#submodules">子模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.html#module-maddux.environment">maddux.environment模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.html#module-maddux.plot">maddux.plot模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.html#module-maddux.predefined_environments">maddux.predefined_environments模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.html#module-maddux">模块内容</a></li>
</ul>
</li>
<li><a href="http://bencaine.me/maddux/maddux.robots.html">maddux.robots包</a>
<ul>
<li><a href="http://bencaine.me/maddux/maddux.robots.html#submodules">子模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.robots.html#module-maddux.robots.arm">maddux.robots.arm模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.robots.html#module-maddux.robots.link">maddux.robots.link模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.robots.html#module-maddux.robots.predefined_robots">maddux.robots.predefined_robots模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.robots.html#module-maddux.robots.utils">maddux.robots.utils模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.robots.html#module-maddux.robots">模块内容</a></li>
</ul>
</li>
<li><a href="http://bencaine.me/maddux/maddux.objects.html">maddux.objects包</a>
<ul>
<li><a href="http://bencaine.me/maddux/maddux.objects.html#submodules">子模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.objects.html#module-maddux.objects.ball">maddux.objects.ball模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.objects.html#module-maddux.objects.dynamic">maddux.objects.dynamic模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.objects.html#module-maddux.objects.obstacle">maddux.objects.obstacle模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.objects.html#module-maddux.objects.static">maddux.objects.static模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.objects.html#module-maddux.objects.target">maddux.objects.target模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.objects.html#module-maddux.objects.throwable">maddux.objects.throwable模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.objects.html#module-maddux.objects">模块内容</a></li>
</ul>
</li>
<li><a href="http://bencaine.me/maddux/maddux.examples.html">maddux.examples包</a>
<ul>
<li><a href="http://bencaine.me/maddux/maddux.examples.html#submodules">子模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.examples.html#module-maddux.examples.arm_animation">maddux.examples.arm_animation模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.examples.html#module-maddux.examples.arm_ball_animation">maddux.examples.arm_ball_animation模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.examples.html#module-maddux.examples.ball_animation">maddux.examples.ball_animation模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.examples.html#module-maddux.examples.find_jacob0">maddux.examples.find_jacob0模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.examples.html#module-maddux.examples.obstacle_collision">maddux.examples.obstacle_collision模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.examples.html#module-maddux.examples.plot">maddux.examples.plot模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.examples.html#module-maddux.examples.plot_arm">maddux.examples.plot_arm模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.examples.html#module-maddux.examples.plot_obstacle">maddux.examples.plot_obstacle模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.examples.html#module-maddux.examples.tutorial">maddux.examples.tutorial模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.examples.html#module-maddux.examples">模块内容</a></li>
</ul>
</li>
<li><a href="http://bencaine.me/maddux/maddux.utils.html">maddux.utils包</a>
<ul>
<li><a href="http://bencaine.me/maddux/maddux.utils.html#submodules">子模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.utils.html#module-maddux.utils.animate_path">maddux.utils.animate_path模块</a></li>
<li><a href="http://bencaine.me/maddux/maddux.utils.html#module-maddux.utils">模块内容</a></li>
</ul>
</li>
</ul>
<h1 id="指数和表格">指数和表格</h1>
<ul>
<li>
<p><a href="http://bencaine.me/maddux/genindex.html">指数</a></p>
</li>
<li>
<p><a href="http://bencaine.me/maddux/py-modindex.html">模块索引</a></p>
</li>
<li>
<p><a href="http://bencaine.me/maddux/search.html">搜索页面</a></p>
</li>
<li>
<h1 id="概观">概观</h1>
<p>Maddux是一个Python语言软件包，用于与模拟环境交互的机器人操纵器的创建，实验和可视化。</p>
<p>使用Maddux，您可以创建任意机器人操纵器，其中包含由DH参数定义的一组链接，并在自定义环境中使用这些操纵器。设计易于修改，非常适合设置实验，让武器学习执行新任务。</p>
<h2 id="目标">目标</h2>
<p>Maddux的创建是为了拥有一个简单，易于理解的工具，可以快速实验教授机器人手臂来执行不同的任务。模拟环境并不是真实的，或者具有现实世界的约束。相反，重点是快速建立一个实验来测试一个想法。</p>
<h2 id="为什么这个名字">为什么这个名字？</h2>
<p>Maddux以Greg Maddux命名，Greg Maddux是一位退役的MLB投手，被广泛认为是有史以来最好的控球投手。他以其强大的机械，命令，沉着和机智而闻名，他是机器人手臂所希望的一切。</p>
<h1 id="教程">教程</h1>
<p>在本教程中，我们将简要介绍创建手臂，设置模拟环境，绘制和动画这些环境，保存机器人移动路径以及创建动画视频。</p>
<h2 id="创造武器">创造武器</h2>
<p>Maddux中的Arms由一系列Link对象组成，这些对象由<a href="https://en.wikipedia.org/wiki/Denavit%E2%80%93Hartenberg_parameters">DH参数</a>定义。每个链接都有θ（角度），偏移，长度和扭曲参数。每个链接还可以具有约束θ，最大速度和关节尺寸（用于可视化和碰撞）。</p>
<p>如果您不熟悉DH参数，我建议您先阅读它们，因为它们可能有点令人困惑。例如，从一个关节到另一个关节的距离可以由偏移或长度来定义。</p>
<p>以下是我们在maddux.robots.predefined_arms中为您定义的“简单人类手臂”的定义。</p>
<p>从 链接 导入 链接
从 手臂 进口 臂
进口 numpy的 为 NP</p>
<p>seg1_len  =  1.0
seg2_len  =  2.0</p>
<p>＃我们的七个“链接”。其中只有两个具有长度或偏移量。
L1  =  链接（0 ， 0 ， 0 ， 1.571 ）
L2  =  链接（0 ， 0 ， 0 ， - 1.571 ）
L3  =  链接（0 ， seg1_len ， 0 ， - 1.571 ）
L4  =  链接（0 ， 0 ， seg2_len ， - 1.571 ）
L5 =  链接（0 ， 0 ， 0 ， 1.571 ）
L6  =  链接（0 ， 0 ， 0 ， 1.571 ）
L7  =  链接（0 ， 0 ， 0 ， 0 ）</p>
<p>＃创建一个数组
links  =  np 。阵列（[ L1 ， L2 ， L3 ， L4 ， L5 ， L6 ， L7 ]）</p>
<p>＃为每个链接创建一个初始联合配置。
＃q0 [0]是Link1的theta
＃q0 [1]是Link2
＃
的theta ，依此类推。q0  =  np 。阵列（[ 0 ， 0 ， 0 ， - 2.0 ， 0 ， 0 ， 0 ]）</p>
<p>＃然后用这些链接创建一个arm，初始配置q0，名称
robot  =  Arm （links ， q0 ， 'simple_human_arm' ）</p>
<p>值得注意的是，只有两个链接具有偏移或长度，为我们提供了两个链接臂。L7根本不是必需的，只是替换可能的末端执行器。</p>
<h2 id="设置和绘制环境">设置和绘制环境</h2>
<p>环境是Maddux中所有模拟的核心。它们允许您将动态（可移动）和静态（静止）对象组以及机器人组合成各种类型的“房间”，以允许所有这些对象的交互。</p>
<p>要定义一个环境，我们将首先定义一些对象，然后我们将创建一个机器人（来自我们预定义的机器人），然后我们将这些添加到环境中。</p>
<p>导入 numpy的 是 NP
从 maddux.robots.predefined_robots  导入 simple_human_arm
从 maddux.objects  导入已 球， 目标， 障碍
来自 maddux.environment  进口 环境</p>
<p>＃创建一个具有特定配置和基准位置的臂
q0  =  np 。阵列（[ 0.5 ， 0.2 ， 0 ， 0.5 ， 0 ， 0 ， 0 ]）
base_pos  =  NP 。阵列（[ 2.0 ， 2.0 ， 0.0 ]）</p>
<p>长度2.0的＃和链路段
臂 =  simple_human_arm （2.0 ， 2.0 ， Q0 ， base_pos ）</p>
<p>＃然后，我们创造了一个球，目标，和障碍物
球 =  球（位置= [ 2.0 ， 0.0 ， 2.0 ]， 半径= 0.15 ）
目标 =  目标（位置= [ 5.0 ， 8.0 ， 2.0 ]， 半径= 0.5 ）
障碍物 =  障碍（[ 4 ， 4 ， 0 ]， [ 5 ， 5 ， 2 ]）</p>
<p>＃并使用这些以产生具有尺寸的环境10x10x10
ENV  =  环境（尺寸= [ 10 ， 10 ， 10 ]，
dynamic_objects = [ 球]，
static_objects = [ 障碍， 靶]，
机器人= 臂）</p>
<p>然后，我们可以与这些对象进行交互，绘制它们，为它们的交互设置动画等。</p>
<p>如果我们想要绘制这个环境，我们所要做的就是</p>
<p>ENV 。情节（）</p>
<p>哪个会生成如下所示的环境：</p>
<p><img src="http://bencaine.me/maddux/_images/tutorial_1.png" alt="_images / tutorial_1.png"></p>
<h2 id="反向运动学和动画">反向运动学和动画</h2>
<p>鉴于上述环境，假设我们想让手臂找到一个关节配置，让手臂的末端效应器接触球。给定球的位置，我们可以使用Arm类中内置的迭代反向运动学求解器来找到可能的关节配置。</p>
<p>手臂。ikine （球。位置）</p>
<p>我们的反向运动求解器自动将构成其路径的每组配置缓存到臂上的变量中。保存此路径后，我们可以通过调用指定持续时间的动画来设置此过程的动画。</p>
<p>ENV 。动画（3.0 ）</p>
<h2 id="保存路径和创建视频">保存路径和创建视频</h2>
<p>在上面的反向运动学示例中，ikine将其生成的路径保存到臂上的变量中。在调用一些修改联合配置（update_angles，update_link_angle，ikine）并让它缓存其更改的函数之后，我们可以将该路径写入文件。</p>
<p>手臂。save_path （'filename_to_save_to' ）</p>
<p>通过将一系列关节配置保存到文件中，我们以后可以使用它来重新运行动画，或者将动画保存为MP4视频。为此，我们只需在arm上调用save_path。我们假设我们的环境是在maddux.predefined_environments.py中定义的。</p>
<p>要简单地重新运行动画，我们就可以运行了</p>
<p>python maddux / utils / animate_path.py --input tutorial_path.npy --environment tutorial</p>
<p>如果我们想创建一个名为tutorial.mp4的视频，我们会将上述命令更改为此</p>
<p>python maddux / utils / animate_path.py --input tutorial_path.npy --environment tutorial --output tutorial.mp4</p>
<p>哪个会创建一个视频然后我变成这个GIF。</p>
<p><img src="http://bencaine.me/maddux/_images/tutorial.gif" alt="_images / tutorial.gif"></p>
<h2 id="结论">结论</h2>
<p>这是为了快速介绍工具包的不同方面。还有许多其他潜在有用的功能，例如动态物体具有速度和运动，让手臂握住并用其末端执行器移动物体，提供臂关节速度，以及根据关节速度计算末端执行器速度。希望这提供了一个轻量级和灵活的工具包，可以根据您的需求进行构建和修改，并让您尽快启动并运行疯狂的想法。</p>
<h1 id="maddux包">maddux包</h1>
<h2 id="子模块">子模块</h2>
<h2 id="madduxenvironment模块">maddux.environment模块</h2>
<p>我们的实验环境。</p>
<dt id="maddux.environment.Environment">_class_`maddux.environment.``Environment`（_dimension = None_，_dynamic_objects = None_，_static_objects = None_，_robot = None _）[[来源]](http://bencaine.me/maddux/_modules/maddux/environment.html#Environment)</dt>
<dt id="maddux.environment.Environment.animate">`animate`（_duration = None_，_save_path = None _）[[来源]](http://bencaine.me/maddux/_modules/maddux/environment.html#Environment.animate)</dt>
<p>动画程序的运行</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | 
<ul>
<li><strong>duration</strong>（<em>int或None</em>） - （可选）动画的持续时间（以秒为单位）</li>
<li><strong>save_path</strong>（<em>String或None</em>） - （可选）保存mp4而不是显示的路径</li>
</ul>
<p>|
| 返回类型： |</p>
<p><a href="https://docs.python.org/library/constants.html#None" title="（在Python v2.7中）">没有</a></p>
<p>|</p>
<dt id="maddux.environment.Environment.collision">`collision`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/environment.html#Environment.collision)</dt>
<p>检查是否有任何动态对象与任何静态对象或墙壁发生碰撞。</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 返回值： | 是否有碰撞 |
| 返回类型： | [布尔](https://docs.python.org/library/functions.html#bool "（在Python v2.7中）") |
<dt id="maddux.environment.Environment.hypothetical_landing_position">`hypothetical_landing_position`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/environment.html#Environment.hypothetical_landing_position)</dt>
<p>找到球落地（或击中墙壁）的位置</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 返回值： | 基于末端执行器速度的投掷物体的假设着陆位置的位置（x，y，z）。 |
| 返回类型： | numpy.ndarray或无 |
<dt id="maddux.environment.Environment.plot">`plot`（_ax = None_，_show = True _）[[来源]](http://bencaine.me/maddux/_modules/maddux/environment.html#Environment.plot)</dt>
<p>绘制投掷轨迹和球</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | 
<ul>
<li><strong>ax</strong>（<em>matplotlib.axes</em>） - 如果数字已经存在，则为当前轴</li>
<li><strong>show</strong>（<a href="https://docs.python.org/library/functions.html#bool" title="（在Python v2.7中）"><em>bool</em></a>） - （默认值：True）是否显示数字</li>
</ul>
<p>|
| 返回类型： |</p>
<p><a href="https://docs.python.org/library/constants.html#None" title="（在Python v2.7中）">没有</a></p>
<p>|</p>
<dt id="maddux.environment.Environment.run">`run`（_持续时间_）[[来源]](http://bencaine.me/maddux/_modules/maddux/environment.html#Environment.run)</dt>
<p>运行一段时间</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **duration**（_整数_） - 以秒为单位运行环境的持续时间 |
| 返回类型： | [没有](https://docs.python.org/library/constants.html#None "（在Python v2.7中）") |
<h2 id="madduxplot模块">maddux.plot模块</h2>
<dt id="maddux.plot.plot_sphere">`maddux.plot.``plot_sphere`（_位置_，_半径_，_轴_，_颜色='g'_，_线宽= 0 _）[[来源]](http://bencaine.me/maddux/_modules/maddux/plot.html#plot_sphere)</dt>
<p>绘制球体。</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | 
<ul>
<li><strong>position</strong>（<em>numpy.ndarray</em>） - 在球体的（x，y，z）中的位置</li>
<li><strong>radius</strong>（<a href="https://docs.python.org/library/functions.html#int" title="（在Python v2.7中）"><em>int</em></a>） - 球体半径</li>
<li><strong>ax</strong>（<em>matplotlib.axes</em>） - 要绘制的轴</li>
<li><strong>color</strong>（<a href="https://docs.python.org/library/functions.html#str" title="（在Python v2.7中）"><em>str</em></a>） - （可选）球体颜色</li>
<li><strong>linewidth</strong>（<a href="https://docs.python.org/library/functions.html#int" title="（在Python v2.7中）"><em>int</em></a>） - （可选）球网格线的宽度</li>
</ul>
<p>|
| 返回类型： |</p>
<p>matplotlib.axes</p>
<p>|</p>
<dt id="maddux.plot.plot_sphere_data">`maddux.plot.``plot_sphere_data`（_位置_，_半径_）[[来源]](http://bencaine.me/maddux/_modules/maddux/plot.html#plot_sphere_data)</dt>
<p>给定位置和半径，获取绘图所需的数据。</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | 
<ul>
<li><strong>position</strong>（<em>numpy.ndarray</em>） - 在球体的（x，y，z）中的位置</li>
<li><strong>radius</strong>（<a href="https://docs.python.org/library/functions.html#int" title="（在Python v2.7中）"><em>int</em></a>） - 球体半径</li>
</ul>
<p>|
| 返回值： |</p>
<p>（x，y，z）用于创建曲面的球体数据元组</p>
<p>|
| 返回类型： |</p>
<p>（np.ndarray，np.ndarray，np.ndarray）</p>
<p>|</p>
<h2 id="madduxpredefined_environments模块">maddux.predefined_environments模块</h2>
<dt id="maddux.predefined_environments.get_easy_environment">`maddux.predefined_environments.``get_easy_environment`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/predefined_environments.html#get_easy_environment)</dt>
<p>一个简单的难度环境，用于规划具有两个障碍的测试，一个球作为目标，一个简单的人类手臂。</p>
<dt id="maddux.predefined_environments.get_hard_environment">`maddux.predefined_environments.``get_hard_environment`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/predefined_environments.html#get_hard_environment)</dt>
<p>一个艰难的难度环境，用于规划具有五个障碍的测试，一个球作为目标，一个简单的人类手臂。</p>
<dt id="maddux.predefined_environments.get_medium_environment">`maddux.predefined_environments.``get_medium_environment`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/predefined_environments.html#get_medium_environment)</dt>
<p>一个中等难度的环境，用于规划具有两个障碍的测试，一个球作为目标，一个简单的人类手臂。</p>
<dt id="maddux.predefined_environments.get_noodle_environment">`maddux.predefined_environments.``get_noodle_environment`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/predefined_environments.html#get_noodle_environment)</dt>
<p>我们的面条臂进行规划测试的荒谬环境。它有五个障碍，一个球作为目标，我们的10个链接面条臂</p>
<dt id="maddux.predefined_environments.get_tutorial_environment">`maddux.predefined_environments.``get_tutorial_environment`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/predefined_environments.html#get_tutorial_environment)</dt>
<p>我们的环境来自文档教程</p>
<dt id="maddux.predefined_environments.get_very_hard_environment">`maddux.predefined_environments.``get_very_hard_environment`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/predefined_environments.html#get_very_hard_environment)</dt>
<p>一个非常困难的难度环境，用于规划具有三个障碍的测试，一个球作为目标，一个简单的人类手臂。</p>
<h2 id="模块内容">模块内容</h2>
<h1 id="madduxrobots包">maddux.robots包</h1>
<h2 id="子模块-2">子模块</h2>
<h2 id="madduxrobotsarm模块">maddux.robots.arm模块</h2>
<p>由一系列DH链接定义的机器人手臂</p>
<dt id="maddux.robots.arm.Arm">_class_`maddux.robots.arm.``Arm`（_links_，_q0_，_name_，_active_links = None_，_base = None_，_tool = None _）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/arm.html#Arm)</dt>
<dt id="maddux.robots.arm.Arm.end_effector_position">`end_effector_position`（_q =无_）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/arm.html#Arm.end_effector_position)</dt>
<p>返回末端执行器位置</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **q**（_numpy.ndarray或None_） - 配置计算给定1xN q向量的末端效应器位置 |
| 返回值： | 末端执行器的位置（x，y，z） |
| 返回类型： | numpy.ndarray |
<dt id="maddux.robots.arm.Arm.end_effector_velocity">`end_effector_velocity`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/arm.html#Arm.end_effector_velocity)</dt>
<p>给出其当前角速度，计算手臂的末端执行器速度。</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 返回值： | 返回每个维度（vx，vy，vz，wx，wy，wz）的线性和角速度。 |
| 返回类型： | np.ndarray |
<dt id="maddux.robots.arm.Arm.fkine">`fkine`（_q =无_，_链接=无_）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/arm.html#Arm.fkine)</dt>
<p>使用当前关节配置或给定的关节配置计算手臂的正向运动</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | 
<ul>
<li><strong>q</strong>（<em>numpy.ndarray或None</em>） - （可选）用于计算FK的联合配置的1xN向量</li>
<li><strong>links</strong>（<em>int或None</em>） - （可选）指定要在其上运行fkine的链接。例如：links = [1,2,3]。</li>
</ul>
<p>|
| 返回值： |</p>
<p>指定的链接列表或末端效应器末尾的同源坐标点</p>
<p>|
| 返回类型： |</p>
<p>4x4 numpy.array</p>
<p>|</p>
<dt id="maddux.robots.arm.Arm.get_current_joint_config">`get_current_joint_config`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/arm.html#Arm.get_current_joint_config)</dt>
<p>从链接获取当前联合配置</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 返回值： | 当前联合配置的1xN向量 |
| 返回类型： | numpy.ndarray |
<dt id="maddux.robots.arm.Arm.hold">`hold`（_obj _）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/arm.html#Arm.hold)</dt>
<p>持有一个特定的对象</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **obj**（_maddux.objects.DynamicObject_） - 要保留的对象 |
| 返回类型： | [没有](https://docs.python.org/library/constants.html#None "（在Python v2.7中）") |
<dt id="maddux.robots.arm.Arm.ikine">`ikine`（_p_，_num_iterations = 1000_，_alpha = 0.1 _）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/arm.html#Arm.ikine)</dt>
<p>计算反向运动学以找到到达给定点的正确关节配置</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | 
<ul>
<li><strong>p</strong>（<em>numpy.ndarray</em>） - 解决逆运动学的点（x，y，z）</li>
<li><strong>num_iterations</strong>（<a href="https://docs.python.org/library/functions.html#int" title="（在Python v2.7中）"><em>int</em></a>） - 放弃之前要尝试的迭代次数</li>
<li><strong>alpha</strong>（<a href="https://docs.python.org/library/functions.html#int" title="（在Python v2.7中）"><em>int</em></a>） - ikine求解器的步长（0.0 - 1.0）</li>
</ul>
<p>|
| 返回值： |</p>
<p>给定点p的关节配置的1xN向量。</p>
<p>|
| 返回类型： |</p>
<p>numpy.ndarray</p>
<p>|</p>
<dt id="maddux.robots.arm.Arm.is_in_collision">`is_in_collision`（_env_object _）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/arm.html#Arm.is_in_collision)</dt>
<p>检查手臂是否与给定物体发生碰撞</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **env_object**（_maddux.Objects.StaticObject_） - 检查与之冲突的对象 |
| 返回值： | 你是否点击了env_object |
| 返回类型： | [布尔](https://docs.python.org/library/functions.html#bool "（在Python v2.7中）") |
<dt id="maddux.robots.arm.Arm.jacob0">`jacob0`（_q =无_）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/arm.html#Arm.jacob0)</dt>
<p>通过在工具框架中找到它然后转换为世界框架来计算世界框架中的雅可比。</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **q**（_numpy.ndarray_） - （可选）1xN联合配置来计算jacobian |
| 返回值： | 世界框架中的6xN雅可比行列式 |
| 返回类型： | numpy.matrix |
<dt id="maddux.robots.arm.Arm.jacobn">`jacobn`（_q =无_）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/arm.html#Arm.jacobn)</dt>
<p>计算工具框架中的雅可比</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **q**（_1xN numpy.ndarray_） - （可选）1xN联合配置来计算jacobian |
| 返回值： | 工具框架中的6xN雅可比行列式 |
| 返回类型： | numpy.matrix |
<dt id="maddux.robots.arm.Arm.plot">`plot`（_ax _）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/arm.html#Arm.plot)</dt>
<p>将我们的机器人绘制到给定的轴上</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **ax**（_matplotlib.axes_） - 情节轴 |
| 返回类型： | [没有](https://docs.python.org/library/constants.html#None "（在Python v2.7中）") |
<dt id="maddux.robots.arm.Arm.release">`release`（_object_idx =无_）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/arm.html#Arm.release)</dt>
<p>释放一个或所有当前保留的对象</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **object_idx** - （可选）要释放的对象的索引 |
<p>：type object_idx = int或None</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 返回类型： | [没有](https://docs.python.org/library/constants.html#None "（在Python v2.7中）") |
<dt id="maddux.robots.arm.Arm.reset">`reset`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/arm.html#Arm.reset)</dt>
<p>将手臂重置回其静止状态，即q0</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 返回类型： | [没有](https://docs.python.org/library/constants.html#None "（在Python v2.7中）") |
<dt id="maddux.robots.arm.Arm.save_path">`save_path`（_文件名_）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/arm.html#Arm.save_path)</dt>
<p>将当前路径保存到文件：param filename：保存联合配置路径的文件名：键入filename：str</p>
<dt id="maddux.robots.arm.Arm.update_angles">`update_angles`（_new_angles_，_save = False _）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/arm.html#Arm.update_angles)</dt>
<p>更新所有链接的角度</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | 
<ul>
<li><strong>new_angles</strong>（<em>numpy.ndarray</em>） - 新链接角度的1xN向量</li>
<li><strong>save</strong> - 确定是否缓存更新的标志</li>
<li><strong>保存</strong> - 布尔</li>
</ul>
<p>|
| 返回类型： |</p>
<p><a href="https://docs.python.org/library/constants.html#None" title="（在Python v2.7中）">没有</a></p>
<p>|</p>
<dt id="maddux.robots.arm.Arm.update_link_angle">`update_link_angle`（_link_，_new_angle_，_save = False _）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/arm.html#Arm.update_link_angle)</dt>
<p>使用给定角度更新给定链接的角度</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | 
<ul>
<li><strong>link</strong>（<a href="https://docs.python.org/library/functions.html#int" title="（在Python v2.7中）"><em>int</em></a>） - 要更新的链接</li>
<li><strong>new_angle</strong>（<a href="https://docs.python.org/library/functions.html#int" title="（在Python v2.7中）"><em>int</em></a>） - 链接的新角度</li>
<li><strong>save</strong>（<a href="https://docs.python.org/library/functions.html#bool" title="（在Python v2.7中）"><em>bool</em></a>） - 确定是否缓存更新的标志</li>
</ul>
<p>|
| 返回类型： |</p>
<p><a href="https://docs.python.org/library/constants.html#None" title="（在Python v2.7中）">没有</a></p>
<p>|</p>
<dt id="maddux.robots.arm.Arm.update_link_positions">`update_link_positions`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/arm.html#Arm.update_link_positions)</dt>
<p>浏览所有链接并更新其位置。</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 返回类型： | [没有](https://docs.python.org/library/constants.html#None "（在Python v2.7中）") |
<dt id="maddux.robots.arm.Arm.update_link_velocity">`update_link_velocity`（_链接_，_加速_，_时间_）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/arm.html#Arm.update_link_velocity)</dt>
<p>在给定时间内以给定加速度更新给定链接的速度</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | 
<ul>
<li><strong>link</strong>（<a href="https://docs.python.org/library/functions.html#int" title="（在Python v2.7中）"><em>int</em></a>） - 要更新的链接</li>
<li><strong>accel</strong>（<a href="https://docs.python.org/library/functions.html#int" title="（在Python v2.7中）"><em>int</em></a>） - 加速度（每秒弧度^ 2）</li>
<li><strong>time</strong>（<a href="https://docs.python.org/library/functions.html#int" title="（在Python v2.7中）"><em>int</em></a>） - 时间（秒）</li>
</ul>
<p>|
| 返回类型： |</p>
<p><a href="https://docs.python.org/library/constants.html#None" title="（在Python v2.7中）">没有</a></p>
<p>|</p>
<h2 id="madduxrobotslink模块">maddux.robots.link模块</h2>
<p>Link对象包含与机器人链接相关的所有信息，例如DH参数和与世界相关的位置。</p>
<dt id="maddux.robots.link.Link">_class_`maddux.robots.link.``Link`（_theta_，_offset_，_length_，_twist_，_q_lim = None_，_max_velocity = 30.0_，_link_size = 0.1_，_connector_size = 0.1 _）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/link.html#Link)</dt>
<dt id="maddux.robots.link.Link.compute_transformation_matrix">`compute_transformation_matrix`（_q _）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/link.html#Link.compute_transformation_matrix)</dt>
<p>从当前theta到新theta的变换矩阵</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **q**（[_int_](https://docs.python.org/library/functions.html#int "（在Python v2.7中）")） - 新的theta |
| 返回值： | 从当前q到提供q的变换矩阵 |
| 返回类型： | 4x4 numpy矩阵 |
<dt id="maddux.robots.link.Link.display">`display`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/link.html#Link.display)</dt>
<p>很好地显示链接的属性</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 返回类型： | [没有](https://docs.python.org/library/constants.html#None "（在Python v2.7中）") |
<dt id="maddux.robots.link.Link.is_in_collision">`is_in_collision`（_env_object _）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/link.html#Link.is_in_collision)</dt>
<p>检查手臂是否与给定的静态物体发生碰撞</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **env_object**（_maddux.objects.StaticObject_） - 检查与之冲突的对象 |
| 返回值： | 链接是否命中提供的env_object |
| 返回类型： | [布尔](https://docs.python.org/library/functions.html#bool "（在Python v2.7中）") |
<dt id="maddux.robots.link.Link.plot">`plot`（_ax _）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/link.html#Link.plot)</dt>
<p>绘制给定matplotlib图上的链接</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **ax**（_matplotlib.axes_） - 用于绘制链接的图 |
| 返回类型： | [没有](https://docs.python.org/library/constants.html#None "（在Python v2.7中）") |
<dt id="maddux.robots.link.Link.set_theta">`set_theta`（_theta _）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/link.html#Link.set_theta)</dt>
<p>将theta设置为新的theta并计算新的变换矩阵</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **theta**（[_int_](https://docs.python.org/library/functions.html#int "（在Python v2.7中）")） - 链接的新theta |
| 返回类型： | [没有](https://docs.python.org/library/constants.html#None "（在Python v2.7中）") |
<dt id="maddux.robots.link.Link.update_velocity">`update_velocity`（_加速_，_时间_）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/link.html#Link.update_velocity)</dt>
<p>在一段时间内通过某种加速作用时，更新链路的当前速度</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | 
<ul>
<li><strong>accel</strong>（<a href="https://docs.python.org/library/functions.html#int" title="（在Python v2.7中）"><em>int</em></a>） - 作用于链路的加速度（每秒弧度^ 2）</li>
<li><strong>time</strong>（<a href="https://docs.python.org/library/functions.html#int" title="（在Python v2.7中）"><em>int</em></a>） - 应用加速度的时间（秒）</li>
</ul>
<p>|
| 返回类型： |</p>
<p><a href="https://docs.python.org/library/constants.html#None" title="（在Python v2.7中）">没有</a></p>
<p>|</p>
<h2 id="madduxrobotspredefined_robots模块">maddux.robots.predefined_robots模块</h2>
<dt id="maddux.robots.predefined_robots.noodle_arm">`maddux.robots.predefined_robots.``noodle_arm`（_seg_lens_，_q0_，_base = None _）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/predefined_robots.html#noodle_arm)</dt>
<p>创建一个包含10个段的复杂臂</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | 
<ul>
<li><strong>seg_lens</strong>（<em>numpy.ndarray</em>） - 每个部分长度的1x10向量</li>
<li><strong>q0</strong>（<em>numpy.ndarray</em>） - 起始关节配置的1xN向量</li>
<li><strong>base</strong>（<em>numpy.ndarray或None</em>） - （可选）arm的可选（x，y，z）基本位置</li>
</ul>
<p>|
| 返回值： |</p>
<p>“面条”的手臂</p>
<p>|
| 返回类型： |</p>
<p>maddux.robot.Arm</p>
<p>|</p>
<dt id="maddux.robots.predefined_robots.simple_human_arm">`maddux.robots.predefined_robots.``simple_human_arm`（_seg1_len_，_seg2_len_，_q0_，_base = None _）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/predefined_robots.html#simple_human_arm)</dt>
<p>创建一个简单的类似人类的机器人手臂，具有7个链接和2个具有所需长度和起始关节配置的段</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | 
<ul>
<li><strong>seg1_len</strong>（<a href="https://docs.python.org/library/functions.html#int" title="（在Python v2.7中）"><em>int</em></a>） - 手臂第一段的长度</li>
<li><strong>seg2_len</strong>（<a href="https://docs.python.org/library/functions.html#int" title="（在Python v2.7中）"><em>int</em></a>） - 手臂第二段的长度</li>
<li><strong>q0</strong>（<em>numpy.ndarray</em>） - 起始关节配置的1xN向量</li>
<li><strong>base</strong>（<em>numpy.ndarray或None</em>） - （可选）（x，y，z）手臂基座的位置</li>
</ul>
<p>|
| 返回值： |</p>
<p>7个链接，2段“人”手臂。</p>
<p>|
| 返回类型： |</p>
<p>maddux.robot.Arm</p>
<p>|</p>
<h2 id="madduxrobotsutils模块">maddux.robots.utils模块</h2>
<p>随机收集机器人使用的实用程序</p>
<dt id="maddux.robots.utils.create_homogeneous_transform_from_point">`maddux.robots.utils.``create_homogeneous_transform_from_point`（_p _）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/utils.html#create_homogeneous_transform_from_point)</dt>
<p>创建一个齐次变换以移动到给定点</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **p**（_numpy.ndarray_） - 我们希望我们的均匀变换移动到的（x，y，z）点 |
| 返回值： | 4x4点的均匀变换 |
| 返回类型： | numpy.matrix |
<dt id="maddux.robots.utils.create_point_from_homogeneous_transform">`maddux.robots.utils.``create_point_from_homogeneous_transform`（_T _）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/utils.html#create_point_from_homogeneous_transform)</dt>
<p>从齐次变换创建一个点</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **T**（_numpy矩阵_） - 4x4齐次变换 |
| 返回值： | 变换点的（x，y，z）坐标 |
| 返回类型： | np.ndarray |
<dt id="maddux.robots.utils.get_rotation_from_homogeneous_transform">`maddux.robots.utils.``get_rotation_from_homogeneous_transform`（_变换_）[[来源]](http://bencaine.me/maddux/_modules/maddux/robots/utils.html#get_rotation_from_homogeneous_transform)</dt>
<p>提取均匀变换的旋转部分</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **transform**（_numpy.ndarray_） - 4x4齐次变换从中提取旋转矩阵。 |
| 返回值： | 3x3旋转矩阵 |
| 返回类型： | numpy.matrix |
</li>
<li>
<h1 id="madduxobjects包">maddux.objects包</h1>
<h2 id="子模块-3">子模块</h2>
<h2 id="madduxobjectsball模块">maddux.objects.ball模块</h2>
<p>投掷的球对象。</p>
<dt id="maddux.objects.ball.Ball">_class_`maddux.objects.ball.``Ball`（_position_，_radius_，_target = False _）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/ball.html#Ball)</dt>
<p>基地： <a href="http://bencaine.me/maddux/maddux.objects.html#maddux.objects.throwable.ThrowableObject" title="maddux.objects.throwable.ThrowableObject"><code>maddux.objects.throwable.ThrowableObject</code></a></p>
<dt id="maddux.objects.ball.Ball.plot">`plot`（_ax _）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/ball.html#Ball.plot)</dt>
<p>在当前位置绘制球。</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **ax**（_matplotlib.axes_） - 图上绘图。 |
| 返回值： | Matplotlib图 |
| 返回类型： | matplotlib.axes |
<h2 id="madduxobjectsdynamic模块">maddux.objects.dynamic模块</h2>
<p>动态对象的抽象基类。</p>
<dt id="maddux.objects.dynamic.DynamicObject">_class_`maddux.objects.dynamic.``DynamicObject`（_position_，_target = False _）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/dynamic.html#DynamicObject)</dt>
<p>基地： <a href="https://docs.python.org/library/functions.html#object" title="（在Python v2.7中）"><code>object</code></a></p>
<dt id="maddux.objects.dynamic.DynamicObject.attach">`attach`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/dynamic.html#DynamicObject.attach)</dt>
<p>附加到对象（停止移动）</p>
<dt id="maddux.objects.dynamic.DynamicObject.display">`display`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/dynamic.html#DynamicObject.display)</dt>
<p>显示信息</p>
<dt id="maddux.objects.dynamic.DynamicObject.plot">`plot`（_ax _）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/dynamic.html#DynamicObject.plot)</dt>
<p>在当前位置绘制动态对象</p>
<dt id="maddux.objects.dynamic.DynamicObject.step">`step`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/dynamic.html#DynamicObject.step)</dt>
<p>及时前进（一毫秒）</p>
<h2 id="madduxobjectsobstacle模块">maddux.objects.obstacle模块</h2>
<p>一种固定的长方形固体，可能会碰撞</p>
<dt id="maddux.objects.obstacle.Obstacle">_class_`maddux.objects.obstacle.``Obstacle`（_pt1_，_pt2_，_color ='r' _）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/obstacle.html#Obstacle)</dt>
<p>基地： <a href="http://bencaine.me/maddux/maddux.objects.html#maddux.objects.static.StaticObject" title="maddux.objects.static.StaticObject"><code>maddux.objects.static.StaticObject</code></a></p>
<dt id="maddux.objects.obstacle.Obstacle.display">`display`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/obstacle.html#Obstacle.display)</dt>
<p>显示障碍物属性</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 返回类型： | [没有](https://docs.python.org/library/constants.html#None "（在Python v2.7中）") |
<dt id="maddux.objects.obstacle.Obstacle.get_paths">`get_paths`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/obstacle.html#Obstacle.get_paths)</dt>
<p>返回矩形的每个曲面的路径以进行绘图。</p>
<p>：返回（底部，顶部，前部，后部，左侧，右侧）：rtype：6个4x3 numpy.ndarrays的列表</p>
<dt id="maddux.objects.obstacle.Obstacle.is_hit">`is_hit`（_位置_）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/obstacle.html#Obstacle.is_hit)</dt>
<p>检查矩形是否被点或路径击中</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **position**（_numpy.ndarray或numpy.matrix_） - 一个对象位置（x，y，z）或位置，如果它是一个路径（[x1，x2，..]，[y1，y2，..]，[z1， z2，..] |
| 返回值： | 障碍物是否被点或路径击中 |
| 返回类型： | [布尔](https://docs.python.org/library/functions.html#bool "（在Python v2.7中）") |
<dt id="maddux.objects.obstacle.Obstacle.is_hit_by_sphere">`is_hit_by_sphere`（_中心_，_半径_）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/obstacle.html#Obstacle.is_hit_by_sphere)</dt>
<p>检查矩形是否被球体击中</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | 
<ul>
<li><strong>中心</strong>（<em>numpy.ndarray</em>） - 球体的中心（x，y，z）</li>
<li><strong>radius</strong>（<a href="https://docs.python.org/library/functions.html#int" title="（在Python v2.7中）"><em>int</em></a>） - 球体的半径</li>
</ul>
<p>|
| 返回值： |</p>
<p>障碍物是否被球体击中</p>
<p>|
| 返回类型： |</p>
<p><a href="https://docs.python.org/library/functions.html#bool" title="（在Python v2.7中）">布尔</a></p>
<p>|</p>
<dt id="maddux.objects.obstacle.Obstacle.plot">`plot`（_ax _）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/obstacle.html#Obstacle.plot)</dt>
<p>在其位置绘制障碍物</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **ax**（_matplotlib.axes_） - 图上绘图 |
| Rtpye： | 没有 |
<h2 id="madduxobjectsstatic模块">maddux.objects.static模块</h2>
<p>静态对象的抽象基类。</p>
<dt id="maddux.objects.static.StaticObject">_班_`maddux.objects.static.``StaticObject`[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/static.html#StaticObject)</dt>
<p>基地： <a href="https://docs.python.org/library/functions.html#object" title="（在Python v2.7中）"><code>object</code></a></p>
<dt id="maddux.objects.static.StaticObject.display">`display`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/static.html#StaticObject.display)</dt>
<p>显示有关静态对象的相关数据。</p>
<dt id="maddux.objects.static.StaticObject.is_hit">`is_hit`（_位置_）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/static.html#StaticObject.is_hit)</dt>
<p>判断另一个对象是否命中静态对象</p>
<dt id="maddux.objects.static.StaticObject.plot">`plot`（_ax _）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/static.html#StaticObject.plot)</dt>
<p>绘制静态对象。</p>
<h2 id="madduxobjectstarget模块">maddux.objects.target模块</h2>
<p>某物可能与之碰撞的静止物体。</p>
<dt id="maddux.objects.target.Target">_class_`maddux.objects.target.``Target`（_position_，_radius _）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/target.html#Target)</dt>
<p>基地： <a href="http://bencaine.me/maddux/maddux.objects.html#maddux.objects.static.StaticObject" title="maddux.objects.static.StaticObject"><code>maddux.objects.static.StaticObject</code></a></p>
<dt id="maddux.objects.target.Target.display">`display`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/target.html#Target.display)</dt>
<p>显示目标属性：rtpye：无</p>
<dt id="maddux.objects.target.Target.is_hit">`is_hit`（_位置_）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/target.html#Target.is_hit)</dt>
<p>检查目标是否被击中。</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **position**（_numpy.array_） - 对象的位置 |
| 返回类型： | 布尔 |
<dt id="maddux.objects.target.Target.plot">`plot`（_ax _）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/target.html#Target.plot)</dt>
<p>在目标位置绘制目标。：param ax：图上的情节。：type ax：matplotlib图：rtype：matplotlib图</p>
<dt id="maddux.objects.target.Target.plot_data">`plot_data`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/target.html#Target.plot_data)</dt>
<p>获取目标位置的绘图数据：rtype：整数的3元组</p>
<h2 id="madduxobjectsthrowable模块">maddux.objects.throwable模块</h2>
<p>一个基本可抛出的对象类，它对重力，速度等特征进行编码。</p>
<dt id="maddux.objects.throwable.ThrowableObject">_class_`maddux.objects.throwable.``ThrowableObject`（_position_，_target = False _）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/throwable.html#ThrowableObject)</dt>
<p>基地： <a href="http://bencaine.me/maddux/maddux.objects.html#maddux.objects.dynamic.DynamicObject" title="maddux.objects.dynamic.DynamicObject"><code>maddux.objects.dynamic.DynamicObject</code></a></p>
<dt id="maddux.objects.throwable.ThrowableObject.attach">`attach`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/throwable.html#ThrowableObject.attach)</dt>
<p>将对象附加到其当前位置</p>
<dt id="maddux.objects.throwable.ThrowableObject.display">`display`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/throwable.html#ThrowableObject.display)</dt>
<p>显示有关对象的信息</p>
<dt id="maddux.objects.throwable.ThrowableObject.step">`step`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/throwable.html#ThrowableObject.step)</dt>
<p>更新一个时间步（1毫秒）</p>
<dt id="maddux.objects.throwable.ThrowableObject.throw">`throw`（_速度_）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/throwable.html#ThrowableObject.throw)</dt>
<p>扔一个物体。</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **速度**（_np.ndarray_） - 投掷速度（vx，vy，vz） |
| 返回类型： | [没有](https://docs.python.org/library/constants.html#None "（在Python v2.7中）") |
</li>
<li>
<h1 id="madduxobjects包-2">maddux.objects包</h1>
<h2 id="子模块-4">子模块</h2>
<h2 id="madduxobjectsball模块-2">maddux.objects.ball模块</h2>
<p>投掷的球对象。</p>
<dt id="maddux.objects.ball.Ball">_class_`maddux.objects.ball.``Ball`（_position_，_radius_，_target = False _）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/ball.html#Ball)</dt>
<p>基地： <a href="http://bencaine.me/maddux/maddux.objects.html#maddux.objects.throwable.ThrowableObject" title="maddux.objects.throwable.ThrowableObject"><code>maddux.objects.throwable.ThrowableObject</code></a></p>
<dt id="maddux.objects.ball.Ball.plot">`plot`（_ax _）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/ball.html#Ball.plot)</dt>
<p>在当前位置绘制球。</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **ax**（_matplotlib.axes_） - 图上绘图。 |
| 返回值： | Matplotlib图 |
| 返回类型： | matplotlib.axes |
<h2 id="madduxobjectsdynamic模块-2">maddux.objects.dynamic模块</h2>
<p>动态对象的抽象基类。</p>
<dt id="maddux.objects.dynamic.DynamicObject">_class_`maddux.objects.dynamic.``DynamicObject`（_position_，_target = False _）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/dynamic.html#DynamicObject)</dt>
<p>基地： <a href="https://docs.python.org/library/functions.html#object" title="（在Python v2.7中）"><code>object</code></a></p>
<dt id="maddux.objects.dynamic.DynamicObject.attach">`attach`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/dynamic.html#DynamicObject.attach)</dt>
<p>附加到对象（停止移动）</p>
<dt id="maddux.objects.dynamic.DynamicObject.display">`display`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/dynamic.html#DynamicObject.display)</dt>
<p>显示信息</p>
<dt id="maddux.objects.dynamic.DynamicObject.plot">`plot`（_ax _）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/dynamic.html#DynamicObject.plot)</dt>
<p>在当前位置绘制动态对象</p>
<dt id="maddux.objects.dynamic.DynamicObject.step">`step`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/dynamic.html#DynamicObject.step)</dt>
<p>及时前进（一毫秒）</p>
<h2 id="madduxobjectsobstacle模块-2">maddux.objects.obstacle模块</h2>
<p>一种固定的长方形固体，可能会碰撞</p>
<dt id="maddux.objects.obstacle.Obstacle">_class_`maddux.objects.obstacle.``Obstacle`（_pt1_，_pt2_，_color ='r' _）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/obstacle.html#Obstacle)</dt>
<p>基地： <a href="http://bencaine.me/maddux/maddux.objects.html#maddux.objects.static.StaticObject" title="maddux.objects.static.StaticObject"><code>maddux.objects.static.StaticObject</code></a></p>
<dt id="maddux.objects.obstacle.Obstacle.display">`display`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/obstacle.html#Obstacle.display)</dt>
<p>显示障碍物属性</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 返回类型： | [没有](https://docs.python.org/library/constants.html#None "（在Python v2.7中）") |
<dt id="maddux.objects.obstacle.Obstacle.get_paths">`get_paths`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/obstacle.html#Obstacle.get_paths)</dt>
<p>返回矩形的每个曲面的路径以进行绘图。</p>
<p>：返回（底部，顶部，前部，后部，左侧，右侧）：rtype：6个4x3 numpy.ndarrays的列表</p>
<dt id="maddux.objects.obstacle.Obstacle.is_hit">`is_hit`（_位置_）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/obstacle.html#Obstacle.is_hit)</dt>
<p>检查矩形是否被点或路径击中</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **position**（_numpy.ndarray或numpy.matrix_） - 一个对象位置（x，y，z）或位置，如果它是一个路径（[x1，x2，..]，[y1，y2，..]，[z1， z2，..] |
| 返回值： | 障碍物是否被点或路径击中 |
| 返回类型： | [布尔](https://docs.python.org/library/functions.html#bool "（在Python v2.7中）") |
<dt id="maddux.objects.obstacle.Obstacle.is_hit_by_sphere">`is_hit_by_sphere`（_中心_，_半径_）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/obstacle.html#Obstacle.is_hit_by_sphere)</dt>
<p>检查矩形是否被球体击中</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | 
<ul>
<li><strong>中心</strong>（<em>numpy.ndarray</em>） - 球体的中心（x，y，z）</li>
<li><strong>radius</strong>（<a href="https://docs.python.org/library/functions.html#int" title="（在Python v2.7中）"><em>int</em></a>） - 球体的半径</li>
</ul>
<p>|
| 返回值： |</p>
<p>障碍物是否被球体击中</p>
<p>|
| 返回类型： |</p>
<p><a href="https://docs.python.org/library/functions.html#bool" title="（在Python v2.7中）">布尔</a></p>
<p>|</p>
<dt id="maddux.objects.obstacle.Obstacle.plot">`plot`（_ax _）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/obstacle.html#Obstacle.plot)</dt>
<p>在其位置绘制障碍物</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **ax**（_matplotlib.axes_） - 图上绘图 |
| Rtpye： | 没有 |
<h2 id="madduxobjectsstatic模块-2">maddux.objects.static模块</h2>
<p>静态对象的抽象基类。</p>
<dt id="maddux.objects.static.StaticObject">_班_`maddux.objects.static.``StaticObject`[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/static.html#StaticObject)</dt>
<p>基地： <a href="https://docs.python.org/library/functions.html#object" title="（在Python v2.7中）"><code>object</code></a></p>
<dt id="maddux.objects.static.StaticObject.display">`display`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/static.html#StaticObject.display)</dt>
<p>显示有关静态对象的相关数据。</p>
<dt id="maddux.objects.static.StaticObject.is_hit">`is_hit`（_位置_）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/static.html#StaticObject.is_hit)</dt>
<p>判断另一个对象是否命中静态对象</p>
<dt id="maddux.objects.static.StaticObject.plot">`plot`（_ax _）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/static.html#StaticObject.plot)</dt>
<p>绘制静态对象。</p>
<h2 id="madduxobjectstarget模块-2">maddux.objects.target模块</h2>
<p>某物可能与之碰撞的静止物体。</p>
<dt id="maddux.objects.target.Target">_class_`maddux.objects.target.``Target`（_position_，_radius _）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/target.html#Target)</dt>
<p>基地： <a href="http://bencaine.me/maddux/maddux.objects.html#maddux.objects.static.StaticObject" title="maddux.objects.static.StaticObject"><code>maddux.objects.static.StaticObject</code></a></p>
<dt id="maddux.objects.target.Target.display">`display`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/target.html#Target.display)</dt>
<p>显示目标属性：rtpye：无</p>
<dt id="maddux.objects.target.Target.is_hit">`is_hit`（_位置_）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/target.html#Target.is_hit)</dt>
<p>检查目标是否被击中。</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **position**（_numpy.array_） - 对象的位置 |
| 返回类型： | 布尔 |
<dt id="maddux.objects.target.Target.plot">`plot`（_ax _）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/target.html#Target.plot)</dt>
<p>在目标位置绘制目标。：param ax：图上的情节。：type ax：matplotlib图：rtype：matplotlib图</p>
<dt id="maddux.objects.target.Target.plot_data">`plot_data`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/target.html#Target.plot_data)</dt>
<p>获取目标位置的绘图数据：rtype：整数的3元组</p>
<h2 id="madduxobjectsthrowable模块-2">maddux.objects.throwable模块</h2>
<p>一个基本可抛出的对象类，它对重力，速度等特征进行编码。</p>
<dt id="maddux.objects.throwable.ThrowableObject">_class_`maddux.objects.throwable.``ThrowableObject`（_position_，_target = False _）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/throwable.html#ThrowableObject)</dt>
<p>基地： <a href="http://bencaine.me/maddux/maddux.objects.html#maddux.objects.dynamic.DynamicObject" title="maddux.objects.dynamic.DynamicObject"><code>maddux.objects.dynamic.DynamicObject</code></a></p>
<dt id="maddux.objects.throwable.ThrowableObject.attach">`attach`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/throwable.html#ThrowableObject.attach)</dt>
<p>将对象附加到其当前位置</p>
<dt id="maddux.objects.throwable.ThrowableObject.display">`display`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/throwable.html#ThrowableObject.display)</dt>
<p>显示有关对象的信息</p>
<dt id="maddux.objects.throwable.ThrowableObject.step">`step`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/throwable.html#ThrowableObject.step)</dt>
<p>更新一个时间步（1毫秒）</p>
<dt id="maddux.objects.throwable.ThrowableObject.throw">`throw`（_速度_）[[来源]](http://bencaine.me/maddux/_modules/maddux/objects/throwable.html#ThrowableObject.throw)</dt>
<p>扔一个物体。</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | **速度**（_np.ndarray_） - 投掷速度（vx，vy，vz） |
| 返回类型： | [没有](https://docs.python.org/library/constants.html#None "（在Python v2.7中）") |
<hr>
<h1 id="madduxexamples包">maddux.examples包</h1>
<h2 id="子模块-5">子模块</h2>
<h2 id="madduxexamplesarm_animation模块">maddux.examples.arm_animation模块</h2>
<dt id="maddux.examples.arm_animation.arm_animation">`maddux.examples.arm_animation.``arm_animation`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/examples/arm_animation.html#arm_animation)</dt>
<p>动画手臂移动触摸球</p>
<h2 id="madduxexamplesarm_ball_animation模块">maddux.examples.arm_ball_animation模块</h2>
<dt id="maddux.examples.arm_ball_animation.arm_ball_animation">`maddux.examples.arm_ball_animation.``arm_ball_animation`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/examples/arm_ball_animation.html#arm_ball_animation)</dt>
<p>为拿着球的手臂设置动画，移动到任意位置。</p>
<h2 id="madduxexamplesball_animation模块">maddux.examples.ball_animation模块</h2>
<dt id="maddux.examples.ball_animation.ball_animation">`maddux.examples.ball_animation.``ball_animation`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/examples/ball_animation.html#ball_animation)</dt>
<p>制作几个球并让它们以不同的速度在环境中移动。</p>
<h2 id="madduxexamplesfind_jacob0模块">maddux.examples.find_jacob0模块</h2>
<dt id="maddux.examples.find_jacob0.find_jacob0">`maddux.examples.find_jacob0.``find_jacob0`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/examples/find_jacob0.html#find_jacob0)</dt>
<p>展示如何计算am arm的jacobian。</p>
<h2 id="madduxexamplesobstacle_collision模块">maddux.examples.obstacle_collision模块</h2>
<dt id="maddux.examples.obstacle_collision.obstacle_collision">`maddux.examples.obstacle_collision.``obstacle_collision`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/examples/obstacle_collision.html#obstacle_collision)</dt>
<p>测试最终配置的手臂是否与我们的任何一个障碍物接触。</p>
<h2 id="madduxexamplesplot模块">maddux.examples.plot模块</h2>
<dt id="maddux.examples.plot.plot">`maddux.examples.plot.``plot`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/examples/plot.html#plot)</dt>
<p>给出一个包含一些对象和机器人的环境的通用绘图示例。</p>
<h2 id="madduxexamplesplot_arm模块">maddux.examples.plot_arm模块</h2>
<dt id="maddux.examples.plot_arm.plot_arm">`maddux.examples.plot_arm.``plot_arm`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/examples/plot_arm.html#plot_arm)</dt>
<p>显示如何绘制手臂。</p>
<h2 id="madduxexamplesplot_obstacle模块">maddux.examples.plot_obstacle模块</h2>
<dt id="maddux.examples.plot_obstacle.plot_obstacle">`maddux.examples.plot_obstacle.``plot_obstacle`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/examples/plot_obstacle.html#plot_obstacle)</dt>
<p>在环境中创建并绘制障碍物。</p>
<h2 id="madduxexamplestutorial模块">maddux.examples.tutorial模块</h2>
<dt id="maddux.examples.tutorial.tutorial">`maddux.examples.tutorial.``tutorial`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/examples/tutorial.html#tutorial)</dt>
<p>我们的文档教程中的代码</p>
<h1 id="madduxutils包">maddux.utils包</h1>
<h2 id="子模块-6">子模块</h2>
<h2 id="madduxutilsanimate_path模块">maddux.utils.animate_path模块</h2>
<dt id="maddux.utils.animate_path.animate_path">`maddux.utils.animate_path.``animate_path`（_environment_，_input_file_，_output_file = None _）[[来源]](http://bencaine.me/maddux/_modules/maddux/utils/animate_path.html#animate_path)</dt>
<p>加载已保存的路径并为其设置动画</p>
<colgroup><col class="field-name"><col class="field-body"></colgroup>
| 参数： | 
<ul>
<li><strong>environment</strong>（<a href="https://docs.python.org/library/functions.html#str" title="（在Python v2.7中）"><em>str</em></a>） - 发生路径的环境</li>
<li><strong>input_file</strong>（<a href="https://docs.python.org/library/functions.html#str" title="（在Python v2.7中）"><em>str</em></a>） - 保存联合配置的文件</li>
<li><strong>output_file</strong>（<em>str或None</em>） - 将动画保存为.mp4的文件</li>
</ul>
<p>|
| Rtpye： |</p>
<p>没有</p>
<p>|</p>
<dt id="maddux.utils.animate_path.main">`maddux.utils.animate_path.``main`（）[[来源]](http://bencaine.me/maddux/_modules/maddux/utils/animate_path.html#main)</dt>
<p>运行CLI以获取动画参数</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RoboND-Kinematics-Project 为Kuka R210机器人手臂提供逆运动学分析]]></title>
        <id>https://blog.bioprinting.site/post/KQATQGv4O</id>
        <link href="https://blog.bioprinting.site/post/KQATQGv4O">
        </link>
        <updated>2019-05-12T14:23:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="项目运动学拾取和放置">项目：运动学拾取和放置</h2>
<h4 id=""><a href="https://github.com/zenetio/RoboND-Kinematics-Project#carlos-r-lacerda"></a>Carlos R. Lacerda</h4>
<hr>
<p><strong>概述：</strong></p>
<p>该项目的目标是为Kuka R210机器人手臂提供运动学分析。在模拟中，我们处理一个任务来挑选，移动和放下一个对象到一个盒子里。在这个项目中，我将使用ROS系统和Gazebo + Rviz作为模拟环境。使用反向运动学（IK），我们可以找到正确的轨迹来驱动手臂将物体放在所需的位置。可以在此<a href="https://github.com/zenetio/RoboND-Kinematics-Project.git">存储库中</a>找到完整的项目，这是<a href="https://youtu.be/Zh5tTvKKrH4">视频</a>。</p>
<p><a href="https://github.com/zenetio/RoboND-Kinematics-Project/blob/master/misc_images/first_try.png"><img src="https://github.com/zenetio/RoboND-Kinematics-Project/raw/master/misc_images/first_try.png" alt="替代文字"></a></p>
<p>图1。</p>
<h3 id="-2"><a href="https://github.com/zenetio/RoboND-Kinematics-Project#kinematic-analysis-model-of-6-dof-kuka-r210-robot"></a>6自由度Kuka R210机器人运动分析模型</h3>
<h4 id="-3"><a href="https://github.com/zenetio/RoboND-Kinematics-Project#1-forward-kinematic"></a>1.前进运动学</h4>
<p>运动学分析主要包括两个方面，即正向运动学分析（FK）和反向运动学分析（IK）。正向运动学分析意味着Kuka的末端执行器的姿态可以用链接的给定几何参数和关节的变量来计算。机器人具有平移或旋转关节。平移沿着给定的矢量方向在空间中移动有限距离，并且可以通过相邻链路之间的以下均匀变换矩阵来描述，如图2所示。</p>
<p><a href="https://github.com/zenetio/RoboND-Kinematics-Project/blob/master/misc_images/homo.png"><img src="https://github.com/zenetio/RoboND-Kinematics-Project/raw/master/misc_images/homo.png" alt="替代文字"></a></p>
<p>图2。</p>
<p>正向运动（FK）问题的解决方案是直线计算，其中我们可以使用关节角度并找到机器人手臂的末端执行器姿势（位置+方向）。下面的图3显示了FK和IK之间的分析模型。</p>
<p><a href="https://github.com/zenetio/RoboND-Kinematics-Project/blob/master/misc_images/fk_ik.png"><img src="https://github.com/zenetio/RoboND-Kinematics-Project/raw/master/misc_images/fk_ik.png" alt="替代文字"></a></p>
<p>图3。</p>
<p>但是什么是联系或联合角度？我们将在下一节中看到。可以使用Denavit-Hartenberg（DH）惯例导出机器人的链接和关节角度之间的关系。</p>
<h3 id="-4"><a href="https://github.com/zenetio/RoboND-Kinematics-Project#2-dh-parameters"></a>2. DH参数</h3>
<p>读取kr210.urdf.xacro文件以执行Kuka KR210机器人的运动学分析并得出其DH参数，得到下表1。</p>
<p><em>表格1。</em></p>
<table>
<thead>
<tr>
<th>链接</th>
<th>α（I-1）</th>
<th>一个第（i-1）</th>
<th>d（I-1）</th>
<th>THETA（ⅰ）</th>
</tr>
</thead>
<tbody>
<tr>
<td>0-&gt; 1</td>
<td>0</td>
<td>0</td>
<td>0.75</td>
<td>0</td>
</tr>
<tr>
<td>1-&gt; 2</td>
<td>-pi / 2</td>
<td>0.35</td>
<td>0</td>
<td>-pi / 2 + q2</td>
</tr>
<tr>
<td>2-&gt; 3</td>
<td>0</td>
<td>1.25</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>3-&gt; 4</td>
<td>-pi / 2</td>
<td>-0.054</td>
<td>1.50</td>
<td>0</td>
</tr>
<tr>
<td>4-&gt; 5</td>
<td>Pi / 2相</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>5-&gt; 6</td>
<td>-pi / 2</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>6-&gt; EE</td>
<td>0</td>
<td>0</td>
<td>0.303</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>DH参数由坐标系i-1到i的变换通过表1中给出的旋转和平移变换给出。注意，这是DH惯例的修改惯例。图4显示了表1中描述的每个变量的位置。</p>
<p><a href="https://github.com/zenetio/RoboND-Kinematics-Project/blob/master/misc_images/kr210_schematic.png"><img src="https://github.com/zenetio/RoboND-Kinematics-Project/raw/master/misc_images/kr210_schematic.png" alt="替代文字"></a></p>
<p>图4。</p>
<p>在Gazebo中，DH参数表由URDF文件描述。URDF文件中详细描述了所有关节和链接。下面的图5显示了Kuka R210 URDF文件的一部分。</p>
<p><a href="https://github.com/zenetio/RoboND-Kinematics-Project/blob/master/misc_images/urdf.png"><img src="https://github.com/zenetio/RoboND-Kinematics-Project/raw/master/misc_images/urdf.png" alt="替代文字"></a></p>
<p>图5。</p>
<p>例如，请注意，joint_3与父link_2和子link_3链接。</p>
<h3 id="-5"><a href="https://github.com/zenetio/RoboND-Kinematics-Project#3-implementation-of-forward-kinematics"></a>3.正向运动学的实现</h3>
<p>因此，使用表1中的值和图2中描述的均匀变换公式，我们可以创建关于每个关节的各个变换矩阵。此外，我们还可以仅使用末端效应器（抓取器）姿势在base_link和gripper_link之间生成广义齐次变换。</p>
<p>例如，base_link和link_1（T0_1）的同构变换可以写成如下：</p>
<p>def  Tn_m（th，alpha，a，d）：
t =矩阵（[[cos（th），             - sin（th），             0，a]，
[sin（th）* cos（alpha），cos（th）* cos（alpha），- sin（alpha），- sin（alpha）* d]，
[sin（th）* sin（alpha），cos（th）* sin（alpha），cos（alpha），cos（alpha）* d]，
[                    0，                    0，            0，                1 ]]）
＃从base_link到LINK_1转化
T0_1 = Tn_m（Q1，alpha0，A0，D1）.subs（S）</p>
<p>我们对所有其他链接重复相同的方法</p>
<p>＃从link_1到Link_2的转换
T1_2 = Tn_m（q2，alpha1，a1，d2）.subs（s）
＃从link_2到Link_3的
转换T2_3 = Tn_m（q3，alpha2，a2，d3）.subs（s）
＃来自link_3的转换到Link_4
T3_4 = Tn_m（q4，alpha3，a3，d4）.subs（s）
＃从link_4到Link_5的
转换T4_5 = Tn_m（q5，alpha4，a4，d5）.subs（s）
＃从link_5到Link_6的
转换T5_6 = Tn_m（q6，alpha5，a5，d6）.subs（s）
＃从link_6到夹子的转换G
T6_G  = Tn_m（q7，alpha6，a6，d7）.subs（s）</p>
<p>然后使用上面的等式，对于从base_link到gripper_link的每个同构变换，我们有：</p>
<p>T0_1 =矩阵（[[COS（Q1），-罪（Q1），0，     0 ]，
[罪（Q1），COS（Q1），0，     0 ]，
[       0，         0，1，0.75 ]，
[       0，         0，0，     1 ]]）</p>
<p>T1_2 =矩阵（[[罪（Q2），COS（Q2），0，0.35 ]，
[       0，         0，1，     0 ]，
[COS（Q2），-罪（Q2），0，     0 ]，
[       0，         0，0，     1 ]]）</p>
<p>T2_3 =矩阵（[[COS（Q3），-罪（Q3），0，1.25 ]，
[罪（Q3），COS（Q3），0，     0 ]，
[       0，         0，1，     0 ]，
[       0，        0，0，     1 ]]）</p>
<p>T3_4 =矩阵（[[COS（Q4），-罪（Q4），0，- 0.054 ]，
[        0，         0，1，     1.5 ]，
[ -罪（Q4），- COS （Q4），0，       0 ]，
[        0，         0，0，       1 ]]）</p>
<p>T4_5 =矩阵（[[COS（Q5），-罪（Q5），   0，0 ]，
[       0，         0，- 1，0 ]，
[罪（Q5），COS（Q5），   0，0 ]，
[       0，         0，   0，1 ]]）</p>
<p>T5_6 =矩阵（[[COS（Q6），- SIN（Q6），0，0 ]，
[        0，         0，1，0 ]，
[ - SIN（Q6），- COS（Q6），0，0 ]，
[        0，         0，0，1 ]]）T6_G =矩阵（[[ 1，0，0，      0 ]，
[ 0，1，0，      0 ]，
[ 0，0，1，0.303 ]，
[ 0，</p>
<p>0，0，      1 ]]）</p>
<p>因此，我们可以计算抓手姿势的完整FK。</p>
<p>注意，均匀变换具有平移和旋转部分。使用此属性，我们可以重新排列同构变换并编写以下内容：</p>
<p><a href="https://github.com/zenetio/RoboND-Kinematics-Project/blob/master/misc_images/wc.png"><img src="https://github.com/zenetio/RoboND-Kinematics-Project/raw/master/misc_images/wc.png" alt="替代文字"></a></p>
<p>图6。</p>
<p>它会导致手腕中心姿势。</p>
<h3 id="-6"><a href="https://github.com/zenetio/RoboND-Kinematics-Project#4-implementation-of-inverse-kinematics"></a>4.反向运动学的实现</h3>
<p>逆运动学分析与正向运动学分析相反。现在情况有点复杂了。给定期望的末端效应器姿势，我们需要找到将实现到目标位置的正确轨迹的关节角度的值。利用反向运动学解决方案，可以确定每个关节角度的值，以便将臂放置在期望的位置和方向。</p>
<p>也就是说，我们需要找到q1，q2，q3，q4，q5和q6的值，这些值会将手臂移动到所需的姿势。</p>
<p><a href="https://github.com/zenetio/RoboND-Kinematics-Project/blob/master/misc_images/geometry.png"><img src="https://github.com/zenetio/RoboND-Kinematics-Project/raw/master/misc_images/geometry.png" alt="替代文字"></a></p>
<p>图7。</p>
<p>使用臂的一些几何特性，q1，q2和q3的值非常严格，如图7所示</p>
<p>q1角度可以从手臂在平面X0-Y0上的投影中找到，我们得到：</p>
<p>theta1 = atan2（Wc [ 1 ]，Wc [ 0 ]）</p>
<p>我们可以从下面的图7和图8得到theta2和theta3。</p>
<p><a href="https://github.com/zenetio/RoboND-Kinematics-Project/blob/master/misc_images/misc3.png"><img src="https://github.com/zenetio/RoboND-Kinematics-Project/raw/master/misc_images/misc3.png" alt="替代文字"></a></p>
<p>图8。</p>
<p>＃使用几何计算三角形边
side_a = 1.501
side_b = sqrt（ pow（（sqrt（Wc [ 0 ] * Wc [ 0 ] + Wc [ 1 ] * Wc [ 1 ]） - 0.35）， 2） + pow（（ Wc [ 2 ] - 0.75）， 2））
side_c = 1.25
＃使用几何来计算三角形角度
angle_a = acos（（side_b）* side_b + side_c * side_c - side_a * side_a）/（2  * side_b * side_c））
angle_b = acos（（side_a * side_a + side_c * side_c - side_b * side_b）/（2  * side_a * side_c））
＃ calculate theta2
theta2 = np.pi /  2。- angle_a - atan2（Wc [2 ] -  0.75，SQRT（WC [ 0 ] * Wc中[ 0 ] + Wc中[ 1 ] * Wc中[ 1 ]）-  0.35）
＃计算theta3
theta3 = np.pi /  2。-（angle_b +  0.036）</p>
<p>最后，使用旋转矩阵R3_6和更多几何属性，我们可以找到剩余角度q4，q5和q6。</p>
<p>＃使用旋转矩阵来计算剩余的关节角度
＃从变换矩阵我们可以提取的旋转矩阵
R0_3 = oClass.T0_3 [ 0： 3， 0： 3 ]
R0_3 = R0_3.evalf（潜艇= {Q1：theta1，Q2：theta2， Q3：theta3}）
R3_6 = R0_3.T * Rot_G＃现在得到欧拉从旋转矩阵角度＃计算theta4
theta4 = ATAN2（R3_6 [ 2， 2 ]， - R3_6 [ 0</p>
<p>，2 ]）
＃计算theta5
theta5 = ATAN2（SQRT（R3_6 [ 0，2 ] * R3_6 [ 0，2 ] + R3_6 [ 2，2 ] * R3_6 [ 2，2 ]），R3_6 [ 1，2 ]）
＃计算theta6
theta6 = ATAN2（- R3_6 [ 1，1 ]，R3_6 [ 1，0 ]）
＃因为该模型具有某些奇点，我们可以考虑
如果（SIN（theta5）&lt;  0）：
theta4 = ATAN2（- R3_6 [ 2，2 ]，R3_6 [ 0，2 ]）
theta6 = ATAN2（R3_6 [ 1，1 ]，- R3_6 [ 1，0 ]）</p>
<h3 id="-7"><a href="https://github.com/zenetio/RoboND-Kinematics-Project#5-project-implementation"></a>5.项目实施</h3>
<ul>
<li>模拟环境：ROS运行Gazebo + Rviz</li>
<li>语言：Python和C ++</li>
<li>操作系统：在VMware Pro上运行的Ubuntu 16.04</li>
</ul>
<p>为了运行这个项目，我在<code>IK_server.py</code>脚本文件中实现了FK和IK的代码。python代码接收末端效应器姿势，处理运动学分析并返回具有关节角度的阵列列表，该关节角度将允许手臂移动到新的期望姿势。</p>
<h3 id="-8"><a href="https://github.com/zenetio/RoboND-Kinematics-Project#6-improvements"></a>6.改进</h3>
<p>我不得不优化Kuka手臂未能挑选物体的一些问题。IK正在从开始到结束放置位置正确地移动手臂但是该过程没有成功，因为夹子未能拾取对象。然后我在<code>trajectory_sampler.cpp</code>代码中做了两处更改：</p>
<ul>
<li>在抓手处理功能之前增加了4秒</li>
<li>夹持器角度从0.02增加到0.025</li>
</ul>
<p>然后这两个变化降低了抓手未能保持对象的概率。</p>
<p>另一个挑战是找到一个解决方案，以避免在循环内运行符号代码来管理从手臂接收到的姿势。符号变量的计算需要很长时间，主要是因为我们有很多矩阵运算。因此，例如，考虑完成符号操作60秒，然后乘以50,60,100个迭代，您将获得大量的计算时间。在最后，这将是每个周期无法接受的时间。</p>
<p>为了解决这个问题，我创建了一个类来管理所有符号变量和计算的创建。然后我执行了一次类代码，创建了一个被序列化并保存到磁盘的对象。所以，在项目中我<code>IK_server.py</code>只需要加载（反序列化）对象代码。这种方法只需几分之一秒，这意味着在循环中管理FK和IK分析的快速计算时间。</p>
<p><a href="https://github.com/zenetio/RoboND-Kinematics-Project/blob/master/misc_images/last_try.png"><img src="https://github.com/zenetio/RoboND-Kinematics-Project/raw/master/misc_images/last_try.png" alt="替代文字"></a></p>
<p>图9。</p>
<p>图9显示了10次尝试后的最终过程。请注意，框中有3个引脚，下拉框中有8个引脚。一个是第11周期，不得考虑。但是其他2个都在盒子里，因为即使夹子姿势是正确的，它也不能将物体保持在夹子中。</p>
<p>因此，我们可以得出结论，FK和IK计算中的误差非常低，如果我们有更好的抓手操作，我们可以在10次尝试中达到100％。</p>
<h3 id="-9"><a href="https://github.com/zenetio/RoboND-Kinematics-Project#future-improvements"></a>未来的改进</h3>
<p>改进夹具操作以避免即使夹具处于正确姿势时也会失败。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ROS-IGTL-Bridge：使用ROS环境进行图像引导治疗的开放式网络接口]]></title>
        <id>https://blog.bioprinting.site/post/AKuuLRT2E</id>
        <link href="https://blog.bioprinting.site/post/AKuuLRT2E">
        </link>
        <updated>2019-05-12T13:59:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="目的">目的</h3>
<p>随着人们对手术机器人系统先进图像引导的兴趣日益增加，机器人设备和医学图像计算软件的快速集成和测试在研究和开发中变得至关重要。最大限度地利用在不同领域广泛接受的平台上构建的现有工程资源，例如机器人中的机器人操作系统（ROS）和医学图像计算中的3D切片器可以简化这些任务。我们提出了一个集成在ROS中的新的开放式网桥接口，以确保无缝的跨平台数据共享。</p>
<h3 id="方法">方法</h3>
<p>实现了名为ROS-IGTL-Bridge的ROS节点。它使用OpenIGTLink协议在ROS环境和外部医学图像计算软件之间建立TCP / IP网络连接。该节点同时通过网络将ROS消息输出到外部软件，反之亦然，从而允许基于ROS的设备和医学图像计算平台之间的无缝和透明数据共享。</p>
<h3 id="结果">结果</h3>
<p>性能测试表明，网桥可以成功地在两个方向上以30 fps流式传输变换，字符串，点和图像。变换，字符串和点的数据传输延迟小于1.2 ms，而rrom VGA图像的数据传输延迟小于1.2 ms。另外一项测试还表明，该桥可以实现900 fps的变换。此外，该桥在两个具有代表性的系统中进行了演示：模拟图像引导的手术机器人设置，包括3D切片机，以及带有ROS的Lego Mindstorms，作为IGT研究的原型和教育平台; 和智能组织自主机器人（STAR）手术设置与3D切片机。</p>
<h3 id="结论">结论</h3>
<p>该研究表明，该桥实现了ROS与医学图像计算软件之间的跨平台数据共享。这将允许由诸如3D切片器的医学图像计算软件提供的基于图像的高级计划/导航快速且无缝地集成到基于ROS的手术机器人系统中。</p>
<p>**关键词：**ROS，OpenIGTLink，界面，手术机器人，图像引导治疗</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/" title="转到此页面的其他部分">去：</a></p>
<h2 id="1简介">1简介</h2>
<p>机器人系统在图像引导治疗（IGT）中的应用已经在许多医学领域得到扩展，导致现代医学技术的不断发展[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R1">1</a> ]。机器人辅助腹腔镜手术在美国和其他发达国家的根治性前列腺切除术中已经很常见[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R2">2</a> ]并且在其他手术中扩大了其用途。机器人导管系统已被用于各种血管内手术[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R3">3</a> ]和心律失常手术[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R4">4</a> ]。机器人放射外科系统已被用于治疗肺，肝，胰腺，脊柱，肾，头部和颈部以及前列腺的肿瘤[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R5">5</a> ]。</p>
<p>虽然今天的大多数临床机器人系统都是为了通过遵循他们的命令和计划来帮助外科医生，但人们越来越关注自动化辅助，其中机器人系统接管一些外科医生的常规任务，例如切割和缝合，让外科医生集中于高级别外科决策[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R6">6</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R7">7</a> ]。随着对自主技术的兴趣日益增加，研究人员和外科医生在手术室中面临着各种各样的技术。这种不断增长的兴趣促使医疗机器人社区利用机器人操作系统（ROS）中的各种功能<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R8"> [8]</a>]，例如计算机视觉，传感，运动学，模拟和运动规划。机器人研究系统包括医疗机器人Raven II [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R9">9</a> ]和达芬奇研究套件（dVRK）[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R10">10</a> ]以及KUKA轻量重型机器人（LWR）[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R11">11</a> ]已经使用ROS作为软件平台。</p>
<p>但是，ROS平台不是执行某些临床任务的理想环境。具体而言，现代手术计划和指导严重依赖于医学图像来识别和定位患病区域和关键结构。此外，必须将这种导航信息映射到物理空间，以实现安全和准确的处理。虽然ROS的多功能性允许研究人员自己实现这些功能，但其中许多已经在一些专门为医学图像计算和图像引导治疗开发的研究平台上可用，例如3D Slicer [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R12">12</a> ]，IGSTK [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R13">13</a> ]， MITK [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R14">14</a> ]或NifTK [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R15">15</a> ]，OsiriX [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R16">16</a> ]，XIP-Builder <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R17"> [17]</a>]和MeVisLab [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R18">18</a> ]。因此，将ROS等机器人研究平台与医学图像计算平台连接起来对于先进医疗机器人系统的开发正变得越来越重要。通过将两个研究领域广泛开发的流行平台结合在一起，研究人员可以利用这两个领域丰富的工程资源。</p>
<p>将ROS等流行平台与医学图像计算平台连接起来，将进一步有益于医学机器人研究。由于ROS支持的机器人硬件种类繁多，从爱好导向产品到工业级高灵敏度机器人，人们可以轻松切换硬件，或者将系统从概念验证原型扩展到完全 - 用于动物和人类研究的功能系统，无需显着改变软件架构。因此，该桥将使原型设计和测试的迭代变得更加容易和快速。</p>
<p>这项研究的目标是开发一个新的软件界面，连接ROS和流行的医学图像计算软件3D Slicer，并提供支持图像引导和机器人辅助手术系统开发的研究和工程工具。这两个软件平台使用开放式网络通信协议OpenIGTLink [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R19">19</a> ] 通过TCP / IP网络无缝共享数据和命令。</p>
<p>在本文中，我们描述了系统架构及其实现，以及概念验证场景。ROS中实现的桥接结构以及ROS和OpenIGTLink消息之间的转换在“方法”部分中进行了解释。随后，网络通信性能测试的结果显示在实验部分，然后是用例部分，其中提供了网桥功能的展望。实验结果和用例在讨论部分讨论。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/" title="转到此页面的其他部分">去：</a></p>
<h2 id="2方法">2方法</h2>
<h3 id="21-ros-igtl-bridge节点">2.1 ROS-IGTL-Bridge节点</h3>
<p>我们软件界面的核心组件是名为ROS-IGTL-Bridge的ROS节点。ROS-IGTL-Bridge作为基于ROS的系统中的节点之一，与3D Slicer或配备有套接字接口的其他外部医学图像计算软件建立TCP / IP套接字连接。它可以配置为作为TCP / IP服务器或客户端运行。ROS提供了由多个节点组成的图形架构，这些节点通过对等网络连接并将数据一起处理。节点可以将ROS消息发布到给定_主题_，以及其他节点可以通过订阅主题来接收消息。ROS-IGTL-Bridge节点将ROS消息转换为OpenIGTLink消息，并通过TCP / IP连接将其发送到外部软件。它还接收OpenIGTLink消息，将其转换为ROS消息，并将其发布到ROS网络中（<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F1/">图1</a>）。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=5543207_nihms883782f1.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/bin/nihms883782f1.jpg" alt="包含图片，插图等的外部文件。对象名称为nihms883782f1.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F1/">图。1</a></p>
<p>ROS-IGTL-Bridge作为支持图像导入，图像处理，手术计划和手术导航的医学图像计算软件（左）之间的消息接口，以及提供运动学计算，传感，模拟，运动规划和计算机的ROS环境。愿景（右）。</p>
<p>该界面支持在图像引导和机器人辅助治疗的背景下常用的数据类型。支持的数据类型将在下一节中列出。</p>
<p>ROS-IGTL-Bridge节点进程由两个独立的POSIX线程组成，允许同时发送和接收数据（<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F2/">图2</a>）。每个消息类型实现了用于OpenIGTLink通信的消息序列化和反序列化的方法作为回调函数，并由两个线程调用。通过OpenIGTLink连接接收的传入消息由消息的头信息评估，并发布到ROS网络中相应的ROS-Topic。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=5543207_nihms883782f2.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/bin/nihms883782f2.jpg" alt="包含图片，插图等的外部文件。对象名称为nihms883782f2.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F2/">图2</a></p>
<p>桥接数据处理由两个独立的POSIX线程组成。线程“接收”（左）通过评估头信息并执行消息转换来处理传入的Open-IGTLink消息，随后将数据发布到相应的ROS主题。同时，线程“发送”在订阅的ROS主题上的先前触发的回调之后发送传出消息（右）。</p>
<p>ROS网络中创建的主题标记为OUT表示传出数据，IN表示传入数据。通过使用启动文件并设置参数服务器IP，端口和客户端/服务器标志，可以轻松配置ROS-IGTL-Bridge节点。此外，自主测试节点ROS-IGTL-Test可用于通过发送虚拟数据并在订阅的ROS主题上可视化接收的数据来评估功能。在测试例程期间，发送随机变换，点，包含20个点的点云，字符串和样本vtkPolyData模型。</p>
<h3 id="22-ros-igtl-bridge支持的消息类型">2.2 ROS-IGTL-Bridge支持的消息类型</h3>
<p>ROS-IGTL-Bridge支持IGT应用中经常使用的各种类型的数据。支持的类型包括字符串，变换，图像，多边形数据和点。以下段落详细介绍了支持的OpenIGT-Link消息以及ROS中的相应主题。为了确定从OpenIGTLink消息到相应ROS消息的转换方法，ROS-IGTL-Bridge使用OpenIGTLink消息的标题部分，该消息提供元数据，包括类型名称，设备名称，时间戳，正文大小和包状态（<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F3/">图3</a>）。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=5543207_nihms883782f3.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/bin/nihms883782f3.jpg" alt="包含图片，插图等的外部文件。对象名称为nihms883782f3.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F3/">图3</a></p>
<p>OpenIGTLink消息的基本结构由通用头信息组成，包括数据类型，名称，时间戳，大小和包状态以及特定于数据类型的主体部分。</p>
<h4 id="221字符串">2.2.1字符串</h4>
<p>设备和外部图像计算软件之间的字符串消息交换允许发送和接收命令或状态更新。因此，外部软件的图形用户界面可以扩展为显示诸如关于接收数据的确认之类的信息，或者提供用于控制所用设备的指令（<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F4/">图4</a>）。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=5543207_nihms883782f4.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/bin/nihms883782f4.jpg" alt="包含图片，插图等的外部文件。对象名称为nihms883782f4.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F4/">图4</a></p>
<p>OpenIGTLink和ROS-IGTL-Bridge的字符串消息中的相应数据字段。</p>
<h4 id="222变换">2.2.2变换</h4>
<p>变换消息可以包含表示设备，兴趣对象等的位置和方向的线性变换，由连接到ROS的传感器测量，或者在外部图像计算软件上生成。消息可用于监视工具，设备和对象的位置和方向，或向设备提供规划数据。OpenIGTLink igtlTransformMessage由4 <em>×</em> 4矩阵表示，并转换为ROS消息类型几何msgs / Transform，包含用于平移的向量和用于方向的四元数（<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F5/">图5</a>）。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=5543207_nihms883782f5.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/bin/nihms883782f5.jpg" alt="包含图片，插图等的外部文件。对象名称为nihms883782f5.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F5/">图5</a></p>
<p>Open-IGTLink和ROS-IGTL-Bridge的转换消息中的相应数据字段。ROS标准数据类型_几何msgs / Transform_包含作为3元素向量的转换和作为四元数的旋转。</p>
<h4 id="223图像">2.2.3图像</h4>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F6/">图6</a>显示了相应图像消息的属性。图像由3D空间中每个维度的大小和间距参数组成。数据存储在具有图像尺寸大小的8位数组中。可以使用IGTL VIDEO OUT主题从ROS发送2D视频流，该主题支持常见的ROS消息类型传感器msgs / Image。因此，摄像机数据可以直接转发到网桥，不需要额外的消息转换。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=5543207_nihms883782f6.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/bin/nihms883782f6.jpg" alt="包含图片，插图等的外部文件。对象名称为nihms883782f6.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F6/">图6</a></p>
<p>OpenIGTLink和ROS-IGTL-Bridge图像消息中的相应数据字段。消息包含卷的元信息，包括大小和间距以及像素数据。</p>
<h4 id="224多边形数据">2.2.4多边形数据</h4>
<p>多边形数据消息允许传输由点和附加表面信息组成的3D模型。多边形，三角形条带，线条或顶点表示网格的结构。由于缺少ROS中的vtkPolyData消息的显式等价物，因此提供了将vtkPolyData转换为ros igtl bridge :: igtlpolydata消息的方法。</p>
<h4 id="225点">2.2.5点</h4>
<p>点消息包括3D点数据，允许发送和获取目标点作为机器人的移动目的地，操纵器的位置或地标坐标用于登记目的或者还有点云和点列表形式的传感器数据（<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F8/">图8</a>）。此外，网桥能够以IGTL POINTCLOUD OUT主题上发布的几何msgs / Point形式发送点云。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=5543207_nihms883782f8.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/bin/nihms883782f8.jpg" alt="包含图片，插图等的外部文件。对象名称为nihms883782f8.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F8/">图8</a></p>
<p>OpenIGTLink和ROS-IGTL-Bridge的点消息中的相应数据字段。_geometry msgs / Point_包含_点_的x，y和z坐标。</p>
<h3 id="23系统配置和消息方案">2.3系统配置和消息方案</h3>
<p>使用不同的消息类型取决于系统配置和操作IGT设置所需的消息方案。<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F10/">图10</a>显示了两个代表性的系统配置，作为使用ROS-IGTL-Bridge的示例应用程序。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=5543207_nihms883782f10.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/bin/nihms883782f10.jpg" alt="包含图片，插图等的外部文件。对象名称为nihms883782f10.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F10/">图10</a></p>
<p>显示ROS-IGTL-Bridge功能的示例设置。（a）机器人和跟踪系统连接到ROS，并由3D Slicer通过ROS-IGTL-Bridge控制。使用OpenIGTLink接口将成像设备直接连接到3D Slicer。（b）机器人和成像设备（超声波）连接到由ROS操作的机器人，并由3D切片机通过ROS-IGTL桥控制。</p>
<p>第一个示例IGT设置包括机器人和跟踪系统，这两个系统都由ROS使用已经存在的ROS节点来操作。跟踪系统用于跟踪机器人的末端执行器。外部成像装置，例如光学相干断层扫描（OCT），超声或MRI，连接到医学图像计算平台，如3D切片器，其提供用于处理和可视化这种医学数据的方法（<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F10/">图10a）。</a>）。通过桥接ROS消息环境和医学图像计算平台，功能集可以有效地相互补充。使用桥的字符串消息转换来交换命令和状态更新，因此可以使用外科手术规划工具的用户界面来操作系统。转换消息允许获得连续刷新的跟踪数据或在六个自由度中命令某个位置。机器人模型数据可以作为多边形数据模型传输，以在3D切片机中可视化。可以将跟踪设备的原始点云或图像数据转发到图像处理平台，以便定位机器人位置或执行路径规划。</p>
<p>第二示例表示机器人引导的成像装置，其可能是附接到机器人末端执行器的超声探头（<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F10/">图10b）</a>）。机器人和成像设备由可下载的标准ROS节点控制，允许在所需设置中进行简单集成。为了在生成的ROS消息环境中访问或发布数据，使用ROS-IGTL-Bridge节点建立与诸如3D Slicer之类的外部手术计划平台的通信。因此，机器人控制以及图像设备命令和响应可以通过网桥作为字符串消息传输。另外，可以将作为点或转换消息的定位命令发送到ROS环境。获取的图像数据被转发到控制机器人的计划软件作为图像或点云消息，因此，图像处理和可视化方法可用于比较术中与术前数据。<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F9/">图9</a> 示出了ROS环境和手术计划平台之间可能的通信协议，同时在被命令到特定点位置之后执行图像采集。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=5543207_nihms883782f9.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/bin/nihms883782f9.jpg" alt="包含图片，插图等的外部文件。对象名称为nihms883782f9.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F9/">图9</a></p>
<p>使用ROS IGTL桥作为网络接口的手术计划软件和ROS操作机器人之间可能的通信协议。初始化机器人，命令移动到一个点并获取具有附加变换信息的图像数据。最后，机器人关闭了。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/" title="转到此页面的其他部分">去：</a></p>
<h2 id="3实验">3实验</h2>
<p>我们使用模拟图像引导的手术机器人系统评估了ROS和3D切片机之间的网络通信性能。此外，我们在两个有代表性的用例场景中展示了该软件的可行性：基于Lego Mindstorms的教育/快速原型图像引导手术导航系统和自主缝合机器人。</p>
<h3 id="31实验设置">3.1实验设置</h3>
<p>模拟图像引导的手术机器人系统由两台计算机组成：基于Linux的计算机（Precision M3800，四核Intel Core i7-4712HQ 2.3 GHz，16 GB 1600MHz DDR3内存，Ubuntu Linux 14.04LTS，Dell Inc.，Round Rock ，TX）模仿机器人控制器和基于Mac的工作站（Mac Pro，双6核Intel Xeon 2.66 GHz和40 GB 1333 MHz DDR3内存，Mac OS X 10.10，Apple Inc.，Cupertino，CA）模仿用于手术计划和导航界面的工作站。这两台计算机通过Cat 5e电缆连接到8端口千兆以太网交换机（SG100D-08，Cisco Systems Inc.，San Jose，CA）。ROS Indigo安装在基于Linux的计算机上，带有ROS-IGTL-Bridge节点。在Mac工作站上，安装了3D Slicer 4.6，用于可视化从ROS传输的数据。</p>
<p>为了评估延迟，发送方根据发送方的内部时钟将数据生成时间嵌入到消息头中。一旦接收器接收到消息，接收器就会提取数据生成的时间，并将其与接收器的内部时钟进行比较，以计算两个模拟器之间数据传输所花费的时间。为了准确确定延迟，使用PTPd [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R20">20</a> ] 同步两台计算机的内部时钟。PTPd使用IEEE 1588-2008标准中定义的精确时间协议（PTP）通过网络将内部时钟与主时钟同步。与广泛使用的网络时间协议（NTP）不同[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R21">21</a>]，PTP旨在实现连接到局域网（LAN）的计算机之间更精确的时钟同步。</p>
<h3 id="32数据传输性能评估">3.2数据传输性能评估</h3>
<p>使用此设置，我们评估了变换，字符串，点和图像的数据传输性能。这些数据类型通常用于实时数据共享，例如工具跟踪，视频流和状态监控，因此确保以适当的帧速率和延迟进行数据传输至关重要。</p>
<p>我们分别在Linux计算机和Mac工作站上部署了两个自定义软件模拟器，即_ROS测试节点_和_IGTL测试服务器_。ROS测试节点是ROS节点，通过ROS网络与ROS-IGTL-Bridge通信，而IGT测试服务器是TCP / IP服务器，使用OpenIGTLink协议通过LAN与ROS-IGTL-Bridge通信。IGTL测试服务器模拟3D切片机或任何其他手术计划和导航软件的行为。两个模拟器都可以作为_发送者_或_接收者_; 当发送者角色分配给一个模拟器时，接收者角色被分配给另一个。发送方生成具有给定类型和消息大小的随机消息，并通过ROS-IGTL-Bridge节点将其发送到接收方。进行了两组测试：</p>
<ul>
<li>
<p>数据传输延迟的定性评估。我们测量了数据传输延迟，同时以每秒30帧（fps）的速度将消息从发送器流式传输到接收器。每个变换消息包含一个表示位置和方向的线性变换。每个字符串消息的大小固定为100个字节，这对于设备的命令就足够了。对于点消息，使用多个数据大小，从每个消息1个点到每个消息10000个点，考虑不同的用例场景，包括工具跟踪，地标跟踪和点云传输。对于图像信息，我们考虑五种图像格式的二维彩色图像（RGB）：VGA（640 <em>×</em> 480像素），SVGA（800 <em>×</em> 600像素），XGA（1024 <em>×</em> 768像素），HD（1280）<em>×</em> 720像素）和全高清（1920 <em>×</em> 1080像素）。</p>
</li>
<li>
<p>高帧率数据传输的演示。此外，我们使用变换数据类型测试高帧速率数据传输，高速率为1000 fps，考虑到感应数据（例如跟踪传感器，编码器）通过局域网在两台计算机之间传输的应用。</p>
</li>
</ul>
<p>在两个测试中，数据都从ROS测试节点传输到IGTL测试服务器，反之亦然。</p>
<h3 id="33多边形数据共享的演示">3.3多边形数据共享的演示</h3>
<p>此外，使用设置演示了多边形数据的传输。对于这种定性评估，称为ROS-IGTL-Test节点的模拟器程序用作ROS节点，而3D Slicer用作外部软件，其基于MRI数据生成3D多边形数据模型。ROS-IGTL-Test节点附带ROS-IGTL-Bridge软件，用于测试人体头部的3D模型。在文件_test.launch中_设置连接参数后，ROS-IGTL-Bridge和3D Slicer中的集成Open-IGTLinkIF模块建立连接，然后交换poly数据消息。</p>
<h3 id="34结果">3.4结果</h3>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/table/T1/">表1</a>中显示了1000帧的平均和标准差延迟。有些情况下，由于数据传输延迟大于消息传输的间隔，因此未传递某些消息。在测量期间，两台计算机之间的时钟偏移保持在0.00 <em>±</em> 0.28毫秒（平均值_±_SD）。</p>
<h3 id="表格1">表格1</h3>
<p>基于1000个消息传输中的测量的变换，点，字符串和图像消息的消息传送等待时间的均值和标准偏差（SD）。</p>
<table>
<thead>
<tr>
<th style="text-align:left">消息类型</th>
<th style="text-align:center">从ROS测试节点到IGTL测试服务器（毫秒）</th>
<th style="text-align:center">从IGTL测试服务器到ROS测试节点（毫秒）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">转变</td>
<td style="text-align:center">1.1 <em>±</em> 0.5</td>
<td style="text-align:center">1.1 <em>±</em> 0.4</td>
</tr>
<tr>
<td style="text-align:left">字符串（100字节）</td>
<td style="text-align:center">1.1 <em>±</em> 0.5</td>
<td style="text-align:center">1.2 <em>±</em> 0.4</td>
</tr>
<tr>
<td style="text-align:left">点（1分）</td>
<td style="text-align:center">1.2 <em>±</em> 0.5</td>
<td style="text-align:center">1.2 <em>±</em> 0.4</td>
</tr>
<tr>
<td style="text-align:left">点（10分）</td>
<td style="text-align:center">1.2 <em>±</em> 0.5</td>
<td style="text-align:center">1.4 <em>±</em> 0.5</td>
</tr>
<tr>
<td style="text-align:left">点（100分）</td>
<td style="text-align:center">17.2 <em>±</em> 12.6</td>
<td style="text-align:center">3.8 <em>±</em> 5.4</td>
</tr>
<tr>
<td style="text-align:left">点（1000分）</td>
<td style="text-align:center">24.8 <em>±</em> 12.3</td>
<td style="text-align:center">20.9 <em>±</em> 26.7</td>
</tr>
<tr>
<td style="text-align:left">图像（VGA）</td>
<td style="text-align:center">25.2 <em>±</em> 4.3</td>
<td style="text-align:center">23.6 <em>±</em> 3.5</td>
</tr>
<tr>
<td style="text-align:left">图像（SVGA）</td>
<td style="text-align:center">33.6 <em>±</em> 4.6 *</td>
<td style="text-align:center">33.6 <em>±</em> 3.7 *</td>
</tr>
<tr>
<td style="text-align:left">图像（XGA）</td>
<td style="text-align:center">58.8 <em>±</em> 10.6 *</td>
<td style="text-align:center">58.5 <em>±</em> 6.0 *</td>
</tr>
<tr>
<td style="text-align:left">图像（HD）</td>
<td style="text-align:center">76.3 <em>±</em> 10.5 *</td>
<td style="text-align:center">67.2 <em>±</em> 6.1 *</td>
</tr>
<tr>
<td style="text-align:left">图像（全高清）</td>
<td style="text-align:center">NA *</td>
<td style="text-align:center">144.5 <em>±</em> 12.2 *</td>
</tr>
</tbody>
</table>
<p>星号（*）表示某些消息未传递给收件人。</p>
<p>为了演示高帧率数据传输，转换消息成功地以1000 fps从ROS测试节点传输到IGTL测试服务器。当消息以另一个方向传输时，数据传输成功达到900 fps。</p>
<p>在多数据传输的附加演示中，由超过60万个点和23万个面组成的多边形数据模型成功地从ROS转移到3D切片器，反之亦然。转移的多边形数据在两种环境中都成功可视化（<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F11/">图11</a>）。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=5543207_nihms883782f11.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/bin/nihms883782f11.jpg" alt="包含图片，插图等的外部文件。对象名称为nihms883782f11.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F11/">图11</a></p>
<p>交换的vtkPolyData模型从样本数据生成，该样本数据在ROS侧（左侧）的vtkRenderWindow中可视化，并在3D Slicer场景（右侧）中进行比较。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/" title="转到此页面的其他部分">去：</a></p>
<h2 id="4个用例">4个用例</h2>
<h3 id="41-igt快速原型教育平台">4.1 IGT快速原型/教育平台</h3>
<p>使用3D Slicer，ROS和Lego Mindstorms EV3对概念验证图像引导机械手系统进行了原型设计。Lego Mindstorms已被用于教育背景下的IGT相关项目[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R22">22</a> ]以及硬件/软件测试平台[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R23">23</a> ]。该项目的目标有两个：（1）利用可扩展的软件系统为医疗机器人创建头脑风暴工具，促进从原型到研究和商业级系统的无缝转换; （2）为学生，工程师和科学家创建一个教育工具，以学习图像引导和医疗机器人。</p>
<p>该系统模仿手术机器人，其致动其末端执行器以跟随在手术导航软件上的3D医学图像（例如，CT，MRI）上定义的物理空间中的轨迹。可以通过3D图形监控该过程。该系统由一个主动的三自由度（DoF）并行链接机械手，控制砖，ROS主计算机和运行ROS主服务器和导航软件3D Slicer的导航计算机组成。控制计算机模块（Lego EV3可编程砖块）通过无线网络上的ROS主服务器与导航软件通信。我们使用大脑的MR图像和从图像创建的2D体模执行模拟程序。通过用其末端执行器物理地触摸它们来记录预定义地标的坐标，将操纵器登记到模型中，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F12/">图12</a>）。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=5543207_nihms883782f12.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/bin/nihms883782f12.jpg" alt="包含图片，插图等的外部文件。对象名称为nihms883782f12.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F12/">图12</a></p>
<p>使用3D切片器中的点配准算法在2D样本数据上匹配定义的和物理的界标。</p>
<p>然后，使用先前定义的从3D切片机传送到控制砖的轨迹点，执行2D体模上的绘制过程（<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F13/">图13a</a>）（<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F13/">图13b</a>）。这个模拟程序表明，这个基于乐高的系统可用于构建具有研究或商业级架构的机器人系统，并模拟真实的临床工作流程，使其成为快速原型设计和教育的理想工具。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=5543207_nihms883782f13.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/bin/nihms883782f13.jpg" alt="包含图片，插图等的外部文件。对象名称为nihms883782f13.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F13/">图13</a></p>
<p>使用Lego Mindstorms构建的机器人手臂遵循2D体模（a）上的轨迹，该轨迹先前在3D切片器（b）中成功进行了图像到患者注册后的计划。</p>
<h3 id="42使用kuka-lwr进行自主缝合">4.2使用KUKA LWR进行自主缝合</h3>
<p>目的是测试ROS-IGTL-Bridge在规划和引导自主手术机器人方面的可行性。使用开发的ROS-IGTL-Bridge，我们开始改进智能组织自主机器人（STAR）的软件系统，该机器人使用KUKA LWR机器人。STAR包括基于商用腹腔镜Endo360°（EndoEvolution，Raynham）工具的机器人缝合工具，使用ROS实现图形用户界面（GUI）和相机集成的自定义控制，以及实时开放式机器人控制软件（OROCOS）控制[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R11">11</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R24">24</a> ]。虽然我们使用STAR证明了卓越的一致性和爆破压力，但是42.2％的缝线需要手动操作员调整，与手动和远程操作机器人手术相比，手术时间更长[<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R7">7</a> ]。需要操作员调整的大多数错过的缝线放置是由全光相机的噪声点云数据引起的，特别是沿着深度轴，这在ROS提供的二维缝线计划中是不明显的。通过使用ROS-IGTL-Bridge升级STAR，我们能够将3D点云从STAR转移到Slicer进行点云可视化（<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F14/">图14</a>）。这可以改善缝合位置的3D规划工作流程，更大的自主性和更短的手术时间。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=5543207_nihms883782f14.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/bin/nihms883782f14.jpg" alt="包含图片，插图等的外部文件。对象名称为nihms883782f14.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F14/">图14</a></p>
<p>图为猪肠道吻合术（左），当前STAR缝合计划（中），以及使用3D切片机实现3D调整的缝合计划（右图）。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/" title="转到此页面的其他部分">去：</a></p>
<h2 id="5讨论">5讨论</h2>
<p>在这项工作中，ROS-IGTL-Bridge节点被实现为通过基于OpenIGTLink协议的通用开放网络接口来扩展ROS。该接口支持在基于ROS的系统和外部医学图像计算平台之间无缝共享IGT应用中经常使用的数据，包括字符串，变换，点，多边形数据和图像。生成匹配消息类型的转换方法以确保兼容性。虽然OpenIGTLink协议为传输线性变换提供了两种不同的消息类型，即TRANSFORM和TDATA，但由于其简单性和通用性，我们选择在当前实现中使用TRANSFORM。TRANSFORM消息表示仿射变换矩阵，可以很容易地将其转换为ROS _几何msgs / Transform_消息，可用于多种用途，从工具跟踪到坐标转换。未来可以支持TDATA，因为它为工具跟踪提供了便利的功能，例如多通道跟踪的传输。可以轻松调整创建的消息和转换，或者可以另外包含新的消息类型以满足特定于任务的需求。</p>
<p>使用ROS-IGTL-Bridge进行数据传输的性能足以满足许多实时IGT应用的需求。我们的测试表明，对于字符串，点和转换消息，每秒30帧的传入和传出消息的数据传输延迟小于1.2毫秒，对于图像（VGA），小于25毫秒。另外，对于变换消息，实现了高达900fps的高帧速率数据传输。此外，成功交换了超过60万点和23万面的大型多边形数据模型。传输大于XGA格式的图像无法达到完整的30 fps。我们目前正致力于扩展OpenIGTLink协议，以提供视频压缩，以获得更好的流媒体性能。</p>
<p>使用3D Slicer和Lego Mind-storm的模拟IGT系统证明了ROS-IGTL-Bridge允许构建原型系统并在有限时间内在模拟IGT程序中验证其功能。我们能够在2016年第22届NA-MIC冬季项目周期间建立这个演示设置，这是为期一周的黑客马拉松活动，重点关注开源医学图像计算软件基础设施[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R25">25</a> ]。ROS-IGTL-Bridge也在高档IGT设置中得到了验证，该设置由具有自主控制系统的工业级高灵巧度机器人组成。ROS-IGTL-Bridge能够传输点云数据，并将3D Slicer提供的缝合定位的高级可视化和3D规划纳入系统。</p>
<p>该研究表明，ROS-IGTL-Bridge支持ROS和图像引导软件之间的跨平台数据共享，具有足够的数据传输性能。通过将ROS中的机器人控制，运动规划和感知等特定方法与3D切片机等手术规划工具的图像处理和可视化功能组合，该桥接器有益于IGT设置。这将允许快速无缝地将图像引导软件（如3D Slicer）提供的基于图像的高级计划/导航集成到基于ROS的手术机器人系统中。通过桥接两个不同的软件平台，研究人员可以从不同研究领域开发的最先进的工程资源中受益，包括机器人和医学图像计算，以开发先进的图像引导手术机器人系统。</p>
<p>一些研究已经证明了使用OpenIGTLink桥接两个研究平台的想法。特别是，OpenIGTLink已被广泛用于桥接数据抓取软件和可视化/用户交互软件，用于医学图像计算研究。Papademetris，Tokuda _等人_使用OpenIGTLink将商业导航系统与外部研究平台（包括3D Slicer [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R19">19</a> ]和BioImage Suite [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R26">26</a> ]）联系起来。图像引导外科工具包（IGSTK）[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R27">27</a> ]，一个开放的软件平台提供与跟踪和成像设备的连接，支承OpenIGTLink跟踪和成像数据输出到其它平台，比如3D切片机和MITK [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R28">28</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R29">29</a>]。最近，Lasso _等人_使用OpenIGTLink将其数据抓取软件PLUS与外部可视化软件桥接，以流式跟踪和超声图像数据[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R30">30</a> ]。Clarkson _等人_开发了一个基于OpenIGTLink的消息库NiftyLink，用于集成数据抓取软件和用于可视化/用户交互的最终用户应用程序[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R15">15</a> ]。其他开源软件包，例如CustusX [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R31">31</a> ]，IBIS [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R32">32</a> ]和MeVisLab [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R18">18</a> ]，也适用于OpenIGTLink，以利用社区中现有的现有软件基础架构。</p>
<p>OpenIGTLink还被用于桥接医学图像计算领域之外的平台。医疗机器人平台CISST库提供了一个OpenIGTLink桥，可将图像可视化软件集成到医疗机器人应用中[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R33">33</a> ]。OpenIGTLink还与基于ROS的机器人系统一起用于腹腔镜介入治疗[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R34">34</a> ]。ROS-IGTL-Bridge是对那些旨在扩展医学图像计算领域中的成功模型的先前工作的概括，并且具有促进医学机器人和医学图像计算之间的工程资源共享的潜力。</p>
<p>ROS-IGTL-Bridge的源代码，指令和测试程序在GitHub [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/#R35">35</a> ]中作为开源软件提供。可以使用基于CMake的构建系统Catkin编译和安装代码。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=5543207_nihms883782f7.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/bin/nihms883782f7.jpg" alt="包含图片，插图等的外部文件。对象名称为nihms883782f7.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/figure/F7/">图7</a></p>
<p>OpenIGT-Link和ROS-IGTL-Bridge的poly数据消息中的相应数据字段。考虑的属性包括_名称，点，多边形，条带，线_和_顶点_。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5543207/" title="转到此页面的其他部分">去：</a></p>
<h2 id="致谢">致谢</h2>
<p>该研究部分得到了美国国立卫生研究院（R01EB020667，R01CA111288，R01EB020610，P41EB015898）的支持。材料的内容完全由作者负责，并不一定代表这些机构的官方观点。作者感谢布莱根妇女医院的陈龙泉先生的技术支持。作者还感谢Christina Choi女士用Lego Mindstorms评估快速原型制作平台。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[青岛参加全国第三次数字医学会议山东省第四次数字医学会]]></title>
        <id>https://blog.bioprinting.site/post/euxBg5taN</id>
        <link href="https://blog.bioprinting.site/post/euxBg5taN">
        </link>
        <updated>2019-05-11T23:40:29.000Z</updated>
        <content type="html"><![CDATA[<p>青岛参加全国第三次数字医学会议山东省第四次数字医学会
<img src="https://blog.bioprinting.site/post-images/1557618060095.jpg" alt="">
<img src="https://blog.bioprinting.site/post-images/1557618066949.jpg" alt="">
<img src="https://blog.bioprinting.site/post-images/1557618070147.jpg" alt="">
<img src="https://blog.bioprinting.site/post-images/1557618073115.jpg" alt="">
<img src="https://blog.bioprinting.site/post-images/1557618075946.jpg" alt="">
<img src="https://blog.bioprinting.site/post-images/1557618078264.jpg" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UR机械臂运动学正逆解方法]]></title>
        <id>https://blog.bioprinting.site/post/IaZRC0R5i</id>
        <link href="https://blog.bioprinting.site/post/IaZRC0R5i">
        </link>
        <updated>2019-05-10T12:43:56.000Z</updated>
        <content type="html"><![CDATA[<p>最近几个月因为工作接触到了机械臂的项目，突然对机械臂运动方法产生了兴趣，也就是如何控制机械臂的位置和姿态。借用一张网上的图片，应该是ur5的尺寸。我用到的是ur3机械臂，除了尺寸不一样，各关节结构和初始位置和ur5是一样的。</p>
<p><img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527072933030-620074166.png" alt=""></p>
<p>ur机械臂是六自由度机械臂，由D-H参数法确定它的运动学模型，连杆坐标系的建立如上图所示。我当时在这个地方的理解上走了不少弯路，后来找个一个视频，我觉得讲解地比较容易理解，可以参考一下<a href="http://v.youku.com/v_show/id_XMzIwNDg4MDA0.html">Denavit-Hartenberg参数视频详解</a>。ur机械臂DH参数表如下，</p>
<p><img src="https://blog.bioprinting.site/post-images/1557492344029.jpg" alt=""></p>
<p>由此可以建立坐标系i在坐标系i-1的齐次变换矩阵，注意每次不管平移还是旋转是相对于当前的运动坐标系变换，矩阵右乘</p>
<p><img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527074816023-1520605604.png" alt=""><img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527074843571-1120839507.png" alt=""></p>
<p>那么把DH参数代入就可以得到所有相邻坐标系的变换矩阵</p>
<p><img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527144154446-776504147.png" alt=""><img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527144201988-926698801.png" alt=""><img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527144208183-1283913775.png" alt=""></p>
<p><img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527144216324-2007686439.png" alt=""><img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527144222807-1848807733.png" alt=""><img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527144229274-1250526175.png" alt=""></p>
<p>所以末端坐标系6到基座固定坐标系0的变换矩阵<img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527074918840-716859445.png" alt="">。那么求正解就很简单了，只要输入六个关节角度θ<sub>i</sub>，就得到末端坐标在基坐标系的变换矩阵T。ur机械臂的视教板上末端点的坐标是用六个值[x, y, z, rx, ry, rz]表示的。前三个值[x, y, z]是三维笛卡尔坐标，表示空间位置，后三个值[rx, ry, rz]是坐标旋转向量，表示空间姿态。我们得到的变换矩阵T怎么变成六值坐标[x, y, z, rx, ry, rz]呢？设</p>
<p><img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527101025758-731072248.png" alt=""></p>
<p>T的左上角的3x3矩阵是旋转矩阵，旋转矩阵和旋转向量之间可以通过罗德里格斯（Rodrigues）变换进行转换。opencv里有相应的函数调用。算法也比较简单，不用opencv的函数自己写代码也不难。T的右上角3x1就是空间位置[x, y, z]。这样有变换矩阵T得到六值坐标，完成了正解。</p>
<p>逆解相对要复杂一些，由末端的空间位置和姿态，计算可能的关节角度。逆解的方法有解析法，迭代法和几何法。其中解析法用数学推导，可以得到全部根，但是计算复杂。有的机械臂可以得到无穷解，比如7轴机械臂。而ur的6轴机械臂是有有限解的。这里推导一下ur的逆解。</p>
<p>首先计算求变换矩阵T过程其中的一些中间矩阵。</p>
<p><img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527075100349-1228823736.png" alt="">，其中c<sub>23</sub>=cos(θ<sub>2</sub>+θ<sub>3</sub>)，s<sub>23</sub>=sin(θ<sub>2</sub>+θ<sub>3</sub>)。</p>
<p><img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527075112036-542481994.png" alt=""></p>
<p><img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527075122415-1330412513.png" alt=""></p>
<p>由<img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527074918840-716859445.png" alt="">得到<img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527103709077-1951572752.png" alt="">。计算</p>
<p><img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527103734056-649296405.png" alt="">，<img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527103755560-1796142198.png" alt="">，得到</p>
<p><img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527103843392-60682071.png" alt=""></p>
<p>等式两边矩阵的行列应该分别相等，由第三行第四列得到<img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527104011790-1934345364.png" alt="">，可解得<img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527104135222-239033524.png" alt="">，有两个解。这里注意写程序的时候，求解这里的反正切是用atan2()这类的函数，返回之在(-π,+π]。而反余弦的返回值在[0,π]，从而保证在2π范围每个解是唯一的。</p>
<p>由第三行第三列得<img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527104310579-69361694.png" alt="">，可解得<img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527104407262-1490785602.png" alt="">，两个解。由第三行第二列得到<img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527104524002-339481378.png" alt="">，可解得<img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527104537576-1226429631.png" alt="">。</p>
<p>接着由</p>
<p><img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527105730267-1783435906.png" alt="">，</p>
<p>计算</p>
<p><img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527104721998-1489358485.png" alt="">，得出等式左边等于</p>
<p><img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527110916911-1640633834.png" alt="">。</p>
<p>由<img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527105035307-1992381215.png" alt="">，两边平方，令<img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527105109353-2076276978.png" alt="">，<img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527105136636-532380401.png" alt="">。</p>
<p>同样由<img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527105159632-1867985633.png" alt="">，令<img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527105212250-1939136089.png" alt="">，<img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527105228874-2044756350.png" alt="">。</p>
<p>两式相加得到<img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527105303715-763704756.png" alt="">，则<img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527105325825-263636398.png" alt="">，有两个解。</p>
<p>把θ<sub>3</sub>带入<img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527105430393-47325808.png" alt="">和<img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527105440038-1776404602.png" alt="">，得<img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527105510239-957405523.png" alt="">，<img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527105522558-2130327615.png" alt="">，其中t<sub>2</sub>=tanθ<sub>2</sub>。两式消去c<sub>2</sub>，得到<img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527105608722-1428977705.png" alt="">。</p>
<p>最后得到<img src="https://images2018.cnblogs.com/blog/1095344/201805/1095344-20180527110033957-1768711475.png" alt="">，从而得到θ<sub>4</sub>。</p>
<p>综合有两个解的情况，ur机械臂逆解总共由2x2x2=8组解。</p>
<p>按照上面的算法，用python写了两个程序，一个正解一个逆解验证一下。工作手边是ur3的机械臂，上面的图和表都是ur5的，换成ur3的参数。正解算出来都没有问题，可以和实际机械臂的空间位姿对应。可是逆解算出来8组值，好像只有四组值是对的。一直还没理解到底是怎么回事，仔细检查了算法和程序好像都没有错阿，不知道是哪里出了问题。网上也没有找到答案，如果哪位大神知道，望不吝赐教！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[内镜手术套筒的制作和内镜吸引器的制作]]></title>
        <id>https://blog.bioprinting.site/post/RlGmbU_Jn</id>
        <link href="https://blog.bioprinting.site/post/RlGmbU_Jn">
        </link>
        <updated>2019-04-30T13:38:26.000Z</updated>
        <content type="html"><![CDATA[<p>http://my.polyv.net/front/video/view?vid=f0d038bc9b1feb7593a02e6a079ab440_f</p>
<p>链接: https://pan.baidu.com/s/1bXYRlQ86KGa63Snx08MnxQ 提取码: 7xfe</p>
  <iframe 
    src="http://my.polyv.net/front/video/view?vid=f0d038bc9b1feb7593a02e6a079ab440_f"
    frameborder="0" 
    allowfullscreen>
</iframe>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我做的手术外侧裂的分离和血肿清除]]></title>
        <id>https://blog.bioprinting.site/post/XX8LudPX2</id>
        <link href="https://blog.bioprinting.site/post/XX8LudPX2">
        </link>
        <updated>2019-04-30T13:15:37.000Z</updated>
        <content type="html"><![CDATA[  <iframe 
    src="http://my.polyv.net/front/video/view?vid=f0d038bc9b2fa6f2267ae762fe10834a_f"
    frameborder="0" 
    allowfullscreen>
</iframe>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BigBridgeRobot——神外机械臂定位机器人仿真系统]]></title>
        <id>https://blog.bioprinting.site/post/wqKx9IwcR</id>
        <link href="https://blog.bioprinting.site/post/wqKx9IwcR">
        </link>
        <updated>2019-04-29T10:32:49.000Z</updated>
        <content type="html"><![CDATA[  <iframe 
    src="http://my.polyv.net/front/video/view?vid=f0d038bc9b69f13e90652559aa54f1a4_f"
    frameborder="0" 
    allowfullscreen>
</iframe>
]]></content>
    </entry>
</feed>