<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.bioprinting.site</id>
    <title>Li Zhenzhu, Ph.D</title>
    <updated>2020-03-15T12:58:33.492Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.bioprinting.site"/>
    <link rel="self" href="https://blog.bioprinting.site/atom.xml"/>
    <subtitle>Binzhou Medical University Hospital, Email: timeanddoctor@gmail.com.</subtitle>
    <logo>https://blog.bioprinting.site/images/avatar.png</logo>
    <icon>https://blog.bioprinting.site/favicon.ico</icon>
    <rights>All rights reserved 2020, Li Zhenzhu, Ph.D</rights>
    <entry>
        <title type="html"><![CDATA[测试]]></title>
        <id>https://blog.bioprinting.site/post/HFfQEX-Xa</id>
        <link href="https://blog.bioprinting.site/post/HFfQEX-Xa">
        </link>
        <updated>2020-03-15T12:57:26.000Z</updated>
        <content type="html"><![CDATA[<p>测试</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[儿童脑干肿瘤及手术入路]]></title>
        <id>https://blog.bioprinting.site/post/2IgPVMzQH</id>
        <link href="https://blog.bioprinting.site/post/2IgPVMzQH">
        </link>
        <updated>2019-10-05T11:42:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="目的">目的</h3>
<p>分析儿童期脑干肿瘤的通路以及安全进入区。</p>
<h3 id="方法">方法</h3>
<p>我们对第一位作者（Cavalheiro，S.）于1991年至2011年在圣保罗联邦大学神经外科和儿科肿瘤研究所进行的脑干肿瘤切除术的207例年龄小于18岁的患者进行了回顾性研究。</p>
<h3 id="结果">结果</h3>
<p>脑干肿瘤占同期所有手术儿科肿瘤的9.1％。使用了11个先前描述的“安全进入区”。我们描述了位于上腹桥的一个新的安全区，我们将其称为超上路法。术后头两个月的手术死亡率为1.9％（四名患者），发病率为21.2％。</p>
<h3 id="结论">结论</h3>
<p>内在和外在的脑干结构的解剖学知识，结合完善的神经外科技术，并借助术中监测，以及基于磁共振成像（MRI）和超声成像的外科手术计划，已广泛切除了脑干病变，具有低死亡率和可接受的发病率。</p>
<p>**关键词：**小儿脑干神经胶质瘤，脑干手术，安全进入区，白色纤维解剖学，三叉神经上入路，低度星形细胞瘤</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/" title="转到此页面的其他部分">去：</a></p>
<h2 id="介绍">介绍</h2>
<p>脑干是人体内最复杂的结构之一，包含最复杂的颅内解剖结构[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR55">55</a> ]。这种紧凑的中线器官在前部受到锁骨保护，在侧面受到颞骨的小部分的保护，在上方受到中脑的保护，而在后部则受到小脑的保护。所有运动，感觉，交感和副交感神经功能都已整合并通过脑干。脑干的结构复杂性使得在那里的外科手术极其困难，并且需要完善的技术。脑干肿瘤在儿童中更为常见，占儿童脑肿瘤的18％和颅后窝肿瘤的25％。没有性别偏爱。这些肿瘤的平均年龄发生在5至10岁左右<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR54"> [54]</a>]。在30至40岁之间的成年人中出现第二个发病高峰。近年来，一些文章已经在脑干解剖和出版了“安全进区。”其中的大多数都与海绵状血管瘤手术，很少在儿童[相关脑干肿瘤手术入路<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR9">9</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR19">19</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR22">22</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR26">26</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR53">53</a> ]。这项研究的目的是回顾本文所述的手术方法以及本文的第一作者（Cavalheiro，S.）基于207例年龄小于18岁的接受脑干肿瘤手术的患者所进行的手术方法。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/" title="转到此页面的其他部分">去：</a></p>
<h2 id="分类">分类</h2>
<p>纤维的各种排列，Virchow-Robin空间以及包括脑干的结构有时使肿瘤无症状地大量生长。这可以允许弥漫性桥脑肿瘤在桥内生长而不会渗入中脑或髓质。当中脑肿瘤生长时，它们向丘脑扩散，不会浸入脑桥。延髓的肿瘤倾向于生长到第四脑室而不会侵入脑桥，或者朝脊髓尾部生长。</p>
<p>已经提出了针对脑干肿瘤的许多分类。我们使用了Choux等人的建议：I型，弥漫性脑干神经胶质瘤；II型，局灶性内在肿瘤（实体或囊性）；III型，外生的；和IV型，颈髓[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR14">14</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR15">15</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR17">17</a> ]。</p>
<h3 id="弥漫性肿瘤i型">弥漫性肿瘤（I型）</h3>
<p>弥漫性肿瘤是最常见的，占脑干肿瘤的80％。它们同时影响多个核和通路，并典型地引起颅神经VI和VII的双侧麻痹，发展为偏瘫和四肢瘫痪。它们表现出快速的临床发展，就组织病理学而言，大多数是Ⅲ或Ⅳ级恶性星形细胞瘤（WHO）。在放射学上，它们的特征是桥脑被截留的桥脑增大。它们在T1磁共振成像（MRI），在T2高，高信号上FLAIR低信号，并表现出最小的对比度增强[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR6">6</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR44">44</a> ]。</p>
<p>这些患者的生存期很短，大多数在诊断后的前两年内死亡。但是，少数情况可能对化学疗法和放射疗法有反应。使用常规或多级放疗的预后没有差异。神经轴的转移可以在5至30％的病例[发生<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR10">10</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR18">18</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR25">25</a> ]。</p>
<p>在几个中心进行了弥漫性脑干肿瘤的立体定向活检。它的用途主要是重要的分子生物学研究[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR52">52</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR57">57</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR62">62</a> ]。但是，活检与某些并发症有关。Pincus等。（2006）[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR49">49</a>）对13例儿童弥漫性桥脑病变报告中的182例立体定向活检病例进行了回顾性研究。他们指出，有75至100％的病例证实了肿瘤的诊断。在87％的病例中，病变为神经胶质瘤，其余的13％为原始神经外胚层肿瘤，神经细胞瘤，室管膜瘤和脱髓鞘性病变。发病率从0％到16％不等，死亡率达到5％。因此，活检表明只有在与非特征图像的情况下或在分子生物学研究中心[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR32">32</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR59">59</a> ]。立体定向活检可以通过额叶区域的进入点或后颅窝进行。</p>
<h3 id="局灶性肿瘤ii型">局灶性肿瘤（II型）</h3>
<p>局灶性肿瘤的行为与弥漫性肿瘤不同。它们是生长缓慢的病灶，症状是惰性的。它们可能是实性或囊性的，与弥漫性肿瘤相反，局部病变边界清晰。较少的水肿与局灶性肿瘤有关，局灶性肿瘤主要是低度神经胶质瘤。它们通常在T1上表现低下，并伴有弥漫性肿瘤增强。focal的浸润在局灶性肿瘤中有所不同。然而，均一性增强强烈提示细胞性星形细胞瘤[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR29">29</a> ]。</p>
<p>如果肿瘤是浅表的，建议手术治疗；但是，如果肿瘤很深，则应保守治疗，以期肿瘤本身可以为切除术提供“开门”。对于这些肿瘤的外科手术方法，使用射线照相术可以提供更好的选择。四边形板中的肿瘤通常是局灶性的，大部分是毛细胞星形细胞瘤[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR33">33</a> ]。</p>
<h3 id="外生性肿瘤iii型">外生性肿瘤（III型）</h3>
<p>外生性肿瘤更容易通过手术获得。它们往往是大的肿瘤，脑干中有很大的成分，有利于手术。它们可能具有囊性成分，这是促进其切除的另一个因素。它们主要是低度星形细胞瘤[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR48">48</a> ]。</p>
<h3 id="颈髓交界性肿瘤iv型">颈髓交界性肿瘤（IV型）</h3>
<p>颈髓交界处肿瘤通常表现为外生性生长，使外科医生无需切开脑干即可直接进入。这些病变通常不渗入脑桥，并从颅脑逐渐生长到第四脑室。它们可能尾部延伸到脊髓中。当向第四脑室生长时，脑积水可能在早期发生。当朝向脊髓生长时，由于脑脊髓液动力学的变化，它们可能会产生脊髓空洞症。尽管地形有利于手术入路，但这些情况最常伴随严重的病情发展。术后，这些患者可能呼吸困难，导致长时间的辅助机械通气和吞咽困难，继而可能引起严重的吸入性肺炎。患者可能需要进行气管造口术和胃造口术，必须进行言语治疗。手术期间使用电生理监测有助于预防这些并发症[<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR16">16</a>]。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/" title="转到此页面的其他部分">去：</a></p>
<h2 id="患者和方法">患者和方法</h2>
<p>1991年至2011年，圣保罗联邦大学神经外科和儿科肿瘤研究所对303名18岁以下脑干肿瘤患者进行了治疗。其中，本文的第一作者对207进行了手术治疗。其余96例为弥漫性肿瘤。在这里，我们描述了手术方法和相关的外部/内部解剖学要点。</p>
<p>脑干分为三个部分：中脑，脑桥和延髓。为了选择最有效，最安全的去除病变的方法，我们将脑干分为七个部分（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig1/">1e</a>）。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig1_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig1_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig1_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig1/?report=objectonly">在单独的窗口中打开</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig1/">图。1</a></p>
<p><strong>一个</strong>。脑干表面解剖。脑干分为三个部分：中脑，脑桥和延髓。中脑受视道（OT）与小脑之间的沟的限制较高，而受脑脊髓沟（Pon。Mes。Sulc。）的限制较低。桥位于上方的桥脑脑沟和下方的桥脑髓沟之间（Pont。Med。Sulc。）。延髓从桥状沟延伸至C1神经根的出口区。<strong>b</strong>，**c **<strong><em>，</em></strong> <strong>d</strong>脑干血管化。椎动脉（VA）汇合在一起，形成桥椎沟水平的基底动脉。基底动脉（BA）在脑桥脑沟水平处引起后脑动脉（PCA）。小脑具有三个表面：腱膜，岩膜和枕下。小脑和延髓的枕下表面由小脑后下动脉（PICA）提供。小脑和脑桥的椎体表面由AICA和基底动脉穿孔器提供，而小脑的中脑和腱膜表面由小脑上动脉（SCA）分支提供。<strong>Ë</strong>脑干又分为七个部分：腹侧，中央和背侧中脑。腹桥和背桥; 和腹和背髓质。<strong>f</strong>根据内侧马鞭草（ML）的病程对脑干进行解剖划分。在ML的前面可以认为是腹侧脑干，而在内侧的lemniscus后面可以视为背侧脑干</p>
<p>中脑分为三个部分：前，中和后。前段由黑质向后定界。中脑从黑质延伸到渡槽。后部仅限于四边形板。桥被分为两个部分：前部和后部，或腹侧和背侧。同样，延髓被分为前壁和后壁，或腹侧和背侧。对脑干外部和内部解剖结构的详细了解对于避免手术方法中的发病至关重要。</p>
<h3 id="中脑">中脑</h3>
<p>中脑通过视道和脑梗之间的沟与二脑分开，而脑桥沟则与中脑分开。在解剖学上，三个结构应当广泛认可中脑：位于脑前外侧部的锥体束，所述第三和第四颅神经[细胞核<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR63">63</a> ]（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig1/">1</a>和<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig2/">and2a）。</a><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig2/">2a</a>）。第三颅神经的核水平在上丘的下半部和下丘的上半部。滑车核位于下丘的下半部尾侧。这些核位于中线附近，平均在外侧中脑沟表面内侧9.5 mm处。中脑外侧沟从内侧膝状体向下延伸到脑桥脑沟以下。该沟被认为是腹外侧中脑的后极限。第三颅神经沿着中脑的整个中央部分有很长的路程，而第四颅神经的内在部分较小，并且贯穿对侧小脑间脑裂隙。第三颅神经从中脑梗的内侧沟流出，并向动眼三角形移动，进入其进入海绵窦。中脑通过中脑穿孔的基底动脉分支接受血液供应。它们分为前内侧，前外侧，外侧和后分支。前内侧分支分为外侧和内侧。内侧分支供应红色核，导水管周围的灰质以及第三和第四颅神经核。外侧分支供应内侧的圆盘菌，黑质和上小脑梗。前脑中脑动脉被称为小脑分支，并供应小腿，黑质和内侧韧带。它们来自许多动脉，包括胶状，后脉络膜内侧，后交通动脉，小脑上动脉和脉络膜前动脉。后动脉由小脑上动脉的分支和胶状动脉形成，并形成一个累及四头肌板的神经丛[<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR55">55</a> ]。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig2_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig2_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig2_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig2/">图2</a></p>
<p><strong>一</strong>中脑的动眼神经的水平示意图。黑质和lemanscus内侧是中脑腹侧（<em>前</em>）和中部之间的边界，而大脑输水管的水平是中脑中央（<em>蓝色</em>）和背侧（<em>后部</em>）（<em>绿色</em>）之间的边界。腹中脑的皮质脊髓束（<em>黄色</em>）（<em>红色</em>）; 中枢（<em>蓝色</em>）和背中脑的CN III（<em>黄色</em>）和IV（<em>红色</em>）的核和进程。<strong>b</strong>中脑的侧面图。腹侧（前）中脑，包含皮质脊髓束（CST），位于内侧盘球菌（ML）和黑质前面。中央的中脑包含红色，动眼神经和滑车核，位于中部圆盘菌和渡槽之间。由上侧（SC）和下侧结肠（IC）组成的背中（<em>后</em>）中脑位于大脑导水管的后面。CN III和IV的核正好位于渡槽的腹侧。<strong>c</strong>中脑前视图。_1_周期性运动进入区的内侧为CN III的出口点，外侧为皮质脊髓束（CST）。<strong>d</strong> 周围运动区受大脑后动脉（PCA）的限制，受小脑上动脉（SCA）的限制</p>
<h3 id="前中脑">前中脑</h3>
<p>中脑前部的肿瘤通常沿两个方向生长：朝向第三脑室和朝向椎间盘水箱。对于生长到第三脑室的肿瘤，使用了跨孔，经call，经脉络膜或经孔的方法。当病变的大小小于2 cm时，可以使用与超声抽吸器相连的神经内窥镜切除肿瘤，其中大多数是低度星形细胞瘤（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig3/">3</a>）。当这些肿瘤向椎间盘水箱生长时，通常会出现韦伯综合征（第三颅神经损伤和对侧偏瘫）（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig4/">4</a>）。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig3_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig3_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig3_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig3/">图3</a></p>
<p><strong>一</strong>内窥镜访问位于中脑的前部和上部分肿瘤。<strong>b</strong>一名8岁的颅内高压患者。病变存在于中脑的前部和上部地形中。<strong>c</strong>在内镜下彻底清除病变并进行脑导水管通畅后的3年随访。诊断为低度星形细胞瘤。<strong>d</strong>。大脑中部及完全切除后外生性肿瘤的术中内窥镜检查。通过门罗的孔后，在第三脑室的底部看到并去除了病变</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig4_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig4_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig4_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig4/">图4</a></p>
<p><strong>a</strong>，<strong>b</strong> 4岁女孩患有右Weber综合征，其实性/囊性中脑前病变，向椎间盘池扩展。<strong>c</strong>，<strong>d的</strong> 6年随访显示，额眶眶骨入路（上皮星形细胞瘤）全切除</p>
<p>经中枢神经的途径可通过经典的翼状,、眶额front合zy或颞temporal途径来接近中脑的前部和前外侧病变。通过这些途径，可以通过颞极方法（颞下或颞下颞下）结合方法。Sano在1980年描述了颞极方法[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR58">58</a> ]。它允许在后上方向的颞叶上开放并可视化前外侧椎间窝。另一种使用的方法是颞下颞叶，如Krause在1911年所描述的[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR36">36</a>]。这种方法增加了由于拉贝复合体的静脉损伤而引起的静脉梗死的风险，以及由于沿腱弓ci裂引起的第三和第四次颅神经损伤而引起的眼瘫。另一方面，这种方法可以很好地观察切牙空间。切口可确保基底动脉，椎间盘池，脑干和脑桥腹侧表面良好暴露。Bricolo和Turazzi [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR7">7</a> ] 描述了一个进入前外侧中脑的“相当安全”的进入区域，因为皮质脊髓束的纤维仅占据了花梗的中间五分之三（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig2/">2c）。</a>）。该狭窄的窗口在上方由大脑后动脉界定，在下方由小脑上动脉界定，在内侧由颅神经III和基底动脉出现，在外侧由锥体束界定（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig5/">5</a>）。这里的肿瘤通常是外生的，因此不必进入脑干，并且可以在病变的出口处切开肿瘤。在局灶性肿瘤的情况下，需要切开脑干，可使用菱形手术刀。不使用双极凝血。平行于第三颅神经切开切口，以防止锥体束损伤。以这种方式进入被称为周运动。此策略必须格外小心，以免损伤红色核，锥体束和动眼神经。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig5_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig5_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig5_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig5/">图5</a></p>
<p><strong>一个</strong>。一名7岁的患有复视和右侧动眼神经麻痹的患者。MRI显示局灶性和固有病变与中脑第三神经的固有进程平行。<strong>b</strong>。完全切除后5年的随访，无残留病变</p>
<h3 id="中脑-2">中脑</h3>
<p>位于中脑中部的肿瘤也可以沿两个方向生长：朝向松果体区域或进入第四脑室。当它们向第四脑室生长时，采用枕下cip骨入路。它们生长时朝向松果体区，我们使用在1911 [由克劳斯建议的路径<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR37">37</a>]和普及斯坦因[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR60">60</a> ]，这是枕下幕上入路线（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig6/">6</a>和<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig7/">和7），</a><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig7/">7</a>），进一步分为中位数或次中位数。这种方法通常使患者处于坐姿。进行广泛的后颅窝开颅手术，并切除C1弓。这种方法允许小脑的广泛运动。在Vermian静脉凝结后，小脑下降以允许进入中脑。当病变位于内侧时，我们也会使小脑前中央静脉凝固。当病变位于外侧时，无需凝固该静脉（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig8/">8）。</a>）。在该区域应小心，因为第四颅神经位于下丘的正下方。对于有外生性病变的患者，无需切开脑干，我们可以直接接近肿瘤，除了小海绵状瘤，我们使用了三种通路：上，下周围胶体和通过中脑沟。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig6_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig6_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig6_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig6/?report=objectonly">在单独的窗口中打开</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig6/">图6</a></p>
<p><strong>一个</strong>。肿瘤位于中脑中央，并向松果体区域生长。<strong>b</strong>幕下race上小脑入路。<strong>c</strong>通过腹下sup上小脑途径的松果体区域的解剖图。_SC_上丘，_IC_下丘</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig7_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig7_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig7_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig7/?report=objectonly">在单独的窗口中打开</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig7/">图7</a></p>
<p><strong>a</strong>，<strong>b</strong>通过中央下ten上小脑入路切除了中脑中央的一个实体囊性肿瘤，其中g的增强朝向松果体区域生长。<strong>c</strong>，<strong>d</strong>十年随访没有发现病变的证据，这是一个毛细血管星形细胞瘤</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig8_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig8_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig8_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig8/">图8</a></p>
<p><strong>一</strong>中脑的侧视图。中脑外侧沟（LMS）在中脑表面延伸，从上方的内侧膝状体（MGB）延伸至下方的脑桥脑沟（Pont。Mes。Sulc。）。LMS沿着内侧马鞭草（ML）的外侧边缘延伸。<strong>b</strong> ML将中脑分为腹侧（<em>前</em>）和背侧（<em>后</em>）部分。通过LMS进入时的神经关键结构是前中脑的皮质脊髓束，中脑（盖骨）中枢的红色，动眼和滑车核，后上（_后背）上_丘的核。） 中脑。动眼神经核在中线位于上丘的下半部和下丘的上半部，而滑车核在中线上位于下丘的下半部。<strong>c</strong>沿中脑外侧沟经下sup上小脑途径到达中脑中央的侧部病变。<strong>d</strong>完全切除后五年随访，无病变迹象，细胞性星形细胞瘤</p>
<p>从关节周围进入点，可以进入两个“安全区”：在下大脑以下或中枢神经下或在滑车神经上或在关节上神经上方的中脑切口。在颈上方法中，在上睑上方正好做一个横向切口，并应由导水管限制。这种方法的进一步扩展会损害颅神经III和IV的神经核，以及内侧纵筋膜。通过颈下通路，在滑车神经与下丘的下缘之间进行横向切口。至于上上路，比脑导水管更深的切口会损伤第三和第四颅神经的核以及内侧纵筋膜。</p>
<p>对于扩展到第四脑室的病变，我们可以切开小脑的四角形叶，以便更大程度地进入小脑中脑裂隙。在这种方法中，必须对第三和第四神经核以及它们在中脑内部的活动进行空间想象。</p>
<p>在这种情况下，超声抽吸器非常重要，肿瘤的颜色对于完全切除也最有帮助。但是，有些肿瘤的颜色与脑干的颜色相同，因此外科医生必须依靠纤维的位置以及肿瘤的质地和循环。肿瘤通常比正常的脑干更柔软，血管也更多，因此更容易切除。</p>
<h3 id="后背中脑">后（背）中脑</h3>
<p>后脑或四肢后板是大脑输水管后的中脑部分的名称。四边形板的肿瘤是最小的脑瘤，有可能杀死脑积水患者。它们约占脑干小儿肿瘤的5％[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR24">24</a> ]。它们通常是惰性病变，其治疗仅限于脑积水的治疗。大多数时候，这些肿瘤在T1加权图像上是等强度的，而在T2加权图像上是高强度的。多达19％的病例可能进行了lin增强MRI检查[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR23">23</a> ]。</p>
<p>脑积水最好通过内镜第三脑室造口术治疗[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR38">38</a> ]。由于活检区域远端有出血的可能，应避免内镜活检（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig9/">9</a>），大多数此类病变为低度星形细胞瘤，例如毛细胞性和非星形细胞性星形细胞瘤，混合性神经胶质瘤和极少数更具侵略性的肿瘤作为间变性星形细胞瘤[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR50">50</a> ]。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig9_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig9_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig9_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig9/?report=objectonly">在单独的窗口中打开</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig9/">图9</a></p>
<p>内镜活检四头肌钢板病变-上皮星形胶质细胞瘤后脑室内出血</p>
<p>一些肿瘤可能会生长并需要手术。在这种情况下，已经使用了两种类型的方法：当它们向第三脑室生长时，选择了小脑上fra肌下肌上神经支配途径（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig11/">11</a>）。然而，如果它们向第四脑室的上部生长，则首选由Poppen [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR51">51</a> ] 提出并经Ausman [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR3">3</a> ] 修改的经枕后入路（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig10/">10</a>）。经颅枕后入路由Horrax于1937年首次描述[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR28">28</a> ]，由Poppen于1968年提出[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR51">51</a> ]，并于1971年由Jameson推广<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR30"> [30]。</a>]。已经描述了几种手术位置，例如坐着，俯卧，协和和四分之三俯卧。Ausmann（1988）[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR3">3</a> ]描述了经枕后入路，四分之三的俯卧位，病变侧向下，冠状平面与地板成45度角，头部弯曲30度和15度仰角。这使得枕叶在重力的作用下掉落，因此脑部回缩的需求减少，并且因枕叶回缩而导致同名偏盲的风险也降低了。这种方法可以很好地观察松果体区域，中脑的后外侧表面，小脑的腱膜表面，call体的脾脏以及第三脑室的后三分之一。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig10_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig10_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig10_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig10/?report=objectonly">在单独的窗口中打开</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig10/">图10</a></p>
<p>四头肌板中的<strong>一个</strong>肿瘤向第四脑室生长。<strong>b</strong>经枕后入路。<strong>c</strong>枕骨右后视图。松果体和脾脏暴露。<strong>d</strong>。四头肌板状肿瘤生长至第四脑室，通过经枕骨入路手术。<strong>e</strong>。病变完全切除后9年的术后影像学检查，未显示肿瘤的证据，这是毛细血管星形细胞瘤</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig11_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig11_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig11_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig11/?report=objectonly">在单独的窗口中打开</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig11/">图11</a></p>
<p><strong>一个</strong>后验（<em>背</em>）中脑由一对上级（SC）和下丘（IC）的。在上丘的上边缘的正上方制作横颈上切口（<em>1</em>）。鞘膜下切口（<em>2</em>）在CN IV与下丘的下边缘之间横向指向。<strong>b</strong>进一步解剖背（后）中脑。重要的标志是大脑导水管，它位于中线内侧纵筋膜（MLF），动眼神经和滑车核的后面。红色核从下丘的中层延伸到第三脑室的侧壁。<strong>C</strong>朝第三和第四脑室生长的大肿瘤的卡通，可以通过合并下in上小脑然后再进行枕下小脑入路来接近。<strong>d</strong>一名5岁患者的四头肌板的大型毛细细胞星形细胞瘤，向着第三脑室和第四脑室生长，通过合并的小脑下-下肌腱膜和telovelar通路穿过菱形窝。<strong>e</strong>术后MRI扫描显示完全切除</p>
<p>该方法主要推荐用于具有较大的上，外侧延伸的肿瘤，移位的静脉复合体会通过后内侧通路损害肿瘤的视野。</p>
<p>在这种方法中，进行枕骨开颅手术，包括枕骨缝线并与横断和上矢状窦相连。硬脑膜可以C形打开，其底部朝向上矢状窦，或者以两个三角形打开，底部朝向上矢状和横窦。小脑腱鞘平行于直窦打开1.5至2厘米。还可以在call体脾小切口上做一个小切口，以扩大肿瘤延伸到III脑室后三分之一的视野。当肿瘤向第三脑室和第四脑室的上部生长时，该区域变为“盲区”，因此，我们使用枕下上小脑与下枕小脑上入路相关联，以到达第四脑室[图<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR4">4</a> ]（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig11/">11</a>）。</p>
<p>因此，对于中脑手术，我们有四个“安全区”：通过前区病变的动眼区，上眼睑上皮，下眼睑下皮以及通过中脑外侧沟至中脑中段。中脑后部病变通常是外生性的，不需要脑干切口。</p>
<h3 id="庞斯">庞斯</h3>
<p>多数桥脑肿瘤是弥漫性的。因此，切除手术是无益的，并建议进行化学疗法/放射疗法。神经外科医生必须区分局灶性，低度外生性和弥漫性肿瘤，患者才能从手术中受益。</p>
<p>桥位于桥上脑桥和桥下脑桥之间。桥脑桥在内侧盘区被分为两部分，分别为前，后或腹侧和背侧。桥包含锥体束，比中脑的锥体束更位于内侧和前方，以及三叉神经，外展肌，面部神经和前庭脉络神经和核。因此，必须了解脑桥中第五，第六和第七颅神经的内在和外在解剖结构（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig12/">12</a>）。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig12_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig12_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig12_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig12/">图12</a></p>
<p><strong>一个</strong>。脑桥的皮质脊髓束的地形（<em>黄色</em>）。VI（<em>绿色</em>）和VII（<em>橙色</em> / <em>红色</em>）颅对的核和过程。<strong>b</strong>侧面图。位于内侧马鞭草（ML）前面的腹桥和位于ML后面的背桥已经暴露。<strong>c</strong> pons的前视图。三角肌上（<em>1</em>）和三叉神经周围（<em>2）</em>）安全进入区用于位于腹桥的病变。在脊椎脑沟下方4 mm处做上神经上切口，矢状位与CN III的出口相同。三叉神经周围的切口位于CN V的进入区域的中间，并位于CN V和CN VII之间。<strong>d</strong>腹桥的侧面图。处于危险状态的神经关键结构是皮质脊髓束，三叉神经运动核和CN V–VIII的桥脑段</p>
<p>面神经围绕第六神经核行进。当通过菱形窝接近肿瘤时，必须很好地建立这种关系。三个动脉组为桥提供血液：前内侧，外侧和背侧。前内侧动脉来自基底动脉和末端椎动脉分支。这些动脉可滋养中上睑板（包括锥体束），内侧马鞭草，内侧纵向筋膜，网状结构和外展核。小脑上动脉（SCA），小脑前下动脉（AICA）和桥脑长动脉产生了穿孔侧支。它们提供小脑上皮梗，中央被膜束，列氏菌侧，蓝斑，运动和感觉三叉神经主要核，外展核，面核，上橄榄核，桥状网状核，盘生侧和锥体束。SCA终末分支包括脑桥的后动脉供应。他们灌注上小脑梗，三叉神经的中脑核和蓝斑[<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR55">55</a> ]（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig13/">13</a>）。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig13_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig13_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig13_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig13/">图13</a></p>
<p><strong>a</strong>后乙状结肠入路可用于三叉神经上和三叉神经进入区。<strong>b</strong>前乙状突入路为三叉神经上缘和三叉神经进入区提供了良好的暴露</p>
<h3 id="前桥">前桥</h3>
<p>前桥和上桥的肿瘤可使用眶额front合途径进行，这是Jane等人描述的眶上颅骨开颅术的一种改进。1982年[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR31">31</a> ]。第三颅神经是该方法的关键参考点。为了暴露桥的上部，有必要用腱鞘自由边缘的硬膜切开术解剖椎间孔和桥前池。入口点是原始的。在中脑桥脑沟下方从第三至第五颅神经的直线上切一个4毫米的垂直切口; 因此，我们将这种进入途径命名为“ supratrigeminal”。我们已经将该途径用于上腹部损伤，而没有额外的患者发病率（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig14/">14</a>）。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig14_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig14_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig14_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig14/?report=objectonly">在单独的窗口中打开</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig14/">图14</a></p>
<p><strong>a</strong>，<strong>b</strong> 8个月大的患者，在桥的前部和上半部有较大病变，通过眶上front行经上原肌进入区进入。<strong>c</strong>，<strong>d</strong>病变完全切除后6个月的术后随访</p>
<p>对于位于脑桥前部和下部的病变，或对于腹侧病变，已使用了乙状结肠前入路（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig15/">15</a>）。在脑桥的切口是在第五和第七颅神经的出现点之间纵向进行的。但是，该走廊太窄，仅适合活组织检查或清除其中的海绵状瘤。这种方法可以通过枕骨旁正中途径或岩相途径来实现。在脑桥的前入路中，第五神经出现周围的区域是一个安全区域，该区域应在距中线1 cm处打开1 cm宽，但应注意不要太前移以避免皮质脊髓束。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig15_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig15_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig15_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig15/?report=objectonly">在单独的窗口中打开</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig15/">图15</a></p>
<p><strong>a</strong>，<strong>b</strong> 10岁四肢轻瘫患者。肿瘤采用前乙状结肠入路手术。<strong>c</strong>，<strong>d</strong>完全切除后10年的术后控制，无肿瘤迹象</p>
<h3 id="后桥">后桥</h3>
<p>桥后病变通过菱形窝进入（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig16/">16</a>）。优越和后脑桥病变由telovelar路线访问，也称为小脑延髓裂入[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR42">42</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR43">43</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR46">46</a> ]。面神经上方脑干的开口称为上颌三角，由内侧纵向筋膜（即中沟）在内侧定义，由面神经尾部（以面部胶原作为参考）定义，由外侧上小脑梗。这个三角形大约是1 cm <sup>2</sup>。尽管这是一个安全的进入三角形，但谨慎地建议在表面上进行双极刺激以定位面神经的走向，这可能由于肿瘤的生长而偏离了方向。进入该区域的距离必须始终距中线2毫米，以保持内侧纵筋膜。但是，与部分面神经受累相比，该束损伤后的恢复非常快。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig16_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig16_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig16_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig16/?report=objectonly">在单独的窗口中打开</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig16/">图16</a></p>
<p>脑桥皮质脊髓束<strong>的</strong>地形图（<em>黄色</em>）。CN VI（<em>绿色</em>）和VII（<em>橙色</em> / <em>红色</em>）颅对的核和过程。<strong>b</strong>由CN VI核和CN VII的桥脑内节段产生的面部丘疹是第四脑室底部最重要的标志。<strong>c</strong>有四个避免损坏的重要结构：内侧纵筋膜（MLF），中央被膜束（CTT），三叉神经中脑（TMT）和脊柱（TST）。<strong>d</strong>后脑干安全区：_1个_胶束周围，_2 __个_筋膜上，_3个_界面，_4个_侧沟局限，_5个_下面部和_6个_中部。<strong>e</strong>面上进入区（<em>2</em>）的上方是含CN IV的腓肠葡萄膜缘，下方是面部胶束（FC），内侧是纵向纵筋膜（MLF），外侧是龈沟，外侧沟。<strong>f上</strong>中央凹，是由沟沟形成的凹陷，呈三角形（<em>绿色三角形</em>）。该三角形的顶点与面部眼睑的最上边缘在相同的轴向水平处。三叉神经运动核（<em>黄色圆圈</em>）位于该三角形的上外侧边缘的较深点。<strong>g</strong>面下进入区的上方是面部胶原，下方是舌下（CN XII）三角形，内侧是纵向纵束（MLF），中间是CN VII核和歧核。<strong>^ h</strong>。中枕下入路被用来到达第四脑室的底部。<strong>我</strong>切开了Telovelar交界处。<strong>j</strong>暴露于第四脑室的地板</p>
<p>该形貌在上，横向方向略微缩回，而应尽可能避免在尾端方向缩回（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig17/">17</a>）。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig17_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig17_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig17_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig17/?report=objectonly">在单独的窗口中打开</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig17/">图17</a></p>
<p><strong>a</strong>，<strong>b</strong>桥上和后桥肿瘤通过枕下小脑门入路进入，并通过point上三角进入桥脑。星形细胞瘤II级。<strong>c</strong>，<strong>d</strong>术后控制显示总切除</p>
<p>对于后部和下部病变，使用经下三角肌（图<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig18/">18</a>）的颈下途径，该三角肌  以内侧边界为内侧纵束，并以延髓纹尾部为界，面神经以外侧为界。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig18_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig18_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig18_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig18/?report=objectonly">在单独的窗口中打开</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig18/">图18</a></p>
<p><strong>a</strong>，<strong>b</strong> 5岁的桥脑病变患者通过面下入路接近。<strong>c</strong>，<strong>d</strong> 8年随访。星形细胞瘤</p>
<p>这是一个较小的三角形，安全距离并不总是相同，因此必须进行术中监护。如Kyoshima等人所述，进入颈下三角形的安全区域。[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR39">39</a> ]将从平均距上肢6.5毫米处开始，沿颅尾方向延伸9.2毫米；颈上三角在上颌骨上方平均22.5 mm，延伸13.6 mm。</p>
<p>当在菱形窝中没有发现空间时，我们使用了第三种方法，即界面方法。Bricolo和Turazzi [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR7">7</a> ]描述了菱形窝中线进入可能在面部神经丛的水平，靠近第六神经核，因为内侧纵筋膜的纤维尚未在该水平交叉。在这种方法中，内侧纵筋膜被破坏，这可能会干扰眼睛的共轭运动。从外科手术的角度来看，我们采用了双侧小脑入路，第四脑室的脉络膜丛凝结，从而可以从足尖到脑导水管充分进入，而无需损害小脑ver骨。</p>
<p>通过侧沟限制器也可以通过telovelar方法接近更多的侧部病变[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR40">40</a> ]。</p>
<p>劳顿等。[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR40">40</a> ]提出了上小脑上梗的上颌骨入路，而无需打开静脉室并进行扩大的小脑入路。已经针对海绵状瘤描述了该途径，但是对于延伸至中线的小脑下脚蒂的肿瘤病变可能就足够了。最好在神经导航的帮助下使用此技术。</p>
<p>因此，对于pons，我们有以下“安全区”：原始肌上，三叉神经周围，肌上，基底下，界面以及通过侧沟限界。</p>
<h3 id="髓质">髓质</h3>
<p>延髓是脑干的最尾部，它通过球囊沟与脑桥分开（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig19/">19）。</a>）。延髓的下限是腹面的金字塔形肉瘤和大孔。后表面是尖顶。它从椎动脉和脊柱前动脉的分支接收血液供应。前外侧穿孔动脉浸润锥体束和下橄榄核。外侧动脉是小脑后下动脉（PICA），小脑前小动脉（AICA）以及椎动脉和基底动脉的分支，它们灌注小脑下花梗，脊髓丘脑束，脊髓小脑中央束，椎管，视网膜迷走神经的背运动核，孤束核和束道，以及舌下，前庭，耳蜗，楔形和big义核。卵状和楔形的核，后区域和迷走神经，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR55">55</a> ]。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig19_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig19_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig19_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig19/">图19</a></p>
<p>橄榄状髓质<strong>的</strong>示意图，其中存在IX，X（<em>绿色和粉红色</em>），XI和XII（<em>红色</em>）颅对，以及皮质脊髓束道（<em>黄色</em>）的形貌与pons和中脑相比 <strong>b</strong>腹髓质。腹侧髓质的安全进入区是食管前和食管后沟。橄榄前沟位于橄榄和金字塔之间，而金字塔是CST所在的地方。橄榄上凹陷的凹陷，即上眼窝突节，正好位于面部和前庭静脉神经与脑干交界处的下方。舌咽，迷走神经和副神经离开橄榄核正下方的延髓，位于橄榄和小脑小脑梗（ICP）之间。舌下根沿着小窝前沟离开延髓。<strong>c</strong>远侧入路用于卵巢前和后沟。<strong>d</strong>背髓质。后中位（PMS），中位（PIS）和后外侧（PLS）沟已被建议作为安全进入区。枕下正中入路</p>
<h3 id="延髓前">延髓前</h3>
<p>髓质可能是最难接近的结构，因为位于其中的IX至XII颅神经对的细胞核密度很高。位于髓质前部的病变可通过远侧入路进入。最初由Heros [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR27">27</a> ]和George等人描述了这种方法。[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR21">21</a> ]在颅脑交界处。根据要切除的con的部位，方法有很多变化：trans突、,上和para旁暴露[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR56">56</a> ]。对于儿童，可以在不去除the的情况下进入髓质的前部（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig20/">20）。</a>）。齿状韧带靠近椎动脉入口的部分有助于髓质的活动性，因此侧向进入变得更容易，因为它避免了开放opening。访问脑干可以是前橄榄，后橄榄，或有时通过橄榄体，优选地在后-橄榄沟（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig20/">20</a>和<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig21/">AND21）。</a><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig21/">21</a>）。可以通过前外侧沟进入延髓。该进入区沿乳腺前沟，位于尾部舌下和头侧C1小根之间。它位于锥体束附近，靠近椎体折返处，仅应用于胞外病变[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR9">9</a><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR9"></a>]。橄榄后沟是一个安全的进入区域。据雷卡尔德等。[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR53">53</a> ]，橄榄体在颅尾轴上提供大约13.5 mm的手术空间，在横轴上提供大约7 mm的空间，在前闻轴上提供大约2.5 mm的手术空间。进入区穿过橄榄后沟，位于橄榄和小舌根下腹腹面至舌咽和迷走神经小根之间[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR53">53</a> ]。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig20_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig20_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig20_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig20/?report=objectonly">在单独的窗口中打开</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig20/">图20</a></p>
<p><strong>a</strong>，<strong>b</strong> 2岁患者发展为四肢瘫痪。存在髓质前部的大肿瘤。远侧入路和经橄榄石切入点用于切除细胞性星形细胞瘤。<strong>c</strong>，<strong>d</strong>十一年随访，未显示肿瘤证据</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig21_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig21_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig21_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig21/">图21</a></p>
<p><strong>a</strong>，<strong>b</strong>在第四脑室有外生性延伸的颈髓肿瘤。术后5年的<strong>c</strong>，<strong>d</strong> MRI无肿瘤迹象</p>
<h3 id="后延髓">后延髓</h3>
<p>髓质后部的内在病变很难接近，因为该区域的细胞核数量巨大。另一方面，其中的大多数损伤具有外生成分，这有助于进入。这些肿瘤称为宫颈髓样。可以通过中线穿过后正中沟进入下位点下方的髓样病变，而髓内病变也是如此。</p>
<p>在术中，可能发生严重的营养改变，例如右侧的髓质病变为高血压和心动过速，左侧的髓质病变为心动过缓。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/" title="转到此页面的其他部分">去：</a></p>
<h2 id="结果-2">结果</h2>
<p>从1991年到2011年，我们评估了303名年龄在18岁以下，肿瘤位于脑干的患者，这些患者位于圣保罗联邦大学小儿神经外科服务中心和儿科肿瘤研究所。96例为扩散性肿瘤，接受了化学疗法/放射疗法。本文的第一作者对其余207例患者进行了手术，占同期该服务手术的所有患者（2015年患者）的9.1％。年龄从8个月到18岁不等，平均年龄为10岁。在这些患者中使用了之前描述的所有“安全区”，而在三名患者中，对于前桥和上桥的肿瘤，使用了一个新的“安全区”，即所谓的上皮肌瘤。一百例患者未进行术中监护，而有107例进行了监护。 <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/table/Tab1/">1</a>。</p>
<h3 id="表格1">表格1</h3>
<p>根据地形，方法，安全区入口点和发病率/死亡率划分的207例手术病例的分布</p>
<table>
<thead>
<tr>
<th>地形</th>
<th>师</th>
<th>方法</th>
<th>安全区入口点</th>
<th>发病率/死亡率</th>
</tr>
</thead>
<tbody>
<tr>
<td>中脑（84）</td>
<td>前部（16）</td>
<td>经室经孔内镜入路（6）</td>
<td>外生性病变</td>
<td>没有</td>
</tr>
<tr>
<td>翼状或额-融合go突入路（10）</td>
<td>眼动马达（10）</td>
<td>没有</td>
<td></td>
<td></td>
</tr>
<tr>
<td>中位数（59）</td>
<td>腹下sup上小脑（53）</td>
<td>中位数（41）</td>
<td>颈上和/或颈下</td>
<td>-空气栓塞（2）-</td>
</tr>
</tbody>
</table>
<p>高血压性
脑室（10）
-震颤（2） |
| 半正中（12） | 中脑外侧沟 |
| ten下上臂小脑结合Telovelar入路（6） | 颈上和/或颈下 | 没有 |
| 后方（9） | 枕骨下颌（8） | 外生性病变 | 没有 |
| ten下上臂小脑结合小脑入路（1） |
| 庞斯（72） | 前部（11） | Fronto-obito go行transylvian方法（3） | 三叉神经上（3） | 没有 |
| 乙状结肠（8） | 原始的（8） | 没有 |
| 后方（61） | 枕下颅骨开颅手术，采用小脑入路（61） | 面部上的（45） | -MLFI（6）- 
面部轻瘫（3）- 
死亡（1） |
| 界面（3） | -MLFI *（2） |
| 面下（13） | 面部轻瘫（9） |
| 灯泡（51） | 前部（11） | 远侧方法（11） | Transolivar | 没有 |
| 后方（40） | 枕骨下开颅配合Telovelar入路（40） | 中线 | -死亡（3）-呼吸
和吞咽障碍（9）
-声带不协调（2） |</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/table/Tab1/?report=objectonly">在单独的窗口中打开</a></p>
<p>_MLFI_内侧纵筋膜损伤</p>
<p>84名患者患有中脑肿瘤。十六个位于中脑的前部，59个位于中脑中央，九个位于四头肌板中。6例肿瘤位于前部并延伸至第三脑室的患者接受了纯净的神经内窥镜检查，并配有超声抽吸器设备（Sonoca 300和92–030微型手机-Söring）。所有病变均为外生性的，无需切开脑干。肿瘤出血不多，可以用低功率的超声吸引器轻松吸出。这些患者的主要临床表现是因脑积水引起的颅内高压。所有肿瘤均为毛细血管星形细胞瘤，无需完成心室分流即可完成切除。十例中脑前部肿瘤延伸至椎间窝窝的患者通过经椎弓根入路手术。对于外生性肿瘤，通过经典的翼状ional肉获得了6次通入，通过额眶眶go合术获得了4次通入，并且进入脑干的通路位于第三神经的侧面（周期性运动进入）。对于中部中脑（59例），有53例患者在坐位时经bell上下臂入路入路，中位41例，中位12例。在六例患者中，通过合并中上小脑下肌下肌入路和通过枕形颅窝进入枕​​下下颌小路，实现了入路。对于内侧上小脑腓肠肌入路，在所有情况下小脑中枢静脉均已凝结，未发生并发症。在旁中位通路中，小脑前中央静脉的凝结是没有必要的，而脑干的进入点是通过外侧中脑沟。两名患者发生了空气栓塞，需要通过中央静脉导管进行抽吸以解决该问题。进气点位于乙状窦附近的横窦，这是硬脑膜开口的最高和最侧向的点。十名患者患有高血压的脑室，其中两名接受了神经内镜检查。两名患者患有氯硝西controlled控制的手部震颤。9例患者的四肢椎板肿瘤，其中8例通过四分之三俯卧位进行手术，另外1例通过in下上臂小脑和枕后小脑下入路联合手术。所有中脑肿瘤均为低度星形细胞瘤，</p>
<p>在168例脑桥肿瘤患者中，有96例为弥漫性且未进行手术。手术切除了72个肿瘤。肿瘤位于前桥和上桥的4例，前桥和下桥的7例，上桥和后桥的48例，下桥和后桥的13例</p>
<p>对位于前桥和上桥的三个肿瘤采用额眶-合手术，脑干进入点位于上颅骨上方，在第三颅神经和三叉神经之间，距中脑桥脑沟以下4 mm。一例采用乙状结肠前手术治疗。这些在脑桥的前部和上半部均患有肿瘤的患者均未发病。在七例中，肿瘤位于桥的前部和下部，并通过乙状结肠前路进入。48个肿瘤位于后桥和上桥，十三个肿瘤位于桥的后桥和下桥。所有位于桥脑后部的肿瘤均通过一条经鼻菱形窝的条状路径进行手术，患者处于俯卧位。上桥和后桥的肿瘤有45个，通过面上通路进行治疗，其中3例使用了在面部上丘上方的界面通路。在6例采用经上路手术的患者中，有3例发生了内侧纵筋膜和面部轻瘫的损伤。在所有情况下，术后6个月症状都会消退。一名患者发生了急性脑积水，并在3天后死亡。在使用界面途径进行手术的三例中，两个发展中的内侧纵筋膜损伤症状在6个月内消失。没有观察到面神经受累。13名患者在桥的后部和下部有肿瘤，并通过面下途径进行手术。其中八名患者出现面瘫，5例导致永久性瘫痪。III级和IV级星形细胞瘤22例，低级星形细胞瘤50例。</p>
<p>51名患者患有髓样肿瘤，其中11个位于前部，40个位于所谓的子宫颈髓交界处。使用远侧入路进入前部肿瘤，其进入点通过橄榄髓延髓途径或外生性肿瘤所在。在所有情况下均使用该途径进行齿状韧带切除术。宫颈肾小球交界处肿瘤采用中腹线纵向切开的髓腔的条状小路手术。9名患者出现呼吸和吞咽恶化。3例患者仍处于呼吸衰竭，并在手术后2个月内死于肺炎。两名患者由于声带不协调而需要进行永久性气管切开术。在髓样肿瘤中，有8个是神经节神经胶质瘤，3个是血管母细胞瘤，29个是星形细胞瘤，8个是III级和IV级星形细胞瘤，</p>
<p>对于整个207例经脑干手术治疗的肿瘤系列，术后头2个月的手术死亡率为1.9％（4例），而手术发病率为21.2％（45例）。本系列中的所有中脑肿瘤均为低度星形细胞瘤。在脑桥中，有50例为低度星形细胞瘤，22例为高度肿瘤。在51个髓样肿瘤中，只有8个是高度星形细胞瘤。因此，在207例脑干肿瘤患儿中，有30例（占14.4％）是高度恶性肿瘤，而有177例是低度恶性肿瘤。随访时间为3至20年，平均13年。良性肿瘤的无病生存期（5年）为92％，而高级神经胶质瘤的中位生存期为18个月。表  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/table/Tab1/">1</a> 总结了207例患者中使用的患者和安全区入口。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/" title="转到此页面的其他部分">去：</a></p>
<h2 id="讨论区">讨论区</h2>
<p>儿童比成人更常见脑干肿瘤。很少有出版物谈到儿童脑干肿瘤的手术方法。它们中的大多数与外科治疗海绵状瘤的脑干方法有关。在这个位置切除海绵状瘤的手术与切除脑干肿瘤的手术有很大不同。海绵状瘤的一个特殊特征是，由Virchow-Robin空间的扩大和凝块的固结所产生的空腔在去除凝块后会引起较大的空间，从而有利于海绵体瘤的切除。因此，在脑干表面的小切口足以去除肿大的海绵状瘤。在脑干的小儿肿瘤中，第一个缺点是与成年人的脑干相比，其结构非常小，除了罕见的囊性病变。另一方面，</p>
<p>高分辨率MRI和MRI结合对诊断的改善，对于手术决策以及选择最安全，更精确的手术方法非常有帮助。神经麻醉学，术中电生理监测和术后重症监护的进步提供了更高的安全性，允许进行更具侵略性的手术切除并防止损伤[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR61">61</a> ]。</p>
<p>神经外科手术器械也已显着发展。今天，我们拥有高亮度的显微镜，其清晰度可以更好地识别肿瘤的结束位置和正常组织的开始位置。带有钻石尖端手术刀的更轻巧，更精致的器械可以精确切开脑干。常规使用带有1毫米尖端的超声外科手术吸气器，使我们能够通过脑干的小开口去除较大的病变。与脑干解剖学的内在和外在知识相关的最合适的获取途径的手术计划，也是取得手术成功的关键。</p>
<p>脑干通常分为三部分：中脑，脑桥和延髓[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR41">41</a> ]。我们进一步将脑干分为七个部分：中脑前部，中部和后部。前桥和后桥; 和前，后延，这帮助我们选择最佳的手术方式[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR11">11</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR12">12</a> ]。</p>
<p>Cantore等。[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR9">9</a> ]将脑干分为两个手术平面-前部和后部。因此，他们将脑干中的六个区域分类。我们将中脑分为三部分的原因是因为四边形板块肿瘤的特征不同于前脑和中脑的特征。四边形板中的大多数肿瘤是惰性的，很少需要手术，将治疗局限于脑积水的控制[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR13">13</a> ]。</p>
<p>Four “safe entry zones” for the midbrain have been described. The most complex and anterior, called the perioculomotor zone, has been described by Bricolo et al. [<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR8">8</a>] There is a space between the oculomotor nerve and the pyramidal tract which can be accessed through an incision parallel and lateral to the oculomotor nerve. The presence of a tumor may increase this distance, facilitating surgery. When tumors have an exophytic component, the brainstem can be directly entered through the tumor. Clinically, these patients present preoperatively with third cranial nerve paralysis and contralateral pyramidal involvement (Weber syndrome) that usually disappears quickly after lesion removal. Small tumors only cause diplopia.</p>
<p>在我们的系列中，中脑的前部有16个肿瘤。六个正在向III脑室生长，并通过纯净的神经内窥镜和超声吸引器进行手术。我们发现很少有文献报道单纯使用神经内镜方法切除脑干肿瘤。Miki等。在6例腹侧脑干表面病变中使用了神经内镜经第三脑室入路[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR45">45</a> ]，而在1例中使用了脑干肿瘤。</p>
<p>在我们系列的十名患者中，肿瘤向椎间盘水箱生长。这些肿瘤中有六种是外生性的，大的，并通过经典的翼状route肌途径打开了西尔维安裂缝并去除了病变。有时很难在年幼的儿童中广泛打开Sylvian裂痕，简单的精细操作会引起血管痉挛，因此经常使用罂粟碱。在四名患者中，肿瘤是内在的，并且通过动眼神经通路接近了脑干。在所有情况下，均采用额眶眶zy合方法。我们还可以使用佐野（Sano）在1980年描述的颞极通道[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR58">58</a>]，它提供了椎间窝的前外侧视图。这些是我们用于中脑前部，通过第三脑室或通过毛细血管运动空间进入的通路。Konovalov和Kadyrov [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR35">35</a> ]提出了通过脉络膜颞部进入这些位于中脑的前外侧病变的途径，尤其是在占优势的一侧以及当肿瘤扩展到周围水箱时。事实是这些病变在这种地形中非常罕见。在我们的系列研究中，只有7％被认为是外科手术的肿瘤位于中脑的前部。尽管Albright 1993 [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR2">2</a> ]报告说脑干肿瘤中只有7-8％位于中脑，但Yasargil的<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR64"> [64]</a>]系列167例脑干肿瘤中，有26例（占15.5％）位于中脑，是Albright报道的两倍[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR2">2</a> ]。Garzon等。[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR20">20</a> ]发现33.8％的脑干肿瘤位于中脑。在我们的207例外科手术病例中，有84例位于中脑（40.5％），但是如果考虑到所有由我们服务治疗的脑干肿瘤病例，则这一比率下降到27.7％。我们认为这是因为我们是神经外科的参考中心，而不是弥漫性桥脑肿瘤的转诊病例。</p>
<p>在1911年，克劳斯（Krause）描述的59例中脑中枢肿瘤患者通过ten下上小脑途径手术[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR36">36</a>]，其中位数为41，中位数为12。通过准中线进近时，我们使用了与中值进近相同的通路。唯一的区别是脑干可通过外侧中脑沟进入。六例患者的肿瘤不仅朝着第三脑室生长，而且还朝着第四脑室生长，他们通过联合方法进行了手术，即在下脑室上腓肠肌，然后跨第四脑室进行枕下cip骨小脑入路。所有患者均在头部弯曲的坐姿下进行手术。进行后颅窝开颅手术，打开硬脑膜以避免枕窦，后者通常在幼儿中使用。在所有情况下都删除了C1拱门。Yasargil [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR64">64</a>]主张通过不移走C1足弓并在垂直于横窦的下方2 cm处打开硬脑膜，从而避免小脑进一步暴露以避免可能的椎间盘突出，从而进入该区域。在我们的系列中，我们没有小脑疝。Vermian静脉是小脑腱膜与腱膜和横窦之间的桥接静脉，没有任何并发​​症[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR55">55</a> ]。必要时，我们还凝固了小脑中央静脉，没有任何临床影响。在两个病例中，患者出现症状性空气栓塞，通过中心线并在靠近横窦的硬脑膜切口顶部的静脉开口的识别中，通过血液抽吸消除了症状。</p>
<p>9例四原发性板状肿瘤患者接受了手术，其中8例通过枕下经深部途径，另外1例通过合并下in上小脑和枕下小脑部途径。在四例颅神经上方，有四例进入上丘脑，五下处于下丘脑。对于中脑中央或后部向第三脑室方向生长的肿瘤，我们采用了小脑后上肌下肌入路。对于生长到第四脑室的肿瘤，我们在四分之三位置采用经枕后入路。当病变长到第三和第四脑室时，我们采用了联合通路。</p>
<p>Ogata和Yonekawa [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR47">47</a> ]提出了一条上，下，下小脑梗的皮下旁神经通路。他们证明有可能打开小脑中脑裂隙外侧的小脑中间花梗表面。</p>
<p>通往桥前部的方法最为困难。Bagahai等。[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR5">5</a> ]描述了在第五和第七颅神经的输出点之间的脑桥腹侧部分的安全进入区域。但是，该走廊非常狭窄，仅适用于该区域的活检或海绵状海绵状切除术。可以通过枕骨旁中位途径或少量途径达到这种通路。在通往前桥的其他通路中，第五个颅神经出现周围的区域是一个“安全”区域，可以向中线开1厘米宽1厘米。但是，应注意不要向前走，以免发生皮质脊髓束。</p>
<p>我们的11位患者前桥有肿瘤。前位和上位四个，前位和下位七个。通过额眶-关节入路进入了三个前部和上部肿瘤，进入病变点的是一个垂直切口，该切口位于中脑骨膜沟以下4毫米，与第三条神经的方向相同。在使用该途径手术的三名患者中，发病率没有增加。这种方法在文献中没有类似的描述，我们更喜欢称其为“上原始途径”，以区别于第五和第七颅神经之间的三叉神经途径。实际上，这个新的切入点位于锥体束内侧的第三和第五颅神经之间。腹桥的其他肿瘤采用乙状结肠前切除术治疗，</p>
<p>在后桥中有61个肿瘤，其中48个位于上桥骨，13个位于下桥骨。如Kyoshima等人提出的，通过上颌三角形接近上肿瘤。[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR39">39</a> ]，或者在外侧病例中，通过外侧沟局。在三例患者中，由于菱形窝中的肿瘤引起的畸变，通过刺激面神经来定位切入点极为困难。因此，切入点是一种优于面部胶原的界面通路，如Bricollo和Taruzzi所述[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR7">7</a>]。但是，两名患者的内侧纵筋膜受伤。通过面下三角手术治疗了13例脑桥下肿瘤。通过这种途径手术的八名患者出现了面瘫，其中五名是永久性的。我们认为，这条路线仅应保留给小型外生性肿瘤或海绵体瘤。由于该区域具有高密度的颅神经核，因此也应避免通过位于延髓纹下方的菱形窝进入。所有进入菱形窝的操作都是通过枕下途径进行的，并去除了C1弓和特洛韦勒方法，有时是双侧的，以避免打开小脑mis骨。病人的位置是腹侧卧位。</p>
<p>髓样肿瘤与脑桥肿瘤存在相同的技术难度。前枕骨通过枕下远侧颅骨切开术，切除C1弓和靠近椎动脉进入颅骨的齿状韧带部分。韧带的这一部分允许髓质进一步移动，从而有助于识别橄榄体并通过后橄榄沟进入脑干（或经橄榄石进入）。右侧的髓腔通入通常会产生术中高血压和心动过速，而左侧的通道会产生心动过缓。绝不能用诸如阿托品或降压药之类的药物来抑制这些自然警报，因为它们表明我们过于积极地操纵了脑干。这些是需要引起注意的间接生理警报。通常，这些植物性风暴在病变受牵拉时发生，应避免。相反，我们应该使用超声波抽吸器去除肿瘤，避免牵引。这些小的植物风暴不是中断程序的原因，因为它们在停止牵引和用温盐水灌溉后会立即停止。</p>
<p>位于枕骨后部的病变也可通过枕骨小门入路进行操作，延髓通过后内侧沟到达小肠下方中线。</p>
<p>脑干中有11个先前描述的“安全”进入区域。在本文中，我们描述了另一个区域，即“前上皮”，用于前桥和上桥脑损伤。该途径用于三例患者，未显示发病率。因此，这是一条合理的访问路线。但是，需要广泛的额中眼眶zy入入入来检查中脑足底沟和第三颅神经。</p>
<p>由神经外科医生来选择正确的途径以最小的发病率进行完整的病灶切除。但是，发病率仍然很高（在我们的系列中为22％）。脑干肿瘤术后脑积水一直是灾难性并发症，神经外科医生应始终意识到这种可能性。我们的一名患者死于脑积水。因此，在可能的情况下，我们会在术后头48小时内放置一个外部心室引流管。</p>
<p>脑干不允许牵引或凝结。因此，我们通常使用吸气少且尖端细腻的超声吸气器，仅在进行大量灌溉的情况下才进行双极电凝作为最后手段，因为热量可能会损坏脑干的脆弱结构。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/" title="转到此页面的其他部分">去：</a></p>
<h2 id="结论-2">结论</h2>
<p>脑干手术是神经外科中最困难的手术之一，尤其是对于小儿神经外科医生，因为儿童时期脑干肿瘤比成人时期更为常见。尽管使用束线照相术的影像学已显着发展，但它们仍未显示脑干内部的核和神经通路。解剖解剖由Klingler的的技术，研究白纤维，帮助神经外科医生在规划的手术方法[三维建筑设计<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR1">1</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR34">34</a>]。在脑干中有11个先前描述的“安全进入区”：牙周运动，外侧中脑沟，下颌入路，上颌上入路，三叉神经，上颌面，界面，下颌面，外侧沟限，唇周和后中沟。我们的三名患者使用了一个新的安全进入区，即“上原始区”，用于接近桥上和桥上病变。图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig22/">22</a>总结了接近安全区域的算法。也许在不久的将来，随着高分辨率7 Tesla MRI的改进，或另一种类型的成像能够显示出由于肿瘤的作用而导致的脑干结构中的精确偏差，再加上更有效的电生理监测系统，这类手术可能会变得更简单，发病率更低。当前，对脑干的内在/外在解剖学的更准确的了解与更先进的工具（如高分辨率显微镜和尖端较薄的超声吸气器）相关联，已使我们能够从任何患者中去除大量具有可接受的死亡率和发病率的脑干肿瘤在这个奇妙的大脑结构中的地形。</p>
<p><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig22_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig22_HTML.jpg" title="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig22_HTML.jpg"></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig22/">图22</a></p>
<p>接近安全区的算法</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/" title="转到此页面的其他部分">去：</a></p>
<h2 id="致谢">致谢</h2>
<p>作者要感谢Blanche Torres女士帮助我们撰写了这份手稿，并感谢StharMar de Vasconcelos Silva先生提供了艺术作品。</p>
<h3 id="利益冲突">利益冲突</h3>
<p>作者宣称他们没有竞争利益。</p>
<h3 id="资金和物质支持">资金和物质支持</h3>
<p>没有。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[颞下入路]]></title>
        <id>https://blog.bioprinting.site/post/1SM-ibZ3Z</id>
        <link href="https://blog.bioprinting.site/post/1SM-ibZ3Z">
        </link>
        <updated>2019-10-05T05:48:06.000Z</updated>
        <content type="html"><![CDATA[<p>这个技术是指颞下keyhole开颅经硬膜外入路显露颞骨上面。这种颞下入路的变型之目的是打开IAC，显露面神经、上前庭神经、耳蜗神经和下前庭神经。</p>
<p>https://v.qq.com/x/page/n0354yj00dq.html#</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810152908_29gfjyt5ia.jpg" alt="" title="1.webp.jpg"></p>
<p><strong>图示经颞下开颅显露内听道。在仔细去除内听道顶壁后，显露面神经、上前庭神经、耳蜗神经和下前庭神经</strong></p>
<p>在弓状隆起处仔细辨认岩浅大神经和上半规管后，整个内听道的走行就可准确的勾画出来，这样有利于避免损伤敏感脆弱的前庭耳蜗结构。按照William F. House和Ugo Fisch的方法标记“蓝线”。用小磨钻（磨除时注意要不断地持续冲水）部分去除弓状隆起的浅表骨质。弓状隆起的下方即为上半规管。“蓝线”和岩大神经共同勾画出内听道的走行。</p>
<p><strong><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810152923_km06oc7wk7.jpg" alt="" title="2.webp.jpg"></strong></p>
<p><strong>左侧。在辨认GSPN和蓝线（即上半规管）后，就可准确的勾画出IAC的走行。</strong></p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810152945_kp29xeatke.jpg" alt="" title="3.webp.jpg"></p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810152945_ljbwfgqr8x.jpg" alt="" title="4.webp.jpg"></p>
<p>位于IAC内并向CPA生长的小听神经瘤（直径&lt;5mm），可用这个手术入路切除之。当肿瘤完全位于内听道内时，尤为适合。这个手术入路的目的是：在完成肿瘤全切的同时，保护听力维持在术前水平以及正常的面神经功能。有时，前庭功能也能保留。</p>
<p>如上所述，颞下入路的优势在于可以提供显露内听道的途径。而如果将开颅的范围向前延伸，打开颞颅底硬脑膜后，就可显露鞍上和桥小脑结构。</p>
<p><strong>手术技术</strong></p>
<p><strong>1. 手术体位和术中监护</strong></p>
<p>全麻后，放置腰大池引流管。硬膜外操作前的最重要的步骤就是充分释放脑脊液，以降低颞叶的张力。除了放腰大池引流外，还有一种方法--在从硬膜外牵拉、抬高颞叶前，先在硬膜脑上切开一小口，释放脑脊液。</p>
<p>面神经肌电图是最基本的术中监测，有利于安全显露内听道的硬脑膜。通常，从解剖上比较容易识别面神经，而术中监测可确保在肿瘤切除过程中面神经能得以无损伤保护。</p>
<p>患者仰卧位，头部上抬高于胸骨平面，同侧肩部垫高；Mayfield头架固定，单钉置于额部，可避免其妨碍手术操作。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153010_r5u2lcc27i.jpg" alt="" title="5.webp.jpg"></p>
<p>Step 1：头部抬高，高于胸部，以利于颅内静脉回流，并可有效的减轻颈部结构压力。与颞下前、后入路相比，头部抬高的角度应更大，这样可更好的显露IAC。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153037_1kjct8vl9p.jpg" alt="" title="6.webp.jpg"></p>
<p>Step 2：随后，将头部向对侧旋转80°。这时，IAC的方向应是垂直的，这样方便解剖定位和手术操作。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153050_ek6m8xlgpy.jpg" alt="" title="7.webp.jpg"></p>
<p>Step 3：头部侧屈10°-15°，有利于依靠重力牵拉颞叶。与颞下前、后入路相比，这种硬膜外路径所需要的侧屈角度可小一些，方便IAC的显露。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153102_korsqejhhp.jpg" alt="" title="8.webp.jpg"></p>
<p>Step 4：与颞下前、后入路一样，头部后伸10°，这可使术者操作舒适。此外，轻微的后伸还可避免气道、喉部和颈部血管受到过度挤压。</p>
<p><strong>2. 解剖标记和定位</strong></p>
<p>这个手术入路需要掌握的关键解剖结构有：眶外侧缘、颧弓、关节结节、外耳道、乳突和乳突上嵴。注意：耳颞神经和颞浅动脉的走行。</p>
<p><strong><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153226_ugvf3v4r26.jpg" alt="" title="9.webp.jpg"></strong></p>
<p><strong>图示颞颧区关键解剖结构和开颅位置。骨窗中心应置于EAC水平，皮肤切口位于耳前、颞浅动脉后方。</strong></p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153247_wrx6tlfvho.jpg" alt="" title="10.webp.jpg"></p>
<p>标记关键解剖结构后，就可确定手术切口和开颅位置。骨窗的基底对应于乳突上嵴；骨窗的中心对应着EAC。骨窗面积约25x25mm，需充分显露IAC；直型手术切口长约5cm，位于耳前，避免损伤耳颞神经和颞浅动脉。</p>
<p><strong>3. 开颅</strong></p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153510_gat44q8xmw.jpg" alt="" title="11.webp.jpg"></p>
<p>Step 1：左侧。耳屏前直切口，分离颞浅动脉和耳颞神经，然后向前牵开并保护之。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153544_9p22clgi9m.jpg" alt="" title="12.webp.jpg"></p>
<p>Step 2：乳突牵开器牵开。”Y”型切开颞肌筋膜，显露颞肌。注意：将颞浅动脉向前方移位牵开。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153602_elxu1tkyy5.jpg" alt="" title="13.webp.jpg"></p>
<p>Step 3：如图所示牵开、固定筋膜，显露颞肌。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153622_hq8c2ufcyq.jpg" alt="" title="14.webp.jpg"></p>
<p>Step 4：钝性剥离子从下方乳突上嵴和颧弓处剥离颞肌，显露颞骨鳞部。颞肌后部通常较薄，因而没必要切开即可充分显露颞骨。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153650_jq0e9xjklp.jpg" alt="" title="15.webp.jpg"></p>
<p>Step 5：于乳突上嵴后部钻孔一个，即打开中颅窝。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153714_vhgh0mty4x.jpg" alt="" title="16.webp.jpg"></p>
<p>Step 6：适当扩大骨孔，铣刀先自后向前、与颧弓平行铣开颅骨。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153754_isct1fvbro.jpg" alt="" title="17.webp.jpg"></p>
<p>Step 7：再从骨孔处“C”型游离骨瓣，宽约25mm、高约25mm。这里要注意，骨瓣高度必须保证2.5cm，方可良好显露内听道。此操作要注意避免损伤硬脑膜。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153811_y8wujqr7e8.jpg" alt="" title="18.webp.jpg"></p>
<p>Step 8：如术前未放置腰大池引流，那么就需在硬脑膜上切一小口，打开脑皮层表面的蛛网膜下腔，释放脑脊液。如此，可最大程度的降低颞叶牵拉的力度。去除骨瓣后，小磨钻磨除骨窗下缘的内板（此部操作应注意保护好硬脑膜），这样可增加手术视角和操作自由度。如乳突气房开放，应严密封堵。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153827_wus7wl694d.jpg" alt="" title="19.webp.jpg"></p>
<p>Step 9：仔细剥离颅底硬脑膜，并牵开，显露中颅窝底。</p>
<p><strong>4. 硬膜外-硬膜下操作</strong></p>
<p><strong><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153856_okbip6rlck.jpg" alt="" title="20.webp.jpg"></strong></p>
<p>Step 1：左侧。新鲜尸体标本。牵开硬脑膜后，显露岩浅大神经（GSPN）。仔细游离GSPN，于其前缘可见MMA及棘孔。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153915_12362rxmg1.jpg" alt="" title="21.webp.jpg"></p>
<p>Step 2：进一步牵开硬脑膜，显露岩骨嵴和弓状隆起。用小磨钻部分磨除覆盖上半规管的薄层骨质，目的是为了精准定位。上半规管蓝线（结合岩大神经）可精确的界定内听道的走行。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153934_h51607svob.jpg" alt="" title="22.webp.jpg"></p>
<p>Step 3：根据上述的解剖定位，小磨钻打开IAC。注意：蓝线、GSPN和磨钻方向之间的相互关系。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154000_g70xwiujfj.jpg" alt="" title="23.webp.jpg"></p>
<p>Step 4：显露IAC硬脑膜和后颅窝，显微椎板咬骨钳去除深部骨质。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154017_lbf0kr8be6.jpg" alt="" title="24.webp.jpg"></p>
<p>Step 5：打开硬脑膜即可见前庭上神经和面神经。注意观察AICA的环襻，背景亦可见脑干，颞下入路最大的优势就在于——可清楚的显露IAC及其内容物。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154035_hwsb2jh08x.jpg" alt="" title="25.webp.jpg"></p>
<p>Step 6：向前进一步磨除岩尖，即可显露脑干的外侧面。注意观察：外展神经穿行于Dorello管。特别需要注意的是：勿损伤耳蜗。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154054_r11m64blxo.jpg" alt="" title="26.webp.jpg"></p>
<p>Step 7：打开颞下硬脑膜，切开小脑幕，显露环池结构。注意观察：Dandy岩静脉，用显微剪刀分离滑车神经周围的蛛网膜。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154114_ybrllmhjfx.jpg" alt="" title="27.webp.jpg"></p>
<p>Step 8：继续向前分离，进入桥脑的腹外侧面。注意观察：滑车、三叉神经以及BA。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154139_cl5aid7yp6.jpg" alt="" title="28.webp.jpg"></p>
<p>Step 9：切除Dandy岩静脉后，可充分显露动眼、滑车和三叉神经。注意观察：BA主干以及SCA双干。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154157_a77ntvhir6.jpg" alt="" title="29.webp.jpg"></p>
<p>Step 10：观察BA顶端的SCA及P1段、动眼和滑车神经。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154216_b7btk5m4gt.jpg" alt="" title="30.webp.jpg"></p>
<p>Step 11：切除岩尖、分开小脑幕后，显露桥脑前外侧面。充分显露BA主干、从AICA到SCA、动眼神经、滑车神经、三叉神经以及外展神经。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154235_uf5cgvtk1r.jpg" alt="" title="31.webp.jpg"></p>
<p>Step 12：再向后方探查，观察三叉、外展和面听神经之间的关系。</p>
<p><strong>5. 关颅</strong></p>
<p>完成颅内操作后，硬膜下生理盐水冲洗。此处硬脑膜水密缝合几乎不可能，但也需仔细缝合，有助于后颅窝硬脑膜重建。颞肌及筋膜的严密缝合可有效的避免术后脑脊液漏，并可封堵内听道骨缺损。部分病例还可于硬膜外使用腹部脂肪修补。钛片固定骨瓣。彻底止血后，间断缝合颞肌、筋膜，皮内连续缝合头皮。因切口较小，不必也不推荐放置引流管，以避免术后脑脊液漏。</p>
<p><strong>手术风险</strong></p>
<ul>
<li>
<p>术前计划不详细、手术体位摆放不合适均可影响术野的显露。</p>
</li>
<li>
<p>耳前神经血管损伤。</p>
</li>
<li>
<p>当乳突气房开放无法避免时，应严密封堵，以避免术后脑脊液鼻漏和脑膜炎。</p>
</li>
<li>
<p>开颅时损伤硬脑膜，尤其是老年人。这并不一定会造成严重后果，但有时会使硬膜外操作变得复杂。在完成颅内操作后，应间断或连续缝合硬脑膜。</p>
</li>
<li>
<p>脑压板牵拉颞叶可造成脑组织损伤。合适的手术体位，早期释放脑脊液（可通过打开皮层蛛网膜下腔或术前放置腰大池引流）可有效地避免此并发症。</p>
</li>
<li>
<p>硬膜外牵拉时可损伤岩浅大神经和岩浅小神经，通常不会产生严重神经功能障碍。</p>
</li>
<li>
<p>上半规管损伤可造成前庭功能障碍，出现暂时性恶心、呕吐。耳蜗损伤可造成术后同侧耳聋。</p>
</li>
<li>
<p>IAC内面神经损伤可导致术后面瘫。</p>
</li>
<li>
<p>中后颅窝神经血管损伤可造成术后相应神经功能障碍。</p>
</li>
<li>
<p>颅内止血不彻底可造成术后颅内血肿。</p>
</li>
<li>
<p>硬脑膜缝合不严密可造成术后脑脊液漏。乳突气房开放，术后可出现脑脊液鼻漏。</p>
</li>
<li>
<p>软组织止血不彻底可造成术后软组织血肿。</p>
</li>
</ul>
<p><strong>手术技巧</strong></p>
<ul>
<li>术前花时间做好计划、设计好手术体位。</li>
</ul>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154345_9eyda2as69.jpg" alt="" title="32.webp.jpg"></p>
<ul>
<li>头部旋转80°可良好显露IAC。</li>
</ul>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154415_fwwt12oct2.jpg" alt="" title="33.webp.jpg"></p>
<ul>
<li>
<p>与颞下前、颞下后入路对比，这种硬膜外入路需要侧屈的角度更小、抬高的角度更大。</p>
</li>
<li>
<p>开刀前需搞清楚以下内容：手术入路相关骨结构和神经血管结构；骨窗位置；皮肤切口。</p>
</li>
<li>
<p>耳前直切口，注意保护好颞浅动脉和耳颞神经。</p>
</li>
</ul>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154443_fa8t7bcan5.jpg" alt="" title="34.webp.jpg"></p>
<ul>
<li>“Y”型切开颞肌筋膜，如图所示牵开固定。其中，基底筋膜瓣（颧弓侧）还可用于硬膜修补。</li>
</ul>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154506_lh9hifh1r9.jpg" alt="" title="35.webp.jpg"></p>
<ul>
<li>绝大多数情况下，颞肌的剥离都可使用钝性剥离子完成，不需切开颞肌。</li>
</ul>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154534_a424s0l34i.jpg" alt="" title="36.webp.jpg"></p>
<ul>
<li>游离骨瓣步骤：1. 颅骨钻孔；2. 平行于乳突上嵴和颧弓铣开颞底颅骨；3. 半弧形游离骨瓣。</li>
</ul>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154555_2xc5m2tqc0.jpg" alt="" title="37.webp.jpg"></p>
<ul>
<li>骨窗高度至少2.5cm（从颧弓处测量），这样方可获得内听道的充分显露。</li>
</ul>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154623_hsxdy2nknl.jpg" alt="" title="38.webp.jpg"></p>
<ul>
<li>磨除骨窗颞底的内板，此步骤重要性在于增大手术视角和操作自由度。</li>
</ul>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154652_sx9njlqqvm.jpg" alt="" title="39.webp.jpg"></p>
<ul>
<li>如乳突气房开放不可避免，需仔细封堵。封堵材料可用骨蜡、筋膜瓣或颞肌。</li>
</ul>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154724_b5ndihay51.jpg" alt="" title="40.webp.jpg"></p>
<ul>
<li>为尽可能降低颞叶的牵拉力度，可在硬脑膜上切开一小口，打开皮层蛛网膜下腔。也可在术前放置腰大池引流。</li>
</ul>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154759_t16robdqgw.jpg" alt="" title="41.webp.jpg"></p>
<ul>
<li>
<p>使用“蓝线”技术，精确定位内听道走行。</p>
</li>
<li>
<p>可通过“打开颞下硬脑膜、切开小脑幕”，拓展IAC的硬膜外入路。磨除岩尖可进一步可扩大中后颅窝的显露。</p>
</li>
<li>
<p>硬脑膜尽可能水密缝合。或可使用肌肉瓣、腹部脂肪组织进行后颅窝硬脑膜的修补。</p>
</li>
<li>
<p>如术后发生脑脊液鼻漏，可放置腰大池引流。</p>
</li>
</ul>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154826_y1t083ruen.jpg" alt="" title="42.webp.jpg"></p>
<ul>
<li>
<p>骨孔处用钛片固定、封堵。</p>
</li>
<li>
<p>为避免术后脑脊液漏，不推荐放置引流管。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从一个py中运行另一个带参数的py]]></title>
        <id>https://blog.bioprinting.site/post/6F7PaKHq4</id>
        <link href="https://blog.bioprinting.site/post/6F7PaKHq4">
        </link>
        <updated>2019-07-08T12:15:16.000Z</updated>
        <content type="html"><![CDATA[<pre><code>import sys
import argparse
import getpass

def main(args):
    if args['username'] is None:
        print 'No user name specified. Login to WebCTRL needs a user name and password. Check all options for this command via -h'
        sys.exit(1)
    else:
        username = args['username']
    if args['password'] is None:
        password = getpass.getpass('No password specified via -p. Please enter your WebCTRL login password: ')
    else:
        password = args['password']
    if args['node'] is None:
        print 'No path to a node specified. Check all options for this command via -h'
        sys.exit(1)
    if args['url'] is None:
        print 'No URL given. Specify the URL to the WebCTRL server analogous to http://google.de'
        sys.exit(1)
    else:
        wsdlFile = args['url'] + '/_common/webservices/Eval?wsdl'

    # This doesn't belong to my original code. It's rather for demonstration:
    # Print the arguments and leave the script
    print 'Username: ' + args['username']
    print 'Node: ' + args['node']
    print 'URL: ' + args['url']


# The parser is only called if this script is called as a script/executable (via command line) but not when imported by another script
if __name__=='__main__':
    if len(sys.argv) &lt; 2:
        print &quot;You haven't specified any arguments. Use -h to get more details on how to use this command.&quot;
        sys.exit(1)
    parser = argparse.ArgumentParser()
    parser.add_argument('--username', '-u', type=str, default=None, help='Username for the login to the WebCTRL server')
    parser.add_argument('--password', '-p', type=str, default=None, help='Password for the login to the WebCTRL server')
    parser.add_argument('--node', '-n', type=str, default=None,
        help='Path to the point or node whose children you want to retrieve. Start querying at the lowest level with &quot;-n /trees/geographic&quot;')
    parser.add_argument('-url', type=str, default='https://webctrl.rz-berlin.mpg.de',
        help=&quot;URL of the WebCTRL server as e.g. http://google.de&quot;)
    args = parser.parse_args()

    # Convert the argparse.Namespace to a dictionary: vars(args)
    main(vars(args))
    sys.exit(0)
</code></pre>
<p>现在，有三种执行wc_query_test的方法，这就是我想要实现的目标：</p>
<p>1）从命令行调用wc_query_test.py：</p>
<p><code>~/PycharmProjects/webctrl$ python wc_query_test.py -u aawrg -p wgAWER -n YWERGAEWR</code></p>
<p>2）从命令行编译和调用wc_query_test：</p>
<p><code>~/PycharmProjects/webctrl$ pyinstaller --distpath dist/. wc_query_test.py
~/PycharmProjects/webctrl$ ./dist/wc_query_test/wc_query_test -u aawrg -p wgAWER -n YWERGAEWR</code></p>
<p>3）从另一个python脚本调用wc_query_test，该脚本进入模块类型用法的方向：</p>
<p><code>import wc_query_test
myDictonary = {'username':'wsdl', 'password':'aaaaaa', 'node':'/trees/geographic', 'url':'https://my.server.de'}
wc_query_test.main(myDictonary)</code></p>
<p>所有三个版本都会产生与预期相同的输出，例如：</p>
<p><code>~/PycharmProjects/webctrl$ ./dist/wc_query_test/wc_query_test -u aawrg -p wgAWER -n YWERGAEWR
Username: aawrg
Node: YWERGAEWR
URL: https://webctrl.rz-berlin.mpg.de</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[numpy_stl简介]]></title>
        <id>https://blog.bioprinting.site/post/5OyTRhe_F</id>
        <link href="https://blog.bioprinting.site/post/5OyTRhe_F">
        </link>
        <updated>2019-06-28T09:49:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="欢迎来到numpy-stl的文档">欢迎来到numpy-stl的文档！</h1>
<p>内容：</p>
<ul>
<li><a href="https://pythonhosted.org/numpy-stl/usage.html">numpy的-STL</a>
<ul>
<li><a href="https://pythonhosted.org/numpy-stl/usage.html#links">链接</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/usage.html#requirements-for-installing">安装要求：</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/usage.html#installation">安装：</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/usage.html#initial-usage">初次使用：</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/usage.html#contributing">贡献：</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/usage.html#quickstart">快速开始</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/usage.html#modifying-mesh-objects">修改Mesh对象</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/usage.html#extending-mesh-objects">扩展Mesh对象</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/usage.html#creating-mesh-objects-from-a-list-of-vertices-and-faces">从顶点和面的列表创建网格对象</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/usage.html#evaluating-mesh-properties-volume-center-of-gravity-inertia">评估网格属性（体积，重心，惯性）</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/usage.html#combining-multiple-stl-files">组合多个STL文件</a></li>
</ul>
</li>
<li><a href="https://pythonhosted.org/numpy-stl/tests.html">测试和例子</a>
<ul>
<li><a href="https://pythonhosted.org/numpy-stl/tests.html#tests-stl-corruption-module">tests.stl_corruption模块</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/tests.html#tests-test-commandline-module">tests.test_commandline模块</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/tests.html#tests-test-convert-module">tests.test_convert模块</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/tests.html#tests-test-mesh-module">tests.test_mesh模块</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/tests.html#tests-test-multiple-module">tests.test_multiple模块</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/tests.html#tests-test-rotate-module">tests.test_rotate模块</a></li>
</ul>
</li>
<li><a href="https://pythonhosted.org/numpy-stl/stl.html">stl包</a>
<ul>
<li><a href="https://pythonhosted.org/numpy-stl/stl.html#stl-mesh">stl.Mesh</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/stl.html#module-stl.main">stl.main模块</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/stl.html#module-stl.base">stl.base模块</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/stl.html#module-stl.mesh">stl.mesh模块</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/stl.html#module-stl.stl">stl.stl模块</a></li>
</ul>
</li>
</ul>
<h1 id="指数和表">指数和表<a href="https://pythonhosted.org/numpy-stl/index.html#indices-and-tables" title="永久链接到这个标题">¶</a></h1>
<ul>
<li>
<p><a href="https://pythonhosted.org/numpy-stl/genindex.html">指数</a></p>
</li>
<li>
<p><a href="https://pythonhosted.org/numpy-stl/py-modindex.html">模块索引</a></p>
</li>
<li>
<p><a href="https://pythonhosted.org/numpy-stl/search.html">搜索页面</a></p>
</li>
<li>
<h1 id="numpy的-stl">numpy的-STL</h1>
<p>简单的库可以快速轻松地处理STL文件（以及一般的3D对象）。</p>
<p>由于所有操作都严重依赖于<cite>numpy，</cite>因此这是Python中最快的STL编辑库之一。</p>
<h2 id="链接">链接</h2>
<blockquote>
<ul>
<li>来源：<a href="https://github.com/WoLpH/numpy-stl">https</a>：<a href="https://github.com/WoLpH/numpy-stl">//github.com/WoLpH/numpy-stl</a></li>
<li>项目页面：<a href="https://pypi.python.org/pypi/numpy-stl">https</a>：<a href="https://pypi.python.org/pypi/numpy-stl">//pypi.python.org/pypi/numpy-stl</a></li>
<li>报告错误：<a href="https://github.com/WoLpH/numpy-stl/issues">https</a>：<a href="https://github.com/WoLpH/numpy-stl/issues">//github.com/WoLpH/numpy-stl/issues</a></li>
<li>文档：<a href="http://numpy-stl.readthedocs.org/en/latest/">http</a>：<a href="http://numpy-stl.readthedocs.org/en/latest/">//numpy-stl.readthedocs.org/en/latest/</a></li>
<li>我的博客：<a href="https://wol.ph/">https</a>：<a href="https://wol.ph/">//wol.ph/</a></li>
</ul>
</blockquote>
<h2 id="安装要求">安装要求：</h2>
<blockquote>
<ul>
<li><a href="http://numpy.org/">numpy</a>任何最新版本</li>
<li><a href="https://github.com/WoLpH/python-utils">python-utils</a> 1.6或更高版本</li>
</ul>
</blockquote>
<h2 id="安装">安装：</h2>
<p><cite>pip install numpy-stl</cite></p>
<h2 id="初次使用">初次使用：</h2>
<blockquote>
<ul>
<li><cite>stl2bin your_ascii_stl_file.stl new_binary_stl_file.stl</cite></li>
<li><cite>stl2ascii your_binary_stl_file.stl new_ascii_stl_file.stl</cite></li>
<li><cite>stl your_ascii_stl_file.stl new_binary_stl_file.stl</cite></li>
</ul>
</blockquote>
<h2 id="贡献">贡献：</h2>
<p>我们随时欢迎您的贡献。请查看入门指南：<a href="https://github.com/WoLpH/numpy-stl/blob/develop/CONTRIBUTING.rst">https</a>： <a href="https://github.com/WoLpH/numpy-stl/blob/develop/CONTRIBUTING.rst">//github.com/WoLpH/numpy-stl/blob/develop/CONTRIBUTING.rst</a></p>
<h2 id="快速入门">快速入门</h2>
</li>
<li>
<p>Quickstart
import numpy
from stl import mesh</p>
</li>
</ul>
<h1 id="using-an-existing-stl-file">Using an existing stl file:</h1>
<p>your_mesh = mesh.Mesh.from_file('some_file.stl')</p>
<h1 id="or-creating-a-new-mesh-make-sure-not-to-overwrite-the-mesh-import-by">Or creating a new mesh (make sure not to overwrite the <code>mesh</code> import by</h1>
<h1 id="naming-it-mesh">naming it <code>mesh</code>):</h1>
<p>VERTICE_COUNT = 100
data = numpy.zeros(VERTICE_COUNT, dtype=mesh.Mesh.dtype)
your_mesh = mesh.Mesh(data, remove_empty_areas=False)</p>
<h1 id="the-mesh-normals-calculated-automatically">The mesh normals (calculated automatically)</h1>
<p>your_mesh.normals</p>
<h1 id="the-mesh-vectors">The mesh vectors</h1>
<p>your_mesh.v0, your_mesh.v1, your_mesh.v2</p>
<h1 id="accessing-individual-points-concatenation-of-v0-v1-and-v2-in-triplets">Accessing individual points (concatenation of v0, v1 and v2 in triplets)</h1>
<p>assert (your_mesh.points[0][0:3] == your_mesh.v0[0]).all()
assert (your_mesh.points[0][3:6] == your_mesh.v1[0]).all()
assert (your_mesh.points[0][6:9] == your_mesh.v2[0]).all()
assert (your_mesh.points[1][0:3] == your_mesh.v0[1]).all()</p>
<p>your_mesh.save('new_stl_file.stl')
Plotting using matplotlib is equally easy:</p>
<p>from stl import mesh
from mpl_toolkits import mplot3d
from matplotlib import pyplot</p>
<h1 id="create-a-new-plot">Create a new plot</h1>
<p>figure = pyplot.figure()
axes = mplot3d.Axes3D(figure)</p>
<h1 id="load-the-stl-files-and-add-the-vectors-to-the-plot">Load the STL files and add the vectors to the plot</h1>
<p>your_mesh = mesh.Mesh.from_file('tests/stl_binary/HalfDonut.stl')
axes.add_collection3d(mplot3d.art3d.Poly3DCollection(your_mesh.vectors))</p>
<h1 id="auto-scale-to-the-mesh-size">Auto scale to the mesh size</h1>
<p>scale = your_mesh.points.flatten(-1)
axes.auto_scale_xyz(scale, scale, scale)</p>
<h1 id="show-the-plot-to-the-screen">Show the plot to the screen</h1>
<p>pyplot.show()
Modifying Mesh objects
from stl import mesh
import math
import numpy</p>
<h1 id="create-3-faces-of-a-cube">Create 3 faces of a cube</h1>
<p>data = numpy.zeros(6, dtype=mesh.Mesh.dtype)</p>
<h1 id="top-of-the-cube">Top of the cube</h1>
<p>data['vectors'][0] = numpy.array([[0, 1, 1],
[1, 0, 1],
[0, 0, 1]])
data['vectors'][1] = numpy.array([[1, 0, 1],
[0, 1, 1],
[1, 1, 1]])</p>
<h1 id="right-face">Right face</h1>
<p>data['vectors'][2] = numpy.array([[1, 0, 0],
[1, 0, 1],
[1, 1, 0]])
data['vectors'][3] = numpy.array([[1, 1, 1],
[1, 0, 1],
[1, 1, 0]])</p>
<h1 id="left-face">Left face</h1>
<p>data['vectors'][4] = numpy.array([[0, 0, 0],
[1, 0, 0],
[1, 0, 1]])
data['vectors'][5] = numpy.array([[0, 0, 0],
[0, 0, 1],
[1, 0, 1]])</p>
<h1 id="since-the-cube-faces-are-from-0-to-1-we-can-move-it-to-the-middle-by">Since the cube faces are from 0 to 1 we can move it to the middle by</h1>
<h1 id="substracting-5">substracting .5</h1>
<p>data['vectors'] -= .5</p>
<h1 id="generate-4-different-meshes-so-we-can-rotate-them-later">Generate 4 different meshes so we can rotate them later</h1>
<p>meshes = [mesh.Mesh(data.copy()) for _ in range(4)]</p>
<h1 id="rotate-90-degrees-over-the-y-axis">Rotate 90 degrees over the Y axis</h1>
<p>meshes[0].rotate([0.0, 0.5, 0.0], math.radians(90))</p>
<h1 id="translate-2-points-over-the-x-axis">Translate 2 points over the X axis</h1>
<p>meshes[1].x += 2</p>
<h1 id="rotate-90-degrees-over-the-x-axis">Rotate 90 degrees over the X axis</h1>
<p>meshes[2].rotate([0.5, 0.0, 0.0], math.radians(90))</p>
<h1 id="translate-2-points-over-the-x-and-y-points">Translate 2 points over the X and Y points</h1>
<p>meshes[2].x += 2
meshes[2].y += 2</p>
<h1 id="rotate-90-degrees-over-the-x-and-y-axis">Rotate 90 degrees over the X and Y axis</h1>
<p>meshes[3].rotate([0.5, 0.0, 0.0], math.radians(90))
meshes[3].rotate([0.0, 0.5, 0.0], math.radians(90))</p>
<h1 id="translate-2-points-over-the-y-axis">Translate 2 points over the Y axis</h1>
<p>meshes[3].y += 2</p>
<h1 id="optionally-render-the-rotated-cube-faces">Optionally render the rotated cube faces</h1>
<p>from matplotlib import pyplot
from mpl_toolkits import mplot3d</p>
<h1 id="create-a-new-plot-2">Create a new plot</h1>
<p>figure = pyplot.figure()
axes = mplot3d.Axes3D(figure)</p>
<h1 id="render-the-cube-faces">Render the cube faces</h1>
<p>for m in meshes:
axes.add_collection3d(mplot3d.art3d.Poly3DCollection(m.vectors))</p>
<h1 id="auto-scale-to-the-mesh-size-2">Auto scale to the mesh size</h1>
<p>scale = numpy.concatenate([m.points for m in meshes]).flatten(-1)
axes.auto_scale_xyz(scale, scale, scale)</p>
<h1 id="show-the-plot-to-the-screen-2">Show the plot to the screen</h1>
<p>pyplot.show()
Extending Mesh objects
from stl import mesh
import math
import numpy</p>
<h1 id="create-3-faces-of-a-cube-2">Create 3 faces of a cube</h1>
<p>data = numpy.zeros(6, dtype=mesh.Mesh.dtype)</p>
<h1 id="top-of-the-cube-2">Top of the cube</h1>
<p>data['vectors'][0] = numpy.array([[0, 1, 1],
[1, 0, 1],
[0, 0, 1]])
data['vectors'][1] = numpy.array([[1, 0, 1],
[0, 1, 1],
[1, 1, 1]])</p>
<h1 id="right-face-2">Right face</h1>
<p>data['vectors'][2] = numpy.array([[1, 0, 0],
[1, 0, 1],
[1, 1, 0]])
data['vectors'][3] = numpy.array([[1, 1, 1],
[1, 0, 1],
[1, 1, 0]])</p>
<h1 id="left-face-2">Left face</h1>
<p>data['vectors'][4] = numpy.array([[0, 0, 0],
[1, 0, 0],
[1, 0, 1]])
data['vectors'][5] = numpy.array([[0, 0, 0],
[0, 0, 1],
[1, 0, 1]])</p>
<h1 id="since-the-cube-faces-are-from-0-to-1-we-can-move-it-to-the-middle-by-2">Since the cube faces are from 0 to 1 we can move it to the middle by</h1>
<h1 id="substracting-5-2">substracting .5</h1>
<p>data['vectors'] -= .5</p>
<p>cube_back = mesh.Mesh(data.copy())
cube_front = mesh.Mesh(data.copy())</p>
<h1 id="rotate-90-degrees-over-the-x-axis-followed-by-the-y-axis-followed-by-the">Rotate 90 degrees over the X axis followed by the Y axis followed by the</h1>
<h1 id="x-axis">X axis</h1>
<p>cube_back.rotate([0.5, 0.0, 0.0], math.radians(90))
cube_back.rotate([0.0, 0.5, 0.0], math.radians(90))
cube_back.rotate([0.5, 0.0, 0.0], math.radians(90))</p>
<p>cube = mesh.Mesh(numpy.concatenate([
cube_back.data.copy(),
cube_front.data.copy(),
]))</p>
<h1 id="optionally-render-the-rotated-cube-faces-2">Optionally render the rotated cube faces</h1>
<p>from matplotlib import pyplot
from mpl_toolkits import mplot3d</p>
<h1 id="create-a-new-plot-3">Create a new plot</h1>
<p>figure = pyplot.figure()
axes = mplot3d.Axes3D(figure)</p>
<h1 id="render-the-cube">Render the cube</h1>
<p>axes.add_collection3d(mplot3d.art3d.Poly3DCollection(cube.vectors))</p>
<h1 id="auto-scale-to-the-mesh-size-3">Auto scale to the mesh size</h1>
<p>scale = cube_back.points.flatten(-1)
axes.auto_scale_xyz(scale, scale, scale)</p>
<h1 id="show-the-plot-to-the-screen-3">Show the plot to the screen</h1>
<p>pyplot.show()
Creating Mesh objects from a list of vertices and faces
import numpy as np
from stl import mesh</p>
<h1 id="define-the-8-vertices-of-the-cube">Define the 8 vertices of the cube</h1>
<p>vertices = np.array([<br>
[-1, -1, -1],
[+1, -1, -1],
[+1, +1, -1],
[-1, +1, -1],
[-1, -1, +1],
[+1, -1, +1],
[+1, +1, +1],
[-1, +1, +1]])</p>
<h1 id="define-the-12-triangles-composing-the-cube">Define the 12 triangles composing the cube</h1>
<p>faces = np.array([<br>
[0,3,1],
[1,3,2],
[0,4,7],
[0,7,3],
[4,5,6],
[4,6,7],
[5,1,2],
[5,2,6],
[2,3,6],
[3,7,6],
[0,1,5],
[0,5,4]])</p>
<h1 id="create-the-mesh">Create the mesh</h1>
<p>cube = mesh.Mesh(np.zeros(faces.shape[0], dtype=mesh.Mesh.dtype))
for i, f in enumerate(faces):
for j in range(3):
cube.vectors[i][j] = vertices[f[j],:]</p>
<h1 id="write-the-mesh-to-file-cubestl">Write the mesh to file &quot;cube.stl&quot;</h1>
<p>cube.save('cube.stl')
Evaluating Mesh properties (Volume, Center of gravity, Inertia)
import numpy as np
from stl import mesh</p>
<h1 id="using-an-existing-closed-stl-file">Using an existing closed stl file:</h1>
<p>your_mesh = mesh.Mesh.from_file('some_file.stl')</p>
<p>volume, cog, inertia = your_mesh.get_mass_properties()
print(&quot;Volume                                  = {0}&quot;.format(volume))
print(&quot;Position of the center of gravity (COG) = {0}&quot;.format(cog))
print(&quot;Inertia matrix at expressed at the COG  = {0}&quot;.format(inertia[0,:]))
print(&quot;                                          {0}&quot;.format(inertia[1,:]))
print(&quot;                                          {0}&quot;.format(inertia[2,:]))
Combining multiple STL files
import math
import stl
from stl import mesh
import numpy</p>
<h1 id="find-the-max-dimensions-so-we-can-know-the-bounding-box-getting-the-height">find the max dimensions, so we can know the bounding box, getting the height,</h1>
<h1 id="width-length-because-these-are-the-step-size">width, length (because these are the step size)...</h1>
<p>def find_mins_maxs(obj):
minx = maxx = miny = maxy = minz = maxz = None
for p in obj.points:
# p contains (x, y, z)
if minx is None:
minx = p[stl.Dimension.X]
maxx = p[stl.Dimension.X]
miny = p[stl.Dimension.Y]
maxy = p[stl.Dimension.Y]
minz = p[stl.Dimension.Z]
maxz = p[stl.Dimension.Z]
else:
maxx = max(p[stl.Dimension.X], maxx)
minx = min(p[stl.Dimension.X], minx)
maxy = max(p[stl.Dimension.Y], maxy)
miny = min(p[stl.Dimension.Y], miny)
maxz = max(p[stl.Dimension.Z], maxz)
minz = min(p[stl.Dimension.Z], minz)
return minx, maxx, miny, maxy, minz, maxz</p>
<p>def translate(_solid, step, padding, multiplier, axis):
if axis == 'x':
items = [0, 3, 6]
elif axis == 'y':
items = [1, 4, 7]
elif axis == 'z':
items = [2, 5, 8]
for p in _solid.points:
# point items are ((x, y, z), (x, y, z), (x, y, z))
for i in range(3):
p[items[i]] += (step * multiplier) + (padding * multiplier)</p>
<p>def copy_obj(obj, dims, num_rows, num_cols, num_layers):
w, l, h = dims
copies = []
for layer in range(num_layers):
for row in range(num_rows):
for col in range(num_cols):
# skip the position where original being copied is
if row == 0 and col == 0 and layer == 0:
continue
_copy = mesh.Mesh(obj.data.copy())
# pad the space between objects by 10% of the dimension being
# translated
if col != 0:
translate(_copy, w, w / 10., col, 'x')
if row != 0:
translate(_copy, l, l / 10., row, 'y')
if layer != 0:
translate(_copy, h, h / 10., layer, 'z')
copies.append(_copy)
return copies</p>
<h1 id="using-an-existing-stl-file-2">Using an existing stl file:</h1>
<p>main_body = mesh.Mesh.from_file('ball_and_socket_simplified_-_main_body.stl')</p>
<h1 id="rotate-along-y">rotate along Y</h1>
<p>main_body.rotate([0.0, 0.5, 0.0], math.radians(90))</p>
<p>minx, maxx, miny, maxy, minz, maxz = find_mins_maxs(main_body)
w1 = maxx - minx
l1 = maxy - miny
h1 = maxz - minz
copies = copy_obj(main_body, (w1, l1, h1), 2, 2, 1)</p>
<h1 id="i-wanted-to-add-another-related-stl-to-the-final-stl">I wanted to add another related STL to the final STL</h1>
<p>twist_lock = mesh.Mesh.from_file('ball_and_socket_simplified_-_twist_lock.stl')
minx, maxx, miny, maxy, minz, maxz = find_mins_maxs(twist_lock)
w2 = maxx - minx
l2 = maxy - miny
h2 = maxz - minz
translate(twist_lock, w1, w1 / 10., 3, 'x')
copies2 = copy_obj(twist_lock, (w2, l2, h2), 2, 2, 1)
combined = mesh.Mesh(numpy.concatenate([main_body.data, twist_lock.data] +
[copy.data for copy in copies] +
[copy.data for copy in copies2]))</p>
<p>combined.save('combined.stl', mode=stl.Mode.ASCII)  # save as ASCII</p>
<ul>
<li>
<h2 id="testsstl_corruption-module">tests.stl_corruption module</h2>
<p>from <strong>future</strong> import print_function
import pytest
import struct</p>
<p>from stl import mesh</p>
<p>_STL_FILE = '''
solid test.stl
facet normal -0.014565 0.073223 -0.002897
outer loop
vertex 0.399344 0.461940 1.044090
vertex 0.500000 0.500000 1.500000
vertex 0.576120 0.500000 1.117320
endloop
endfacet
endsolid test.stl
'''.lstrip()</p>
<p>def test_valid_ascii(tmpdir, speedups):
tmp_file = tmpdir.join('tmp.stl')
with tmp_file.open('w+') as fh:
fh.write(_STL_FILE)
fh.seek(0)
mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)</p>
<p>def test_ascii_with_missing_name(tmpdir, speedups):
tmp_file = tmpdir.join('tmp.stl')
with tmp_file.open('w+') as fh:
# Split the file into lines
lines = _STL_FILE.splitlines()</p>
<pre><code>    # Remove everything except solid
    lines[0] = lines[0].split()[0]

    # Join the lines to test files that start with solid without space
    fh.write('\n'.join(lines))
    fh.seek(0)
    mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)
</code></pre>
<p>def test_ascii_with_blank_lines(tmpdir, speedups):
_stl_file = '''
solid test.stl</p>
<p>facet normal -0.014565 0.073223 -0.002897</p>
<p>outer loop</p>
<p>vertex 0.399344 0.461940 1.044090
vertex 0.500000 0.500000 1.500000</p>
<p>vertex 0.576120 0.500000 1.117320</p>
<p>endloop</p>
<p>endfacet</p>
<p>endsolid test.stl
'''.lstrip()</p>
<pre><code>tmp_file = tmpdir.join('tmp.stl')
with tmp_file.open('w+') as fh:
    fh.write(_stl_file)
    fh.seek(0)
    mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)
</code></pre>
<p>def test_incomplete_ascii_file(tmpdir, speedups):
tmp_file = tmpdir.join('tmp.stl')
with tmp_file.open('w+') as fh:
fh.write('solid some_file.stl')
fh.seek(0)
with pytest.raises(AssertionError):
mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)</p>
<pre><code>for offset in (-20, 82, 100):
    with tmp_file.open('w+') as fh:
        fh.write(_STL_FILE[:-offset])
        fh.seek(0)
        with pytest.raises(AssertionError):
            mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)
</code></pre>
<p>def test_corrupt_ascii_file(tmpdir, speedups):
tmp_file = tmpdir.join('tmp.stl')
with tmp_file.open('w+') as fh:
fh.write(_STL_FILE)
fh.seek(40)
print('####\n' * 100, file=fh)
fh.seek(0)
with pytest.raises(AssertionError):
mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)</p>
<pre><code>with tmp_file.open('w+') as fh:
    fh.write(_STL_FILE)
    fh.seek(40)
    print(' ' * 100, file=fh)
    fh.seek(80)
    fh.write(struct.pack('&lt;i', 10).decode('utf-8'))
    fh.seek(0)
    with pytest.raises(AssertionError):
        mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)
</code></pre>
<p>def test_corrupt_binary_file(tmpdir, speedups):
tmp_file = tmpdir.join('tmp.stl')
with tmp_file.open('w+') as fh:
fh.write('#########\n' * 8)
fh.write('#\0\0\0')
fh.seek(0)
mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)</p>
<pre><code>with tmp_file.open('w+') as fh:
    fh.write('#########\n' * 9)
    fh.seek(0)
    with pytest.raises(AssertionError):
        mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)

with tmp_file.open('w+') as fh:
    fh.write('#########\n' * 8)
    fh.write('#\0\0\0')
    fh.seek(0)
    fh.write('solid test.stl')
    fh.seek(0)
    mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)
</code></pre>
<h2 id="teststest_commandline-module">tests.test_commandline module</h2>
<p>import sys</p>
<p>from stl import main</p>
<p>def test_main(ascii_file, binary_file, tmpdir, speedups):
original_argv = sys.argv[:]
args_pre = ['stl']
args_post = [str(tmpdir.join('output.stl'))]</p>
<pre><code>if not speedups:
    args_pre.append('-s')

try:
    sys.argv[:] = args_pre + [ascii_file] + args_post
    main.main()
    sys.argv[:] = args_pre + ['-r', ascii_file] + args_post
    main.main()
    sys.argv[:] = args_pre + ['-a', binary_file] + args_post
    main.main()
    sys.argv[:] = args_pre + ['-b', ascii_file] + args_post
    main.main()
finally:
    sys.argv[:] = original_argv
</code></pre>
<p>def test_args(ascii_file, tmpdir):
parser = main._get_parser('')</p>
<pre><code>def _get_name(*args):
    return main._get_name(parser.parse_args(list(map(str, args))))

assert _get_name('--name', 'foobar') == 'foobar'
assert _get_name('-', tmpdir.join('binary.stl')).endswith('binary.stl')
assert _get_name(ascii_file, '-').endswith('HalfDonut.stl')
assert _get_name('-', '-')
</code></pre>
<p>def test_ascii(binary_file, tmpdir, speedups):
original_argv = sys.argv[:]
try:
sys.argv[:] = [
'stl',
'-s' if not speedups else '',
binary_file,
str(tmpdir.join('ascii.stl')),
]
try:
main.to_ascii()
except SystemExit:
pass
finally:
sys.argv[:] = original_argv</p>
<p>def test_binary(ascii_file, tmpdir, speedups):
original_argv = sys.argv[:]
try:
sys.argv[:] = [
'stl',
'-s' if not speedups else '',
ascii_file,
str(tmpdir.join('binary.stl')),
]
try:
main.to_binary()
except SystemExit:
pass
finally:
sys.argv[:] = original_argv</p>
<h2 id="teststest_convert-module">tests.test_convert module</h2>
<h1 id="import-os">import os</h1>
<p>import pytest
import tempfile</p>
<p>from stl import stl</p>
<p>def <em>test_conversion(from</em>, to, mode, speedups):</p>
<pre><code>for name in from_.listdir():
    source_file = from_.join(name)
    expected_file = to.join(name)
    if not expected_file.exists():
        continue

    mesh = stl.StlMesh(source_file, speedups=speedups)
    with open(str(expected_file), 'rb') as expected_fh:
        expected = expected_fh.read()
        # For binary files, skip the header
        if mode is stl.BINARY:
            expected = expected[80:]

        with tempfile.TemporaryFile() as dest_fh:
            mesh.save(name, dest_fh, mode)
            # Go back to the beginning to read
            dest_fh.seek(0)
            dest = dest_fh.read()
            # For binary files, skip the header
            if mode is stl.BINARY:
                dest = dest[80:]

            assert dest.strip() == expected.strip()
</code></pre>
<p>def test_ascii_to_binary(ascii_path, binary_path, speedups):
_test_conversion(ascii_path, binary_path, mode=stl.BINARY,
speedups=speedups)</p>
<p>def test_binary_to_ascii(ascii_path, binary_path, speedups):
_test_conversion(binary_path, ascii_path, mode=stl.ASCII,
speedups=speedups)</p>
<p>def test_stl_mesh(ascii_file, tmpdir, speedups):
tmp_file = tmpdir.join('tmp.stl')</p>
<pre><code>mesh = stl.StlMesh(ascii_file, speedups=speedups)
with pytest.raises(ValueError):
    mesh.save(filename=str(tmp_file), mode='test')

mesh.save(str(tmp_file))
mesh.save(str(tmp_file), update_normals=False)
</code></pre>
<h2 id="teststest_mesh-module">tests.test_mesh module</h2>
<p>import numpy</p>
<p>from stl.mesh import Mesh
from stl.base import BaseMesh
from stl.base import RemoveDuplicates</p>
<p>def test_units_1d():
data = numpy.zeros(1, dtype=Mesh.dtype)
data['vectors'][0] = numpy.array([[0, 0, 0],
[1, 0, 0],
[2, 0, 0]])</p>
<pre><code>mesh = Mesh(data, remove_empty_areas=False)
mesh.update_units()

assert mesh.areas == 0
assert (mesh.normals == [0, 0, 0]).all()
assert (mesh.units == [0, 0, 0]).all()
</code></pre>
<p>def test_units_2d():
data = numpy.zeros(2, dtype=Mesh.dtype)
data['vectors'][0] = numpy.array([[0, 0, 0],
[1, 0, 0],
[0, 1, 0]])
data['vectors'][1] = numpy.array([[1, 0, 0],
[0, 1, 0],
[1, 1, 0]])</p>
<pre><code>mesh = Mesh(data, remove_empty_areas=False)
mesh.update_units()

assert (mesh.areas == [.5, .5]).all()
assert (mesh.normals == [[0, 0, 1.],
                         [0, 0, -1.]]).all()

assert (mesh.units == [[0, 0, 1],
                       [0, 0, -1]]).all()
</code></pre>
<p>def test_units_3d():
data = numpy.zeros(1, dtype=Mesh.dtype)
data['vectors'][0] = numpy.array([[0, 0, 0],
[1, 0, 0],
[0, 1, 1.]])</p>
<pre><code>mesh = Mesh(data, remove_empty_areas=False)
mesh.update_units()

assert (mesh.areas - 2 ** .5) &lt; 0.0001
assert (mesh.normals == [0, -1, 1]).all()

units = mesh.units[0]
assert units[0] == 0
# Due to floating point errors
assert (units[1] + .5 * 2 ** .5) &lt; 0.0001
assert (units[2] - .5 * 2 ** .5) &lt; 0.0001
</code></pre>
<p>def test_duplicate_polygons():
data = numpy.zeros(6, dtype=Mesh.dtype)
data['vectors'][0] = numpy.array([[1, 0, 0],
[0, 0, 0],
[0, 0, 0]])
data['vectors'][1] = numpy.array([[2, 0, 0],
[0, 0, 0],
[0, 0, 0]])
data['vectors'][2] = numpy.array([[0, 0, 0],
[0, 0, 0],
[0, 0, 0]])
data['vectors'][3] = numpy.array([[2, 0, 0],
[0, 0, 0],
[0, 0, 0]])
data['vectors'][4] = numpy.array([[1, 0, 0],
[0, 0, 0],
[0, 0, 0]])
data['vectors'][5] = numpy.array([[0, 0, 0],
[0, 0, 0],
[0, 0, 0]])</p>
<pre><code>mesh = Mesh(data)
assert mesh.data.size == 6

mesh = Mesh(data, remove_duplicate_polygons=0)
assert mesh.data.size == 6

mesh = Mesh(data, remove_duplicate_polygons=False)
assert mesh.data.size == 6

mesh = Mesh(data, remove_duplicate_polygons=None)
assert mesh.data.size == 6

mesh = Mesh(data, remove_duplicate_polygons=RemoveDuplicates.NONE)
assert mesh.data.size == 6

mesh = Mesh(data, remove_duplicate_polygons=RemoveDuplicates.SINGLE)
assert mesh.data.size == 3

mesh = Mesh(data, remove_duplicate_polygons=True)
assert mesh.data.size == 3

assert (mesh.vectors[0] == numpy.array([[1, 0, 0],
                                        [0, 0, 0],
                                        [0, 0, 0]])).all()
assert (mesh.vectors[1] == numpy.array([[2, 0, 0],
                                        [0, 0, 0],
                                        [0, 0, 0]])).all()
assert (mesh.vectors[2] == numpy.array([[0, 0, 0],
                                        [0, 0, 0],
                                        [0, 0, 0]])).all()

mesh = Mesh(data, remove_duplicate_polygons=RemoveDuplicates.ALL)
assert mesh.data.size == 3

assert (mesh.vectors[0] == numpy.array([[1, 0, 0],
                                        [0, 0, 0],
                                        [0, 0, 0]])).all()
assert (mesh.vectors[1] == numpy.array([[2, 0, 0],
                                        [0, 0, 0],
                                        [0, 0, 0]])).all()
assert (mesh.vectors[2] == numpy.array([[0, 0, 0],
                                        [0, 0, 0],
                                        [0, 0, 0]])).all()
</code></pre>
<p>def test_remove_all_duplicate_polygons():
data = numpy.zeros(5, dtype=Mesh.dtype)
data['vectors'][0] = numpy.array([[0, 0, 0],
[0, 0, 0],
[0, 0, 0]])
data['vectors'][1] = numpy.array([[1, 0, 0],
[0, 0, 0],
[0, 0, 0]])
data['vectors'][2] = numpy.array([[2, 0, 0],
[0, 0, 0],
[0, 0, 0]])
data['vectors'][3] = numpy.array([[3, 0, 0],
[0, 0, 0],
[0, 0, 0]])
data['vectors'][4] = numpy.array([[3, 0, 0],
[0, 0, 0],
[0, 0, 0]])</p>
<pre><code>mesh = Mesh(data, remove_duplicate_polygons=False)
assert mesh.data.size == 5
Mesh.remove_duplicate_polygons(mesh.data, RemoveDuplicates.NONE)

mesh = Mesh(data, remove_duplicate_polygons=RemoveDuplicates.ALL)
assert mesh.data.size == 3

assert (mesh.vectors[0] == numpy.array([[0, 0, 0],
                                        [0, 0, 0],
                                        [0, 0, 0]])).all()
assert (mesh.vectors[1] == numpy.array([[1, 0, 0],
                                        [0, 0, 0],
                                        [0, 0, 0]])).all()
assert (mesh.vectors[2] == numpy.array([[2, 0, 0],
                                        [0, 0, 0],
                                        [0, 0, 0]])).all()
</code></pre>
<p>def test_empty_areas():
data = numpy.zeros(3, dtype=Mesh.dtype)
data['vectors'][0] = numpy.array([[0, 0, 0],
[1, 0, 0],
[0, 1, 0]])
data['vectors'][1] = numpy.array([[1, 0, 0],
[0, 1, 0],
[1, 0, 0]])
data['vectors'][2] = numpy.array([[1, 0, 0],
[0, 1, 0],
[1, 0, 0]])</p>
<pre><code>mesh = Mesh(data, remove_empty_areas=False)
assert mesh.data.size == 3

mesh = Mesh(data, remove_empty_areas=True)
assert mesh.data.size == 1
</code></pre>
<p>def test_base_mesh():
data = numpy.zeros(10, dtype=BaseMesh.dtype)
mesh = BaseMesh(data, remove_empty_areas=False)
# Increment vector 0 item 0
mesh.v0[0] += 1
mesh.v1[0] += 2</p>
<pre><code># Check item 0 (contains v0, v1 and v2)
assert (mesh[0] == numpy.array(
    [1., 1., 1., 2., 2., 2., 0., 0., 0.], dtype=numpy.float32)
).all()
assert (mesh.vectors[0] == numpy.array([
        [1., 1., 1.],
        [2., 2., 2.],
        [0., 0., 0.]], dtype=numpy.float32)).all()
assert (mesh.v0[0] == numpy.array([1., 1., 1.], dtype=numpy.float32)).all()
assert (mesh.points[0] == numpy.array(
    [1., 1., 1., 2., 2., 2., 0., 0., 0.], dtype=numpy.float32)
).all()
assert (
    mesh.x[0] == numpy.array([1., 2., 0.], dtype=numpy.float32)).all()

mesh[0] = 3
assert (mesh[0] == numpy.array(
    [3., 3., 3., 3., 3., 3., 3., 3., 3.], dtype=numpy.float32)
).all()

assert len(mesh) == len(list(mesh))
assert (mesh.min_ &lt; mesh.max_).all()
mesh.update_normals()
assert mesh.units.sum() == 0.0
mesh.v0[:] = mesh.v1[:] = mesh.v2[:] = 0
assert mesh.points.sum() == 0.0
</code></pre>
<h2 id="teststest_multiple-module">tests.test_multiple module</h2>
<p>from stl import mesh
from stl.utils import b</p>
<p>_STL_FILE = b('''
solid test.stl
facet normal -0.014565 0.073223 -0.002897
outer loop
vertex 0.399344 0.461940 1.044090
vertex 0.500000 0.500000 1.500000
vertex 0.576120 0.500000 1.117320
endloop
endfacet
endsolid test.stl
'''.lstrip())</p>
<p>def test_single_stl(tmpdir, speedups):
tmp_file = tmpdir.join('tmp.stl')
with tmp_file.open('wb+') as fh:
fh.write(_STL_FILE)
fh.seek(0)
for m in mesh.Mesh.from_multi_file(
str(tmp_file), fh=fh, speedups=speedups):
pass</p>
<p>def test_multiple_stl(tmpdir, speedups):
tmp_file = tmpdir.join('tmp.stl')
with tmp_file.open('wb+') as fh:
for _ in range(10):
fh.write(_STL_FILE)
fh.seek(0)
for i, m in enumerate(mesh.Mesh.from_multi_file(
str(tmp_file), fh=fh, speedups=speedups)):
assert m.name == b'test.stl'</p>
<pre><code>    assert i == 9
</code></pre>
<p>def test_single_stl_file(tmpdir, speedups):
tmp_file = tmpdir.join('tmp.stl')
with tmp_file.open('wb+') as fh:
fh.write(_STL_FILE)
fh.seek(0)
for m in mesh.Mesh.from_multi_file(
str(tmp_file), speedups=speedups):
pass</p>
<p>def test_multiple_stl_file(tmpdir, speedups):
tmp_file = tmpdir.join('tmp.stl')
with tmp_file.open('wb+') as fh:
for _ in range(10):
fh.write(_STL_FILE)</p>
<pre><code>    fh.seek(0)
    for i, m in enumerate(mesh.Mesh.from_multi_file(
            str(tmp_file), speedups=speedups)):
        assert m.name == b'test.stl'

    assert i == 9
</code></pre>
<h2 id="teststest_rotate-module">tests.test_rotate module</h2>
<p>import math
import numpy</p>
<p>from stl.mesh import Mesh</p>
<p>def test_rotation():
# Create 6 faces of a cube
data = numpy.zeros(6, dtype=Mesh.dtype)</p>
<pre><code># Top of the cube
data['vectors'][0] = numpy.array([[0, 1, 1],
                                  [1, 0, 1],
                                  [0, 0, 1]])
data['vectors'][1] = numpy.array([[1, 0, 1],
                                  [0, 1, 1],
                                  [1, 1, 1]])
# Right face
data['vectors'][2] = numpy.array([[1, 0, 0],
                                  [1, 0, 1],
                                  [1, 1, 0]])
data['vectors'][3] = numpy.array([[1, 1, 1],
                                  [1, 0, 1],
                                  [1, 1, 0]])
# Left face
data['vectors'][4] = numpy.array([[0, 0, 0],
                                  [1, 0, 0],
                                  [1, 0, 1]])
data['vectors'][5] = numpy.array([[0, 0, 0],
                                  [0, 0, 1],
                                  [1, 0, 1]])

mesh = Mesh(data, remove_empty_areas=False)

# Since the cube faces are from 0 to 1 we can move it to the middle by
# substracting .5
data['vectors'] -= .5

# Rotate 90 degrees over the X axis followed by the Y axis followed by the
# X axis
mesh.rotate([0.5, 0.0, 0.0], math.radians(90))
mesh.rotate([0.0, 0.5, 0.0], math.radians(90))
mesh.rotate([0.5, 0.0, 0.0], math.radians(90))

# Since the cube faces are from 0 to 1 we can move it to the middle by
# substracting .5
data['vectors'] += .5

assert (mesh.vectors == numpy.array([
    [[1, 0, 0], [0, 1, 0], [0, 0, 0]],
    [[0, 1, 0], [1, 0, 0], [1, 1, 0]],
    [[0, 1, 1], [0, 1, 0], [1, 1, 1]],
    [[1, 1, 0], [0, 1, 0], [1, 1, 1]],
    [[0, 0, 1], [0, 1, 1], [0, 1, 0]],
    [[0, 0, 1], [0, 0, 0], [0, 1, 0]],
])).all()
</code></pre>
<p>def test_rotation_over_point():
# Create a single face
data = numpy.zeros(1, dtype=Mesh.dtype)</p>
<pre><code>data['vectors'][0] = numpy.array([[1, 0, 0],
                                  [0, 1, 0],
                                  [0, 0, 1]])

mesh = Mesh(data, remove_empty_areas=False)

mesh.rotate([1, 0, 0], math.radians(180), point=[1, 2, 3])
assert (mesh.vectors == numpy.array([[1, -4, -6],
                                     [0, -5, -6],
                                     [0, -4, -7]])).all()
</code></pre>
<p>def test_no_rotation():
# Create a single face
data = numpy.zeros(1, dtype=Mesh.dtype)</p>
<pre><code>data['vectors'][0] = numpy.array([[0, 1, 1],
                                  [1, 0, 1],
                                  [0, 0, 1]])

mesh = Mesh(data, remove_empty_areas=False)

# Rotate by 0 degrees
mesh.rotate([0.5, 0.0, 0.0], math.radians(0))
assert (mesh.vectors == numpy.array([
    [[0, 1, 1], [1, 0, 1], [0, 0, 1]]])).all()

# Use a zero rotation matrix
mesh.rotate([0.0, 0.0, 0.0], math.radians(90))
assert (mesh.vectors == numpy.array([
    [[0, 1, 1], [1, 0, 1], [0, 0, 1]]])).all()
</code></pre>
<p>def test_no_translation():
# Create a single face
data = numpy.zeros(1, dtype=Mesh.dtype)
data['vectors'][0] = numpy.array([[0, 1, 1],
[1, 0, 1],
[0, 0, 1]])</p>
<pre><code>mesh = Mesh(data, remove_empty_areas=False)
assert (mesh.vectors == numpy.array([
    [[0, 1, 1], [1, 0, 1], [0, 0, 1]]])).all()

# Translate mesh with a zero vector
mesh.translate([0.0, 0.0, 0.0])
assert (mesh.vectors == numpy.array([
    [[0, 1, 1], [1, 0, 1], [0, 0, 1]]])).all()
</code></pre>
<p>def test_translation():
# Create a single face
data = numpy.zeros(1, dtype=Mesh.dtype)
data['vectors'][0] = numpy.array([[0, 1, 1],
[1, 0, 1],
[0, 0, 1]])</p>
<pre><code>mesh = Mesh(data, remove_empty_areas=False)
assert (mesh.vectors == numpy.array([
    [[0, 1, 1], [1, 0, 1], [0, 0, 1]]])).all()

# Translate mesh with vector [1, 2, 3]
mesh.translate([1.0, 2.0, 3.0])
assert (mesh.vectors == numpy.array([
    [[1, 3, 4], [2, 2, 4], [1, 2, 4]]])).all()
</code></pre>
<p>def test_no_transformation():
# Create a single face
data = numpy.zeros(1, dtype=Mesh.dtype)
data['vectors'][0] = numpy.array([[0, 1, 1],
[1, 0, 1],
[0, 0, 1]])</p>
<pre><code>mesh = Mesh(data, remove_empty_areas=False)
assert (mesh.vectors == numpy.array([
    [[0, 1, 1], [1, 0, 1], [0, 0, 1]]])).all()

# Transform mesh with identity matrix
mesh.transform(numpy.eye(4))
assert (mesh.vectors == numpy.array([
    [[0, 1, 1], [1, 0, 1], [0, 0, 1]]])).all()
assert numpy.all(mesh.areas == 0.5)
</code></pre>
<p>def test_transformation():
# Create a single face
data = numpy.zeros(1, dtype=Mesh.dtype)
data['vectors'][0] = numpy.array([[0, 1, 1],
[1, 0, 1],
[0, 0, 1]])</p>
<pre><code>mesh = Mesh(data, remove_empty_areas=False)
assert (mesh.vectors == numpy.array([
    [[0, 1, 1], [1, 0, 1], [0, 0, 1]]])).all()

# Transform mesh with identity matrix
tr = numpy.zeros((4, 4))
tr[0:3, 0:3] = Mesh.rotation_matrix([0, 0, 1], 0.5 * numpy.pi)
tr[0:3, 3] = [1, 2, 3]
mesh.transform(tr)
assert (mesh.vectors == numpy.array([
    [[0, 2, 4], [1, 3, 4], [1, 2, 4]]])).all()
assert numpy.all(mesh.areas == 0.5)</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[matplotlib绘图注意]]></title>
        <id>https://blog.bioprinting.site/post/HOPBFrX0u</id>
        <link href="https://blog.bioprinting.site/post/HOPBFrX0u">
        </link>
        <updated>2019-06-26T11:59:40.000Z</updated>
        <content type="html"><![CDATA[<p>https://wizardforcel.gitbooks.io/matplotlib-user-guide/7.3.html
https://www.guofei.site</p>
<p>转载请注明出处：</p>
<p><a href="http://www.cnblogs.com/darkknightzh/p/6182474.html">http://www.cnblogs.com/darkknightzh/p/6182474.html</a></p>
<p>参考网址：</p>
<p><a href="http://matplotlib.org/examples/pylab_examples/ginput_demo.html">http://matplotlib.org/examples/pylab_examples/ginput_demo.html</a></p>
<p><a href="http://stackoverflow.com/questions/12760797/imshowimg-cmap-cm-gray-shows-a-white-for-128-value">http://stackoverflow.com/questions/12760797/imshowimg-cmap-cm-gray-shows-a-white-for-128-value</a></p>
<p>1. 获得鼠标点击位置——使用ginput函数：</p>
<p><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>import matplotlib.pyplot as plt
import numpy as np</p>
<p>x=range(1,10)
y=[2*v for v in x]
print(x, y)
plt.plot(x, y)
pos=plt.ginput(3)
print(pos)
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><img src="https://images2015.cnblogs.com/blog/682463/201612/682463-20161215111214808-689851759.png" alt=""></p>
<p>那三个红色的十字为鼠标点击的位置，显示如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/682463/201612/682463-20161215111244026-2011598343.png" alt=""></p>
<p>2. 显示灰度图像：</p>
<p>默认imshow显示的是彩色图像：</p>
<p><img src="https://images2015.cnblogs.com/blog/682463/201612/682463-20161215111345448-1894828896.png" alt=""></p>
<p>需要显示灰度图像时，可以使用plt.get_cmap：</p>
<p><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>import matplotlib.pyplot as plt
import Image</p>
<p>im = Image.open(&quot;th.jpg&quot;)
plt.imshow(im, cmap = plt.get_cmap(&quot;gray&quot;))
pos=plt.ginput(3)
print(pos)
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><img src="https://images2015.cnblogs.com/blog/682463/201612/682463-20161215111416542-1864257153.png" alt=""></p>
<p>可以使用vmin和vmax来达到和matlab的imshow中[]一样的效果，将小于vmin的量化成黑色，大于vmax的量化成白色：</p>
<p>plt.imshow(im, cmap = plt.get_cmap(&quot;gray&quot;), vmin = 100, vmax = 150)</p>
<p><img src="https://images2015.cnblogs.com/blog/682463/201612/682463-20161215111456901-1192492061.png" alt=""></p>
<p>那三个红色的十字为鼠标点击的位置，显示如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/682463/201612/682463-20161215111519261-443664761.png" alt=""></p>
<p>由上面可见，直接plot的话，左下角是坐标原点；使用imshow时，是左上角为坐标原点。对于图像来说，和图像的坐标一样，不用转换，可以直接使用</p>
<p>使用matplotlib交互绘图****
加载图片，点击左键选中图片上的点并绘出横轴纵轴垂线，确定后点击右键打印出当前坐标：</p>
<p>#!/usr/bin/python</p>
<h1 id="codingutf-8">coding:utf-8</h1>
<p>from matplotlib import pyplot as plt
import cv2</p>
<p>def on_press(event):
if event.button==1:
ax.scatter(event.xdata, event.ydata)
plt.plot([event.xdata, event.xdata], [event.ydata, 600])
plt.plot([event.xdata, 0], [event.ydata, event.ydata])
fig.canvas.draw()
elif event.button==3:
print(&quot;x,y=&quot;,event.xdata, event.ydata)
if <strong>name</strong> == &quot;<strong>main</strong>&quot;:
img = cv2.imread('01.png')
cv2.imshow(&quot;src&quot;, img)
fig = plt.figure()
fig.canvas.mpl_connect(&quot;button_press_event&quot;, on_press)
ax = fig.add_subplot(111)
ax.imshow(img)
plt.axis(&quot;off&quot;)
plt.show()</p>
<p>输出：
原图01.png：</p>
<p>点击左键选点，并绘出横轴纵轴垂线：</p>
<h2 id="点击右键输出当前点的坐标xy-50127130681818176-20148636363636365">点击右键输出当前点的坐标：
(‘x,y=’, 501.27130681818176, 201.48636363636365)</h2>
<p>作者：阿卡蒂奥
来源：CSDN
原文：https://blog.csdn.net/akadiao/article/details/79761790
版权声明：本文为博主原创文章，转载请附上博文链接！</p>
<p>这篇文章的目的出于实验的需要,我需要对图片上的部分区域做出涂抹标记,本来是选择用opencv做交互的，但在需要进行图像的输出以及鼠标时间添加时，opencv出现错误。</p>
<p>解决方案网上有很多，尝试以后依然bug，这里先做一个记录,有时间再来处理。错误报告如下:</p>
<p>OpenCV Error: Unspecified error (The function is not implemented. Rebuild the library with Windows, GTK+ 2.x or Carbon support. If you are on Ubuntu or Debian, install libgtk2.0-dev and pkg-config, then re-run cmake or configure script) in cvShowImage, file -------src-dir-------/opencv-2.4.10/modules/highgui/src/window.cpp, line 501
Traceback (most recent call last):
File &quot;test.py&quot;, line 20, in <module>
cv2.imshow('img',img)
cv2.error: -------src-dir-------/opencv-2.4.10/modules/highgui/src/window.cpp:501: error: (-2) The function is not implemented. Rebuild the library with Windows, GTK+ 2.x or Carbon support. If you are on Ubuntu or Debian, install libgtk2.0-dev and pkg-config, then re-run cmake or configure script in function cvShowImage</p>
<p>这里我们切换另一种解决方案，利用python的matplotlib库完成图像的输出以及鼠标事件的添加。</p>
<p>点击图片，在图像中鼠标对应位置画点：</p>
<h1 id="codingutf-8-2">coding=utf-8</h1>
<p>from matplotlib import pyplot as plt
import cv2</p>
<p>def on_press(event):
if event.inaxes == None:
print &quot;none&quot;
return
#在鼠标的当前位置绘制一个点
ax.scatter(event.xdata, event.ydata）
#更新画板
fig.canvas.draw()</p>
<p>if <strong>name</strong> == &quot;<strong>main</strong>&quot;:
fileN = r'./0107_1.3.6.1.4.1.14519.5.2.1.6279.6001.263660956768649083933159084365.bmp'
img = cv2.imread(fileN)
cv2.imshow('img',img)
fig = py.figure()
fig.canvas.mpl_connect(&quot;button_press_event&quot;, on_press)
ax = fig.add_subplot(121)
ax1 = fig.add_subplot(122)
ax.imshow(img)
ax1.imshow(img)
plt.axis(&quot;off&quot;)
plt.show()</p>
<p>先来简单解释一下代码的含义：</p>
<p>fig.canvas.mpl_connect(&quot;button_press_event&quot;, on_press)#在这个figure上加点击事件，点击后的情况在自己写的on_press()方法里
def on_press(event):
event.inaxes.figure.canvas.draw()#用于图片刷新
event.x#事件的坐标用于其他按钮点击和figure点击发生冲突时判断返回
event.xdata,event.ydata#鼠标点击的位置，与上面那个坐标表示形式不同</p>
<p>最后的输出结果入下图。我们得到了非常奇怪的结果，如果你自己亲自动手试的话体会应该会更有体会，两边的图像本来应该一样大，但在第一次绘制点的时候，左侧图像出现了闪动，然后尺寸的比例突然发生了变化。</p>
<p>是的，图像尺寸没有发生变化，但尺寸的比例的确变了，这里我们要做的就是关闭自动变化的尺度比例。</p>
<p>if <strong>name</strong> == &quot;<strong>main</strong>&quot;:
fileN = r'./0107_1.3.6.1.4.1.14519.5.2.1.6279.6001.263660956768649083933159084365.bmp'
img = cv2.imread(fileN)
cv2.imshow('img',img)
fig = py.figure()
fig.canvas.mpl_connect(&quot;button_press_event&quot;, on_press)
ax = fig.add_subplot(121)
ax1 = fig.add_subplot(122)
ax.imshow(img)
ax1.imshow(img)
#关闭自动尺度适配
ax.set_autoscale_on(False)
plt.axis(&quot;off&quot;)
plt.show()
当然，我们可以改变绘制标记的样式：</p>
<p>ax.scatter(x,y,c='k',s=25,alpha=1.0,marker='o')
#T:散点的颜色
#s：散点的大小
#alpha:是透明程度</p>
<p>现在我们能够在图像上进行标记了，但这样还不够，程序需要获取这些标记点。</p>
<p>实际上fig.canvas.mpl_connect(&quot;button_press_event&quot;, on_press)能够进行自定义的多参数传递，如果在每次绘制的时候将数据保存在外部传入的列表中，那么当画板被销毁时，我们就能获取到原来所有的绘制点。</p>
<p>这里介绍两种使用方法：</p>
<p>def on_key(event, arg1, arg2, arg3):
pass
canvas.mpl_connect('key_press_event', lambda event: on_key(event, plt1, plt2, plt3))</p>
<p>和</p>
<p>def on_key(event, args_list):
pass
fig.canvas.mpl_connect('key_press_event', lambda event: on_key(event, [plt1, plt2, plt3]))</p>
<p>这里需要注意的是scatter绘制的点，实际上并没有大小的概念，这个点实质是一个坐标。</p>
<p>如果需要绘制有实际面积的圆形的标记，可以使用matplotlib.patches.Circle</p>
<p>具体的使用如下：</p>
<p>from matplotlib.patches import Circle</p>
<h2 id="fig-pltfigureax-figadd_subplot111cir-circlexy-eventxdata-eventydatafacecolor-black-edgecolorblackradius10-alpha10axadd_patchcir">fig = plt.figure()
ax = fig.add_subplot(111)
cir = Circle(xy = (event.xdata, event.ydata),facecolor = 'black', edgecolor='black',radius=10, alpha=1.0)
ax.add_patch(cir)</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TK 窗口]]></title>
        <id>https://blog.bioprinting.site/post/XnzyCJy-A</id>
        <link href="https://blog.bioprinting.site/post/XnzyCJy-A">
        </link>
        <updated>2019-06-13T12:45:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="python下用tkinter进行gui编程"><a href="https://www.cnblogs.com/fuyunbiyi/archive/2012/06/13/2548497.html">Python下用Tkinter进行GUI编程</a></h1>
<p><code>Python可用的GUI编程的包很多，Tkinter也是其中一个半标准的工具包。</code></p>
<p><code>作为一个老牌的Python GUI工具包（皮皮书屋里找了本书，竟然是2001年的),它由Tk GUI包装而来。在Windows版里面已经包括了，不用单独下载。</code></p>
<p><code>用Tkinter实现一个简单的GUI程序,单击click按钮时会在终端打印出’hello world’：</code></p>
<p><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>author</strong> = 'fyby'
from Tkinter import *   #引入Tkinter工具包
def hello():
print('hello world!')</p>
<p>win = Tk()  #定义一个窗体
win.title('Hello World')    #定义窗体标题
win.geometry('400x200')     #定义窗体的大小，是400X200像素</p>
<p>btn = Button(win, text='Click me', command=hello)
#注意这个地方，不要写成hello(),如果是hello()的话，
#会在mainloop中调用hello函数，</p>
<h1 id="而不是单击button按钮时出发事件">而不是单击button按钮时出发事件</h1>
<p>btn.pack(expand=YES, fill=BOTH) #将按钮pack，充满整个窗体(只有pack的组件实例才能显示)</p>
<p>mainloop() #进入主循环，程序运行
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><img src="https://images.cnblogs.com/cnblogs_com/fuyunbiyi/201206/201206132114189135.png" alt="image" title="image"></p>
<p><code>当我们写一个较大的程序时，最好将代码分成一个或者是几个类，再看一下Hello World例子</code></p>
<p><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>#-<em>- encoding=UTF-8 -</em>-
<strong>author</strong> = 'fyby'
from Tkinter import *
class App:
def <strong>init</strong>(self, master):
#构造函数里传入一个父组件(master),创建一个Frame组件并显示
frame = Frame(master)
frame.pack()
#创建两个button，并作为frame的一部分
self.button = Button(frame, text=&quot;QUIT&quot;, fg=&quot;red&quot;, command=frame.quit)
self.button.pack(side=LEFT) #此处side为LEFT表示将其放置 到frame剩余空间的最左方
self.hi_there = Button(frame, text=&quot;Hello&quot;, command=self.say_hi)
self.hi_there.pack(side=LEFT)</p>
<pre><code>def say_hi(self):
    print &quot;hi there, this is a class example!&quot;
</code></pre>
<p>win = Tk()
app = App(win)
win.mainloop()
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><img src="https://images.cnblogs.com/cnblogs_com/fuyunbiyi/201206/201206132114208428.png" alt="image" title="image"></p>
<p>看完了上面两个无聊的Hello World例子，再来看一个稍微Perfect点的东西吧。Menu组件，自己画一个像样点的程序外壳。</p>
<p><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>#-<em>- encoding=UTF-8 -</em>-
<strong>author</strong> = 'fyby'
from Tkinter import *</p>
<p>root = Tk()</p>
<p>def hello():
print('hello')</p>
<h1 id="创建一个导航菜单">创建一个导航菜单</h1>
<p>menubar = Menu(root)
menubar.add_command(label=&quot;Hello!&quot;, command=hello)
menubar.add_command(label=&quot;Quit!&quot;,command=root.quit)</p>
<p>root.config(menu=menubar)</p>
<p>mainloop()
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><img src="https://images.cnblogs.com/cnblogs_com/fuyunbiyi/201206/201206132114217481.png" alt="image" title="image"></p>
<p>这个程序还是有点无趣，因为我们只是创建了一个顶级的导航菜单，点击后只是在终端中输出hello而已，下面来创建一个下拉菜单，这样才像一个正儿八经的应用<img src="https://images.cnblogs.com/cnblogs_com/fuyunbiyi/201206/201206132114226675.png" alt="大笑">在下面的这个例子中，会创建三个顶级菜单，每个顶级菜单中都有下拉菜单（用add_command方法创建，最后用add_cascade方法加入到上级菜单中去），为每个下拉选项都绑定一个hello函数，在终端中打印出hello.</p>
<p>root.quit是退出这个Tk的实例。</p>
<p><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>#-<em>- encoding=UTF-8 -</em>-
<strong>author</strong> = 'fyby'
from Tkinter import *
root = Tk()</p>
<p>def hello():
print('hello')</p>
<p>def about():
print('我是开发者')</p>
<p>menubar = Menu(root)</p>
<p>#创建下拉菜单File，然后将其加入到顶级的菜单栏中
filemenu = Menu(menubar,tearoff=0)
filemenu.add_command(label=&quot;Open&quot;, command=hello)
filemenu.add_command(label=&quot;Save&quot;, command=hello)
filemenu.add_separator()
filemenu.add_command(label=&quot;Exit&quot;, command=root.quit)
menubar.add_cascade(label=&quot;File&quot;, menu=filemenu)</p>
<p>#创建另一个下拉菜单Edit
editmenu = Menu(menubar, tearoff=0)
editmenu.add_command(label=&quot;Cut&quot;, command=hello)
editmenu.add_command(label=&quot;Copy&quot;, command=hello)
editmenu.add_command(label=&quot;Paste&quot;, command=hello)
menubar.add_cascade(label=&quot;Edit&quot;,menu=editmenu)
#创建下拉菜单Help
helpmenu = Menu(menubar, tearoff=0)
helpmenu.add_command(label=&quot;About&quot;, command=about)
menubar.add_cascade(label=&quot;Help&quot;, menu=helpmenu)</p>
<p>#显示菜单
root.config(menu=menubar)</p>
<p>mainloop()
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><img src="https://images.cnblogs.com/cnblogs_com/fuyunbiyi/201206/201206132114235727.png" alt="image" title="image"></p>
<p>写了这一些，差不多对Tkinter有了一个大体的印象了。在Python中用Tkinter绘制GUI界面还是蛮简单的。再把上面的例子扩展一下，和Label标签结合，当单击about的时候，在窗体上打印About的内容，而不是在终端输出。将about函数稍微修改一下。单击about以后将会调用about函数渲染frame绘制一个标签并显示其内容。
def about():
w = Label(root,text=&quot;开发者感谢名单\nfuyunbiyi\nfyby尚未出现的女朋友\nhttp://www.programup.com网站&quot;)
w.pack(side=TOP)</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/fuyunbiyi/201206/201206132114252054.png" alt="image" title="image"></p>
<p>关于Tkinter更多的内容，参考<a href="http://www.programup.com/wiki/beginning_tkinter/">http://www.programup.com/wiki/beginning_tkinter/</a>，例子原型主要来自于该网站，还有一本书（就是文章开头提到过的那那本01年的书，<a href="http://www.ppurl.com/2012/02/python%E4%B8%8Etkinter%E7%BC%96%E7%A8%8B.html">http://www.ppurl.com/2012/02/python%E4%B8%8Etkinter%E7%BC%96%E7%A8%8B.html</a>)。还有，国内的书记得《征服Python》中好像也有关于Tkinter的例子，在VeryCD上应该可以找的到<img src="https://images.cnblogs.com/cnblogs_com/fuyunbiyi/201206/201206132114264039.png" alt="大声笑">。</p>
<p>分类: <a href="https://www.cnblogs.com/fuyunbiyi/category/368825.html">读书笔记</a></p>
<p><a id="green_channel_digg"></a>好文要顶 <a id="green_channel_follow"></a>关注我 <a id="green_channel_favorite"></a>收藏该文 <a id="green_channel_weibo" title="分享至新浪微博"></a><img src="https://common.cnblogs.com/images/icon_weibo_24.png" alt=""> <a id="green_channel_wechat" title="分享至微信"></a><img src="https://common.cnblogs.com/images/wechat.png" alt=""></p>
<p><a href="https://home.cnblogs.com/u/fuyunbiyi/"><img src="https://pic.cnblogs.com/face/u370835.jpg?id=24210832" alt=""></a>
<a href="https://home.cnblogs.com/u/fuyunbiyi/">浮云比翼</a>
<a href="https://home.cnblogs.com/u/fuyunbiyi/followees">关注 - 19</a>
<a href="https://home.cnblogs.com/u/fuyunbiyi/followers">粉丝 - 78</a></p>
<p><a>+加关注</a></p>
<p>2</p>
<p>0</p>
<p><a href="https://www.cnblogs.com/fuyunbiyi/archive/2012/06/03/2532750.html">« </a>上一篇：<a href="https://www.cnblogs.com/fuyunbiyi/archive/2012/06/03/2532750.html" title="发布于2012-06-03 15:06">6月3日——回首一个半月</a>
<a href="https://www.cnblogs.com/fuyunbiyi/archive/2012/07/31/2617419.html">» </a>下一篇：<a href="https://www.cnblogs.com/fuyunbiyi/archive/2012/07/31/2617419.html" title="发布于2012-07-31 21:32">学生终究要面对社会</a></p>
<p>posted @ 2012-06-13 21:14 <a href="https://www.cnblogs.com/fuyunbiyi/">浮云比翼</a> 阅读(27174) 评论(5) <a href="https://i.cnblogs.com/EditPosts.aspx?postid=2548497">编辑</a> <a href="https://www.cnblogs.com/fuyunbiyi/archive/2012/06/13/2548497.html">收藏</a></p>
<p><a name="!comments"></a></p>
<p>评论列表</p>
<p><a href="https://www.cnblogs.com/fuyunbiyi/archive/2012/06/13/2548497.html#2479400">#1楼</a><a id="comment_anchor_2479400" name="2479400"></a> 2012-09-23 15:42 <a href="https://www.cnblogs.com/hollyspirit/">hollyspirit</a> <a href="http://msg.cnblogs.com/send/hollyspirit" title="发送站内短消息"> </a></p>
<p>很好的学习材料。</p>
<p><a class="comment_digg">支持(0)</a><a class="comment_bury">反对(0)</a></p>
<p><a href="https://www.cnblogs.com/fuyunbiyi/archive/2012/06/13/2548497.html#2501081">#2楼</a><a id="comment_anchor_2501081" name="2501081"></a> 2012-10-22 17:01 <a href="http://home.cnblogs.com/u/438131/">prayer163</a> <a href="http://msg.cnblogs.com/send/prayer163" title="发送站内短消息"> </a></p>
<p>请问您这句：
filemenu = Menu(menubar,tearoff=0)</p>
<p>里面tearoff是什么含义？</p>
<p>我该如何、在哪里能查到这些参数的意义呢？ 谢谢！</p>
<p><a class="comment_digg">支持(1)</a><a class="comment_bury">反对(0)</a></p>
<p><a href="https://www.cnblogs.com/fuyunbiyi/archive/2012/06/13/2548497.html#2502107">#3楼</a><a id="comment_anchor_2502107" name="2502107"></a>[楼主] 2012-10-22 20:15 <a href="https://www.cnblogs.com/fuyunbiyi/">浮云比翼</a> <a href="http://msg.cnblogs.com/send/%E6%B5%AE%E4%BA%91%E6%AF%94%E7%BF%BC" title="发送站内短消息"> </a></p>
<p><a href="https://www.cnblogs.com/fuyunbiyi/archive/2012/06/13/2548497.html#2501081" title="查看所回复的评论">@</a> prayer163
tearoff=0指的是不分开，就是说你所添加的submenu不能弹出新窗口，如果你想要使用哪种点击一下能弹出一个新窗口显示一些目录的话可以设置tearoff=1。
其实完全可以自己动手试一下的，例如，将filemenu = Menu(menubar,tearoff=0)改成filemenu = Menu(menubar,tearoff=1)，这时你再点击filemenu的时候，会看到下拉目录里面有一条线，然后点击这条线，就会弹出一个新的窗口显示这一些的下拉菜单了。
相关资料可以参考<a href="http://www.tutorialspoint.com/python/tk_menu.htm">http://www.tutorialspoint.com/python/tk_menu.htm</a></p>
<p>但是这上面说的参数说明也都比较笼统，还是自己试验一下比较好一些。</p>
<p><a class="comment_digg">支持(1)</a><a class="comment_bury">反对(0)</a></p>
<p><a href="https://www.cnblogs.com/fuyunbiyi/archive/2012/06/13/2548497.html#2502110">#4楼</a><a id="comment_anchor_2502110" name="2502110"></a>[楼主] 2012-10-22 20:21 <a href="https://www.cnblogs.com/fuyunbiyi/">浮云比翼</a> <a href="http://msg.cnblogs.com/send/%E6%B5%AE%E4%BA%91%E6%AF%94%E7%BF%BC" title="发送站内短消息"> </a></p>
<p><a href="https://www.cnblogs.com/fuyunbiyi/archive/2012/06/13/2548497.html#2501081" title="查看所回复的评论">@</a> prayer163
<img src="https://pic002.cnblogs.com/images/2012/370835/2012102220204555.png" alt=""></p>
<p>点了以后就是这样的</p>
<p><img src="https://pic002.cnblogs.com/images/2012/370835/2012102220205355.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PyAutoGui]]></title>
        <id>https://blog.bioprinting.site/post/BI_VpZjOp</id>
        <link href="https://blog.bioprinting.site/post/BI_VpZjOp">
        </link>
        <updated>2019-06-13T11:48:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="pyautogui">PyAutoGUI</h1>
<p>PyAutoGUI是一个面向人类的跨平台GUI自动化Python模块。用于以编程方式控制鼠标和键盘。</p>
<p><code>pip install pyautogui</code></p>
<p>完整文档可在<a href="https://pyautogui.readthedocs.org/">https://pyautogui.readthedocs.org获得</a></p>
<p>简体中文文档可从<a href="https://muxuezi.github.io/posts/doc-pyautogui.html">https://muxuezi.github.io/posts/doc-pyautogui.html获得</a></p>
<p>源代码可在<a href="https://github.com/asweigart/pyautogui">https://github.com/asweigart/pyautogui获得</a></p>
<h1 id=""><a href="https://github.com/3dprintingdoctor/pyautogui#dependencies"></a>依赖</h1>
<p>PyAutoGUI支持Python 2和3.如果使用pip从PyPI安装PyAutoGUI：</p>
<p>Windows没有依赖项。不需要安装Win32扩展。</p>
<p>OS X需要安装pyobjc-core和pyobjc模块（按此顺序）。</p>
<p>Linux需要安装python3-xlib（或Python 2的python-xlib）模块。</p>
<p>需要安装Pillow，在Linux上，您可能需要安装其他库以确保Pillow的PNG / JPEG正常工作。看到：</p>
<p><code>https://stackoverflow.com/questions/7648200/pip-install-pil-e-tickets-1-no-jpeg-png-support</p>
<p>http://ubuntuforums.org/showthread.php?t=1751455</code></p>
<p>如果您想进行开发并为PyAutoGUI做出贡献，您需要从PyPI安装这些模块：</p>
<ul>
<li>pyscreeze</li>
<li>pymsgbox</li>
<li>pytweening</li>
</ul>
<h1 id="-2"><a href="https://github.com/3dprintingdoctor/pyautogui#example-usage"></a>示例用法</h1>
<h2 id="-3"><a href="https://github.com/3dprintingdoctor/pyautogui#keyboard-and-mouse-control"></a>键盘和鼠标控制</h2>
<pre><code> &gt;&gt; &gt;  进口 pyautogui
 &gt;&gt; &gt;屏幕宽度，screenHeight = pyautogui.size（）
 &gt;&gt; &gt; currentMouseX，currentMouseY = pyautogui.position（）
 &gt;&gt; &gt; pyautogui.moveTo（100，150）
 &gt;&gt; &gt; pyautogui.click（）
 &gt;&gt; &gt; pyautogui.moveRel（无，10）   ＃移动鼠标10个像素向下
&gt;&gt; &gt; pyautogui.doubleClick（）
 &gt;&gt; &gt; pyautogui。moveTo（ 500，500，duration = 2，tween = pyautogui.tweens.easeInOutQuad）   ＃使用补间/缓动功能将鼠标移动超过2秒。
&gt;&gt; &gt; pyautogui.typewrite（'世界，你好！'，间隔= 0.25）   ＃在每个键之间以1/4秒的暂停型
&gt;&gt; &gt; pyautogui.press（' ESC '）
 &gt;&gt; &gt; pyautogui.keyDown（'移'）
 &gt;&gt; &gt; pyautogui.typewrite（['左'， '左'， '左'， '左'， '左'， '左' ]）
&gt;&gt; &gt; pyautogui.keyUp（ '移'）
&gt;&gt; &gt; pyautogui.hotkey（ ' CTRL '， ' Ç '）
</code></pre>
<h2 id="-4"><a href="https://github.com/3dprintingdoctor/pyautogui#display-message-boxes"></a>显示消息框</h2>
<pre><code> &gt;&gt; &gt;  进口 pyautogui
 &gt;&gt; &gt; pyautogui.alert（'这是一个警告框。'）
 ' OK '
&gt;&gt; &gt; pyautogui.confirm（'要我继续吗？'）
 '取消'
&gt;&gt; &gt; pyautogui.confirm（'输入选项。'，buttons = [ ' A '，' B '，' C ' ]）
 'B '
 &gt;&gt;&gt; pyautogui.prompt（“你叫什么名字？”）
 “铝”
&gt;&gt; &gt; pyautogui.password（“请输入密码（文本将被隐藏）”），
 “剑鱼”
</code></pre>
<h2 id="-5"><a href="https://github.com/3dprintingdoctor/pyautogui#screenshot-functions"></a>截图功能</h2>
<p>（PyAutoGUI使用Pillow来处理与图像相关的功能。）</p>
<pre><code> &gt;&gt; &gt;  进口 pyautogui
 &gt;&gt; &gt; IM1 = pyautogui.screenshot（）
 &gt;&gt; &gt; im1.save（' my_screenshot.png '）
 &gt;&gt; &gt; IM2 = pyautogui.screenshot（' my_screenshot2.png '）
</code></pre>
<p>您还可以找到屏幕上图像的位置：</p>
<pre><code> &gt;&gt; &gt;  进口 pyautogui
 &gt;&gt; &gt; button7location = pyautogui.locateOnScreen（' button.png '）＃匹配区域的返回（左，上，宽度，高度）
&gt;&gt; &gt; button7location
（1416，562，50，41）
 &gt;&gt; &gt; buttonx，buttony = pyautogui.center（button7location）
 &gt;&gt; &gt; buttonx，buttony
（1441，582）
 &gt;&gt; &gt; pyautogui.click（buttonx，buttony）  ＃点击其中按钮被发现的中心
</code></pre>
<p>locateCenterOnScreen（）函数返回此匹配区域的中心：</p>
<pre><code> &gt;&gt; &gt;  进口 pyautogui
 &gt;&gt; &gt; buttonx，buttony = pyautogui.locateCenterOnScreen（' button.png '）＃返回（X，Y）的匹配区域的
&gt;&gt; &gt; buttonx，buttony
（1441，582）
 &gt;&gt; &gt; pyautogui.click（buttonx，buttony）  ＃点击其中按钮被发现的中心
</code></pre>
<h2 id="pyautogui让所有gui都自动化">PyAutoGUI——让所有GUI都自动化</h2>
<p>本教程译自大神<a href="http://inventwithpython.com/">Al Sweigart</a>的<a href="https://pyautogui.readthedocs.org/">PyAutoGUI</a>项目，Python自动化工具，更适合处理GUI任务，网页任务推荐：</p>
<ul>
<li><a href="https://selenium-python.readthedocs.org/">Selenium</a>+Firefox记录（Chromedriver和Phantomjs也很给力，Phantomjs虽然是无头浏览器，但有时定位不准），然后用Python写单元测试</li>
<li><a href="http://www.python-requests.org/en/latest/">request</a>处理get/post请求写一堆代码自动化处理，都在后台运行，不用运行浏览器，非常适合处理表单</li>
</ul>
<p>没有<a href="http://www.sikuli.org/">sikuli</a>功能多，但是Python让生活更简单，<a href="http://cn.pycon.org/2015/">人生苦短，Python当歌</a>。</p>
<p>同时推荐一本Python网络数据采集（图灵社区取的名字^_^）的基础书籍<a href="http://shop.oreilly.com/product/0636920034391.do">Ryan Mitchell的《Web Scraping with Python》</a>，可以和PyAutoGUI结合使用。</p>
<p>tl;dr</p>
<p>2015-08-17：输入中文bug没有解决，目前的解决方案是Python 2.X环境下安装<a href="https://github.com/asweigart/pyperclip">pyperclip</a>和pyautogui，用复制粘贴来实现。</p>
<p>In [ ]:</p>
<p>import pyperclip
import pyautogui</p>
<h1 id="pyautogui中文输入需要用粘贴实现">PyAutoGUI中文输入需要用粘贴实现</h1>
<h1 id="python-2版本的pyperclip提供中文复制">Python 2版本的pyperclip提供中文复制</h1>
<p>def paste(foo):
pyperclip.copy(foo)
pyautogui.hotkey('ctrl', 'v')</p>
<p>foo = u'学而时习之'</p>
<h1 id="移动到文本框">移动到文本框</h1>
<p>pyautogui.click(130,30)
paste(foo)</p>
<h2 id="1简介">1.简介</h2>
<h3 id="11-目的">1.1 目的</h3>
<p>PyAutoGUI是一个纯Python的GUI自动化工具，其目的是可以用程序自动控制鼠标和键盘操作，多平台支持（Windows，OS X，Linux）。可以用<code>pip</code>安装，Github上有<a href="https://github.com/asweigart/pyautogui">源代码</a>。</p>
<p>下面的代码让鼠标移到屏幕中央。</p>
<p>In [ ]:</p>
<p>import pyautogui
screenWidth, screenHeight = pyautogui.size()
pyautogui.moveTo(screenWidth / 2, screenHeight / 2)</p>
<p>PyAutoGUI可以模拟鼠标的移动、点击、拖拽，键盘按键输入、按住操作，以及鼠标+键盘的热键同时按住等操作，可以说手能动的都可以。</p>
<h3 id="12-例子">1.2 例子</h3>
<p>In [ ]:</p>
<p>import pyautogui
screenWidth, screenHeight = pyautogui.size()
currentMouseX, currentMouseY = pyautogui.position()
pyautogui.moveTo(100, 150)
pyautogui.click()</p>
<h1 id="鼠标向下移动10像素">鼠标向下移动10像素</h1>
<p>pyautogui.moveRel(None, 10)
pyautogui.doubleClick()</p>
<h1 id="用缓动渐变函数让鼠标2秒后移动到500500位置">用缓动/渐变函数让鼠标2秒后移动到(500,500)位置</h1>
<h1 id="use-tweeningeasing-function-to-move-mouse-over-2-seconds">use tweening/easing function to move mouse over 2 seconds.</h1>
<p>pyautogui.moveTo(1800, 500, duration=2, tween=pyautogui.easeInOutQuad)</p>
<h1 id="在每次输入之间暂停025秒">在每次输入之间暂停0.25秒</h1>
<p>pyautogui.typewrite('Hello world!', interval=0.25)
pyautogui.press('esc')
pyautogui.keyDown('shift')
pyautogui.press(['left', 'left', 'left', 'left', 'left', 'left'])
pyautogui.keyUp('shift')
pyautogui.hotkey('ctrl', 'c')</p>
<p>In [ ]:</p>
<p>distance = 200
while distance &gt; 0:
pyautogui.dragRel(distance, 0, duration=0.5) # 向右
distance -= 5
pyautogui.dragRel(0, distance, duration=0.5) # 向下
pyautogui.draIn gRel(-distance, 0, duration=0.5) # 向左
distance -= 5
pyautogui.dragRel(0, -distance, duration=0.5) # 向上</p>
<h3 id="14-保护措施fail-safes">1.4 保护措施（Fail-Safes）</h3>
<p>就像《魔法师的学徒》(Sorcerer’s Apprentice)会担水的扫帚，可以担水，却无力阻止水漫浴室。你的程序也可能会失控（即使是按照你的意思执行的），那时就需要中断。如果鼠标还在自动操作，就很难在程序窗口关闭它。</p>
<p>为了能够及时中断，PyAutoGUI提供了一个保护措施。当<code>pyautogui.FAILSAFE = True</code>时，如果把鼠标光标在屏幕左上角，PyAutoGUI函数就会产生<code>pyautogui.FailSafeException</code>异常。如果失控了，需要中断PyAutoGUI函数，就把鼠标光标在屏幕左上角。要禁用这个特性，就把<code>FAILSAFE</code>设置成<code>False</code>：</p>
<p>In [ ]:</p>
<p>import pyautogui
pyautogui.FAILSAFE = False</p>
<p>通过把<code>pyautogui.PAUSE</code>设置成<code>float</code>或<code>int</code>时间（秒），可以为所有的PyAutoGUI函数增加延迟。默认延迟时间是0.1秒。在函数循环执行的时候，这样做可以让PyAutoGUI运行的慢一点，非常有用。例如：</p>
<p>In [ ]:</p>
<p>import pyautogui
pyautogui.PAUSE = 2.5
pyautogui.moveTo(100,100); pyautogui.click()</p>
<p>所有的PyAutoGUI函数在延迟完成前都处于阻塞状态（block）。（未来计划增加一个可选的非阻塞模式来调用函数。）</p>
<p><strong>建议<code>PAUSE</code>和<code>FAILSAFE</code>一起使用。</strong></p>
<h2 id="2-安装与依赖">2 安装与依赖</h2>
<p>PyAutoGUI支持Python 2.x和Python 3.x</p>
<ul>
<li>Windows：PyAutoGUI没有任何依赖，因为它用Python的<code>ctypes</code>模块所以不需要<code>pywin32</code><code>pip3 install pyautogui</code></li>
<li>OS X：PyAutoGUI需要<a href="http://pythonhosted.org/pyobjc/install.html">PyObjC</a>运行AppKit和Quartz模块。这个模块在PyPI上的按住顺序是<code>pyobjc-core</code>和<code>pyobjc</code><code>sudo pip3 install pyobjc-core
sudo pip3 install pyobjc
sudo pip3 install pyautogui</code></li>
<li>Linux：PyAutoGUI需要<code>python-xlib</code>（Python 2）、<code>python3-Xlib</code>（Python 3）<code>sudo pip3 install python3-xlib
sudo apt-get scrot
sudo apt-get install python-tk
sudo apt-get install python3-dev
sudo pip3 install pyautogui</code></li>
</ul>
<h3 id="3速查表小抄cheat-sheet">3.速查表（小抄，Cheat Sheet）</h3>
<h4 id="31-常用函数">3.1 常用函数</h4>
<p>In [ ]:</p>
<p>import pyautogui</p>
<h1 id="当前鼠标的坐标">当前鼠标的坐标</h1>
<p>pyautogui.position()</p>
<p>Out[ ]:</p>
<p>(123, 372)</p>
<p>In [ ]:</p>
<h1 id="当前屏幕的分辨率宽度和高度">当前屏幕的分辨率（宽度和高度）</h1>
<p>pyautogui.size()</p>
<p>Out[ ]:</p>
<p>(1920, 1080)</p>
<p>In [ ]:</p>
<h1 id="xy是否在屏幕上">(x,y)是否在屏幕上</h1>
<p>x, y = 122, 244
pyautogui.onScreen(x, y)</p>
<p>Out[ ]:</p>
<p>True</p>
<h4 id="32-保护措施">3.2 保护措施</h4>
<p>PyAutoGUI函数增加延迟为2.5秒：</p>
<p>In [ ]:</p>
<p>import pyautogui
pyautogui.PAUSE = 2.5</p>
<p>当pyautogui.FAILSAFE = True时，如果把鼠标光标在屏幕左上角，PyAutoGUI函数就会产生pyautogui.FailSafeException异常。</p>
<p>In [ ]:</p>
<p>import pyautogui
pyautogui.FAILSAFE = True</p>
<h4 id="33-鼠标函数">3.3 鼠标函数</h4>
<p>坐标系的原点是左上角。X轴（水平）坐标向右增大，Y轴（竖直）坐标向下增大。</p>
<p>In [ ]:</p>
<p>num_seconds = 1.2</p>
<h1 id="用num_seconds秒的时间把光标移动到x-y位置">用num_seconds秒的时间把光标移动到(x, y)位置</h1>
<p>pyautogui.moveTo(x, y, duration=num_seconds)</p>
<h1 id="用num_seconds秒的时间把光标的x轴水平坐标移动xoffset">用num_seconds秒的时间把光标的X轴（水平）坐标移动xOffset，</h1>
<h1 id="y轴竖直坐标向下移动yoffset">Y轴（竖直）坐标向下移动yOffset。</h1>
<p>xOffset, yOffset = 50, 100
pyautogui.moveRel(xOffset, yOffset, duration=num_seconds)</p>
<p><code>click()</code>函数就是让鼠标点击，默认是单击左键，参数可以设置：</p>
<p>In [ ]:</p>
<p>pyautogui.click(x=moveToX, y=moveToY, clicks=num_of_clicks, interval=secs_between_clicks, button='left')</p>
<p>其中，<code>button</code>属性可以设置成<code>left</code>，<code>middle</code>和<code>right</code>。</p>
<p>所有的点击都可以用这个函数，不过下面的函数可读性更好：</p>
<p>In [ ]:</p>
<p>pyautogui.rightClick(x=moveToX, y=moveToY)
pyautogui.middleClick(x=moveToX, y=moveToY)
pyautogui.doubleClick(x=moveToX, y=moveToY)
pyautogui.tripleClick(x=moveToX, y=moveToY)</p>
<p><code>scroll</code>函数控制鼠标滚轮的滚动，<code>amount_to_scroll</code>参数表示滚动的格数。正数则页面向上滚动，负数则向下滚动：</p>
<p>In [ ]:</p>
<p>pyautogui.scroll(clicks=amount_to_scroll, x=moveToX, y=moveToY)</p>
<p>每个按键按下和松开两个事件可以分开处理：</p>
<p>In [ ]:</p>
<p>pyautogui.mouseDown(x=moveToX, y=moveToY, button='left')
pyautogui.mouseUp(x=moveToX, y=moveToY, button='left')</p>
<h4 id="34-键盘函数">3.4 键盘函数</h4>
<p>键盘上可以按的键都可以调用：</p>
<p>In [ ]:</p>
<h1 id="每次键入的时间间隔">每次键入的时间间隔</h1>
<p>secs_between_keys = 0.1
pyautogui.typewrite('Hello world!\n', interval=secs_between_keys)</p>
<p>多个键也可以：</p>
<p>In [ ]:</p>
<p>pyautogui.typewrite(['a', 'b', 'c', 'left', 'backspace', 'enter', 'f1'], interval=secs_between_keys)</p>
<p>按键名称列表：</p>
<p>In [ ]:</p>
<p>pyautogui.KEYBOARD_KEYS[:10]</p>
<p>Out[ ]:</p>
<p>['\t', '\n', '\r', ' ', '!', '&quot;', '#', '$', '%', '&amp;']</p>
<p>键盘的一些热键像<code>Ctrl-S</code>或<code>Ctrl-Shift-1</code>都可以用<code>hotkey()</code>函数来实现：</p>
<p>In [ ]:</p>
<p>pyautogui.hotkey('ctrl', 'a') # 全选
pyautogui.hotkey('ctrl', 'c') # 复制
pyautogui.hotkey('ctrl', 'v') # 粘贴</p>
<p>每个按键的按下和松开也可以单独调用：</p>
<p>In [ ]:</p>
<p>pyautogui.keyDown(key_name)
pyautogui.keyUp(key_name)</p>
<h4 id="35-消息弹窗函数">3.5 消息弹窗函数</h4>
<p>如果你需要消息弹窗，通过单击OK暂停程序，或者向用户显示一些信息，消息弹窗函数就会有类似JavaScript的功能：</p>
<p>In [ ]:</p>
<p>pyautogui.alert('这个消息弹窗是文字+OK按钮')
pyautogui.confirm('这个消息弹窗是文字+OK+Cancel按钮')
pyautogui.prompt('这个消息弹窗是让用户输入字符串，单击OK')</p>
<p>Out[ ]:</p>
<p>''</p>
<p>在<code>prompt()</code>函数中，如果用户什么都不输入，就会返回<code>None</code>。</p>
<h4 id="36-截屏函数">3.6 截屏函数</h4>
<p>PyAutoGUI用Pillow/PIL库实现图片相关的识别和操作。</p>
<p>在Linux里面，你必须执行<code>sudo apt-get install scrot</code>来使用截屏特性。</p>
<p>In [ ]:</p>
<h1 id="返回一个pillowpil的image对象">返回一个Pillow/PIL的Image对象</h1>
<p>pyautogui.screenshot()
pyautogui.screenshot('foo.png')</p>
<p>如果你有一个图片文件想在上面做点击操作，你可以用<code>locateOnScreen()</code>函数来定位。</p>
<p>In [ ]:</p>
<h1 id="返回最左x坐标最顶y坐标宽度高度">返回(最左x坐标，最顶y坐标，宽度，高度)</h1>
<p>pyautogui.locateOnScreen('pyautogui/looks.png')</p>
<p>Out[ ]:</p>
<p>(0, 1040, 48, 40)</p>
<p><code>locateAllOnScreen()</code>函数会寻找所有相似图片，返回一个生成器：</p>
<p>In [ ]:</p>
<p>for i in pyautogui.locateAllOnScreen('pyautogui/looks.png'):
print(i)</p>
<p>(0, 1040, 48, 40)</p>
<p>In [ ]:</p>
<p>list(pyautogui.locateAllOnScreen('pyautogui/looks.png'))</p>
<p>Out[ ]:</p>
<p>[(0, 1040, 48, 40)]</p>
<p><code>locateCenterOnScreen()</code>函数会返回图片在屏幕上的中心XY轴坐标值：</p>
<p>In [ ]:</p>
<p>pyautogui.locateCenterOnScreen('pyautogui/looks.png')</p>
<p>Out[ ]:</p>
<p>(24, 1060)</p>
<p>如果没找到图片会返回<code>None</code>。</p>
<blockquote>
<p>定位比较慢，一般得用1~2秒</p>
</blockquote>
<h2 id="4-常用函数">4 常用函数</h2>
<ul>
<li><code>position()</code>：返回整数元组(x, y)，分别表示鼠标光标所在位置的XY轴坐标</li>
<li><code>size()</code>：返回显示器的尺寸整数元组(x, y)。未来将加入多屏支持</li>
</ul>
<h2 id="5-鼠标控制函数">5 鼠标控制函数</h2>
<h3 id="51-屏幕与鼠标位置">5.1 屏幕与鼠标位置</h3>
<p>屏幕位置使用X和Y轴的笛卡尔坐标系。原点<code>(0,0)</code>在左上角，分别向右、向下增大。</p>
<p>如果屏幕像素是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1920</mn><mo>×</mo><mn>1080</mn></mrow><annotation encoding="application/x-tex">1920 \times 1080</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">8</span><span class="mord">0</span></span></span></span>，那么右下角的坐标是<code>(1919, 1079)</code>。</p>
<p>分辨率大小可以通过<code>size()</code>函数返回整数元组。光标的位置用<code>position()</code>返回。例如：</p>
<p>In [ ]:</p>
<p>pyautogui.size()</p>
<p>Out[ ]:</p>
<p>(1920, 1080)</p>
<p>In [ ]:</p>
<p>pyautogui.position()</p>
<p>Out[ ]:</p>
<p>(272, 688)</p>
<p>下面是Python 3版本的光标位置记录程序：</p>
<p>In [ ]:</p>
<h1 id="python-3">! python 3</h1>
<p>import pyautogui
print('Press Ctrl-C to quit')
try:
while True:
x, y = pyautogui.position()
positionStr = 'X: {} Y: {}'.format(*[str(x).rjust(4) for x in [x, y]])
print(positionStr, end='')
print('\b' * len(positionStr), end='', flush=True)
except KeyboardInterrupt:
print('\n')</p>
<p>Python 2版本是：</p>
<p>In [ ]:</p>
<h1 id="python">! python</h1>
<p>import pyautogui, sys
print('Press Ctrl-C to quit.')
try:
while True:
x, y = pyautogui.position()
positionStr = 'X: ' + str(x).rjust(4) + ' Y: ' + str(y).rjust(4)
print positionStr,
print '\b' * (len(positionStr) + 2),
sys.stdout.flush()
except KeyboardInterrupt:
print '\n'</p>
<p>要检查XY坐标是否在屏幕上，需要用<code>onScreen()</code>函数来检验，如果在屏幕上返回<code>True</code>：</p>
<p>In [ ]:</p>
<p>import pyautogui
pyautogui.onScreen(0, 0)</p>
<p>Out[ ]:</p>
<p>True</p>
<p>In [ ]:</p>
<p>pyautogui.onScreen(0, -1)</p>
<p>Out[ ]:</p>
<p>False</p>
<p>In [ ]:</p>
<p>pyautogui.onScreen(0, 2080)</p>
<p>Out[ ]:</p>
<p>False</p>
<p>In [ ]:</p>
<p>pyautogui.onScreen(1920, 1080)</p>
<p>Out[ ]:</p>
<p>False</p>
<p>In [ ]:</p>
<p>pyautogui.onScreen(1919, 1079)</p>
<p>Out[ ]:</p>
<p>True</p>
<h3 id="52-鼠标行为">5.2 鼠标行为</h3>
<p><code>moveTo()</code>函数会把鼠标光标移动到指定的XY轴坐标处。如果传入<code>None</code>值，则表示使用当前光标的对象轴坐标值。</p>
<p>In [ ]:</p>
<p>pyautogui.moveTo(100, 200)     # 光标移动到(100, 200)位置
pyautogui.moveTo(None, 500)   # 光标移动到(100, 500)位置
pyautogui.moveTo(600, None)   # 光标移动到(600, 500)位置</p>
<p>一般鼠标光标都是瞬间移动到指定的位置，如果你想让鼠标移动的慢点，可以设置持续时间：</p>
<p>In [ ]:</p>
<p>pyautogui.moveTo(100, 200, duration=2)     # 用2秒把光标移动到(100, 200)位置</p>
<p>默认的持续时间<code>pyautogui.MINIMUM_DURATION</code>是0.1秒，如果你设置的时间比默认值还短，那么就会瞬间执行。</p>
<p>如果你想让光标以当前位置为原点，进行相对移动，就用<code>pyautogui.moveRel()</code>函数。例如：</p>
<p>In [ ]:</p>
<p>pyautogui.moveTo(100, 200) #把光标移动到(100, 200)位置
pyautogui.moveRel(0, 50)   #向下移动50
pyautogui.moveRel(30, 0, 2)   #向右移动30
pyautogui.moveRel(30, None)   #向右移动30</p>
<h3 id="53-鼠标拖拽">5.3 鼠标拖拽</h3>
<p>PyAutoGUI的<code>dragTo()</code>和<code>dragRel()</code>函数与<code>moveTo()</code>和<code>moveRel()</code>函数类似。另外，他们有一个<code>button</code>参数可以设置成<code>left</code>，<code>middle</code>和<code>right</code>三个键。例如：</p>
<p>In [ ]:</p>
<h1 id="按住鼠标左键把鼠标拖拽到100-200位置">按住鼠标左键，把鼠标拖拽到(100, 200)位置</h1>
<p>pyautogui.dragTo(100, 200, button='left')</p>
<h1 id="按住鼠标左键用2秒钟把鼠标拖拽到300-400位置">按住鼠标左键，用2秒钟把鼠标拖拽到(300, 400)位置</h1>
<p>pyautogui.dragTo(300, 400, 2, button='left')</p>
<h1 id="按住鼠标右键用2秒钟把鼠标拖拽到300位置">按住鼠标右键，用2秒钟把鼠标拖拽到(30,0)位置</h1>
<p>pyautogui.dragTo(30, 0, 2, button='right')</p>
<h3 id="54-缓动渐变tween-easing函数">5.4 缓动/渐变（Tween / Easing）函数</h3>
<p>缓动/渐变函数的作用是让光标的移动更炫。如果你不需要用到的话，你可以忽略这些。</p>
<p>缓动/渐变函数可以改变光标移动过程的速度和方向。通常鼠标是匀速直线运动，这就是线性缓动/渐变函数。PyAutoGUI有30种缓动/渐变函数，可以通过<code>pyautogui.ease*?</code>查看。其中，<code>pyautogui.easeInQuad()</code>函数可以用于<code>moveTo()</code>，<code>moveRel()</code>，<code>dragTo()</code>和<code>dragRel()</code>函数，光标移动呈现先慢后快的效果，整个过程的时间还是和原来一样。而<code>pyautogui.easeOutQuad</code>函数的效果相反：光标开始移动很快，然后慢慢减速。<code>pyautogui.easeOutElastic</code>是弹簧效果，首先越过终点，然后再反弹回来。例如：</p>
<p>In [ ]:</p>
<h1 id="开始很慢不断加速">开始很慢，不断加速</h1>
<p>pyautogui.moveTo(100, 100, 2, pyautogui.easeInQuad)</p>
<h1 id="开始很快不断减速">开始很快，不断减速</h1>
<p>pyautogui.moveTo(100, 100, 2, pyautogui.easeOutQuad)</p>
<h1 id="开始和结束都快中间比较慢">开始和结束都快，中间比较慢</h1>
<p>pyautogui.moveTo(100, 100, 2, pyautogui.easeInOutQuad)</p>
<h1 id="一步一徘徊前进">一步一徘徊前进</h1>
<p>pyautogui.moveTo(100, 100, 2, pyautogui.easeInBounce)</p>
<h1 id="徘徊幅度更大甚至超过起点和终点">徘徊幅度更大，甚至超过起点和终点</h1>
<p>pyautogui.moveTo(100, 100, 2, pyautogui.easeInElastic)</p>
<p>这些效果函数是模仿Al Sweigart的<a href="https://github.com/asweigart/pytweening">PyTweening</a>模块，可以直接使用，不需要额外安装。</p>
<p>如果你想创建自己的效果，也可以定义一个函数，其参数是(0.0,1.0)，表示起点和终点，返回值是介于[0.0,1.0]之间的数。</p>
<h3 id="55-鼠标单击">5.5 鼠标单击</h3>
<p><code>click()</code>函数模拟单击鼠标左键一次的行为。例如：</p>
<p>In [ ]:</p>
<p>pyautogui.click()</p>
<p>如果单机之前要先移动，可以把目标的XY坐标值传入函数：</p>
<p>In [ ]:</p>
<h1 id="先移动到100-200再单击">先移动到(100, 200)再单击</h1>
<p>pyautogui.click(x=100, y=200, duration=2)</p>
<p>可以通过<code>button</code>参数设置<code>left</code>，<code>middle</code>和<code>right</code>三个键。例如：</p>
<p>In [ ]:</p>
<p>pyautogui.click(button='right')</p>
<p>要做多次单击可以设置<code>clicks</code>参数，还有<code>interval</code>参数可以设置每次单击之间的时间间隔。例如：</p>
<p>In [ ]:</p>
<h1 id="双击左键">双击左键</h1>
<p>pyautogui.click(clicks=2)</p>
<h1 id="两次单击之间停留025秒">两次单击之间停留0.25秒</h1>
<p>pyautogui.click(clicks=2, interval=0.25)</p>
<h1 id="三击右键">三击右键</h1>
<p>pyautogui.click(button='right', clicks=2, interval=0.25)</p>
<p>为了操作方便，PyAutoGUI提供了<code>doubleClick()</code>，<code>tripleClick()</code>和<code>rightClick()</code>来实现双击、三击和右击操作。</p>
<h3 id="56-鼠标按下和松开函数">5.6 鼠标按下和松开函数</h3>
<p><code>mouseDown()</code>和<code>mouseUp()</code>函数可以实现鼠标按下和鼠标松开的操作。两者参数相同，有<code>x</code>，<code>y</code>和<code>button</code>。例如：</p>
<p>In [ ]:</p>
<h1 id="鼠标左键按下再松开">鼠标左键按下再松开</h1>
<p>pyautogui.mouseDown(); pyautogui.mouseUp()</p>
<h1 id="按下鼠标右键">按下鼠标右键</h1>
<p>pyautogui.mouseDown(button='right')</p>
<h1 id="移动到100-200位置然后松开鼠标右键">移动到(100, 200)位置，然后松开鼠标右键</h1>
<p>pyautogui.mouseUp(button='right', x=100, y=200)</p>
<h3 id="57-滚轮滚动函数">5.7 滚轮滚动函数</h3>
<p>鼠标滚轮滚动可以用<code>scroll()</code>函数和<code>clicks</code>次数参数来模拟。不同平台上的<code>clicks</code>次数不太一样。还有<code>x</code>和<code>y</code>参数可以在滚动之前定位到(x, y)位置。例如：</p>
<p>In [ ]:</p>
<h1 id="向上滚动10格">向上滚动10格</h1>
<p>pyautogui.scroll(10)</p>
<h1 id="向下滚动10格">向下滚动10格</h1>
<p>pyautogui.scroll(-10)</p>
<h1 id="移动到100-100位置再向上滚动10格">移动到(100, 100)位置再向上滚动10格</h1>
<p>pyautogui.scroll(10, x=100, y=100)</p>
<p>在OS X和Linux平台上，PyAutoGUI还可以用<code>hscroll()</code>实现水平滚动。例如：</p>
<p>In [ ]:</p>
<h1 id="向右滚动10格">向右滚动10格</h1>
<p>pyautogui.hscroll(10)</p>
<h1 id="向左滚动10格">向左滚动10格</h1>
<p>pyautogui.hscroll(-10)</p>
<p><code>scroll()</code>函数是<code>vscroll()</code>的一个包装（<code>wrapper</code>），执行竖直滚动。</p>
<h3 id="6-键盘控制函数">6 键盘控制函数</h3>
<h3 id="61-typewrite输入函数">6.1 <code>typewrite()</code>输入函数</h3>
<p>键盘控制的主要函数就是<code>typewrite()</code>。这个函数可以实现字符输入。要在两次输入间增加时间间隔，可以用<code>interval</code>参数。例如：</p>
<p>In [ ]:</p>
<h1 id="输入hello-world">输入Hello world!</h1>
<p>pyautogui.typewrite('Hello world!')</p>
<h1 id="每次输入间隔025秒输入hello-world">每次输入间隔0.25秒，输入Hello world!</h1>
<p>pyautogui.typewrite('Hello world!', interval=0.25)</p>
<p><code>typewrite()</code>函数只能用于单个字符键，不能按SHITF和F1这些功能键。</p>
<h3 id="62-presskeydown和keyup函数">6.2 <code>press()</code>，<code>keyDown()</code>和<code>keyUp()</code>函数</h3>
<p>要按那些功能键，可以用<code>press()</code>函数把<code>pyautogui.KEYBOARD_KEYS</code>里面按键对应的字符串输入进去。例如：</p>
<p>In [ ]:</p>
<h1 id="enter键">ENTER键</h1>
<p>pyautogui.press('enter')</p>
<h1 id="f1键">F1键</h1>
<p>pyautogui.press('f1')</p>
<h1 id="左方向键">左方向键</h1>
<p>pyautogui.press('left')</p>
<p><code>press()</code>函数其实是<code>keyDown()</code>和<code>keyUp()</code>函数的包装，模拟的按下然后松开两个动作。这两个函数可以单独调用。例如，按下<code>shift</code>键的同时按3次左方向键：</p>
<p>In [ ]:</p>
<h1 id="按下shift键">按下<code>shift</code>键</h1>
<p>pyautogui.keyDown('shift')
pyautogui.press('left')
pyautogui.press('left')
pyautogui.press('left')</p>
<h1 id="松开shift键">松开<code>shift</code>键</h1>
<p>pyautogui.keyUp('shift')</p>
<p>和<code>typewrite()</code>函数一样，可以用数组把一组键传入<code>press()</code>。例如：</p>
<p>In [ ]:</p>
<p>pyautogui.press(['left', 'left', 'left'])</p>
<h3 id="63-hotkey函数">6.3 <code>hotkey()</code>函数</h3>
<p>为了更高效的输入热键，PyAutoGUI提供了<code>hotkey()</code>函数来绑定若干按键：</p>
<p>In [ ]:</p>
<p>pyautogui.hotkey('ctrl', 'shift', 'ese')</p>
<p>等价于：</p>
<p>In [ ]:</p>
<p>pyautogui.keyDown('ctrl')
pyautogui.keyDown('shift')
pyautogui.keyDown('esc')
pyautogui.keyUp('esc')
pyautogui.keyUp('shift')
pyautogui.keyUp('ctrl')</p>
<h3 id="64-keyboard_keys">6.4 KEYBOARD_KEYS</h3>
<p>下面就是<code>press()</code>，<code>keyDown()</code>，<code>keyUp()</code>和<code>hotkey()</code>函数可以输入的按键名称：</p>
<p>In [ ]:</p>
<p>print(pyautogui.KEYBOARD_KEYS)</p>
<p>['\t', '\n', '\r', ' ', '!', '&quot;', '#', '$', '%', '&amp;', &quot;'&quot;, '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '&lt;', '=', '&gt;', '?', '@', '[', '\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', 'accept', 'add', 'alt', 'altleft', 'altright', 'apps', 'backspace', 'browserback', 'browserfavorites', 'browserforward', 'browserhome', 'browserrefresh', 'browsersearch', 'browserstop', 'capslock', 'clear', 'convert', 'ctrl', 'ctrlleft', 'ctrlright', 'decimal', 'del', 'delete', 'divide', 'down', 'end', 'enter', 'esc', 'escape', 'execute', 'f1', 'f10', 'f11', 'f12', 'f13', 'f14', 'f15', 'f16', 'f17', 'f18', 'f19', 'f2', 'f20', 'f21', 'f22', 'f23', 'f24', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'final', 'fn', 'hanguel', 'hangul', 'hanja', 'help', 'home', 'insert', 'junja', 'kana', 'kanji', 'launchapp1', 'launchapp2', 'launchmail', 'launchmediaselect', 'left', 'modechange', 'multiply', 'nexttrack', 'nonconvert', 'num0', 'num1', 'num2', 'num3', 'num4', 'num5', 'num6', 'num7', 'num8', 'num9', 'numlock', 'pagedown', 'pageup', 'pause', 'pgdn', 'pgup', 'playpause', 'prevtrack', 'print', 'printscreen', 'prntscrn', 'prtsc', 'prtscr', 'return', 'right', 'scrolllock', 'select', 'separator', 'shift', 'shiftleft', 'shiftright', 'sleep', 'stop', 'subtract', 'tab', 'up', 'volumedown', 'volumemute', 'volumeup', 'win', 'winleft', 'winright', 'yen', 'command', 'option', 'optionleft', 'optionright']</p>
<h3 id="7-消息弹窗函数">7 消息弹窗函数</h3>
<p>PyAutoGUI通过Tkinter实现了4种纯Python的消息弹窗函数，和JavaScript类似。</p>
<h3 id="71-alert函数">7.1 alert()函数</h3>
<p>In [ ]:</p>
<p>pyautogui.alert(text='', title='', button='OK')</p>
<p>Out[ ]:</p>
<p>'OK'</p>
<p>显示一个简单的带文字和OK按钮的消息弹窗。用户点击后返回<code>button</code>的文字。</p>
<h3 id="72-the-confirm-function">7.2 The confirm() Function</h3>
<p>In [ ]:</p>
<h1 id="ok和cancel按钮的消息弹窗">OK和Cancel按钮的消息弹窗</h1>
<p>pyautogui.confirm(text='', title='', buttons=['OK', 'Cancel'])</p>
<h1 id="10个按键0-9的消息弹窗">10个按键0-9的消息弹窗</h1>
<p>pyautogui.confirm(text='', title='', buttons=range(10))</p>
<p>Out[ ]:</p>
<p>'0'</p>
<p>显示一个简单的带文字、OK和Cancel按钮的消息弹窗，用户点击后返回被点击button的文字，支持自定义数字、文字的列表。</p>
<h3 id="73-the-prompt-function">7.3 The prompt() Function</h3>
<p>In [ ]:</p>
<p>pyautogui.prompt(text='', title='' , default='')</p>
<p>可以输入的消息弹窗，带OK和Cancel按钮。用户点击OK按钮返回输入的文字，点击Cancel按钮返回<code>None</code>。</p>
<h3 id="74-the-password-function">7.4 The password() Function</h3>
<p>In [ ]:</p>
<p>pyautogui.password(text='', title='', default='', mask='*')</p>
<p>样式同<code>prompt()</code>，用于输入密码，消息用<code>*</code>表示。带OK和Cancel按钮。用户点击OK按钮返回输入的文字，点击Cancel按钮返回<code>None</code>。</p>
<h3 id="8-截屏函数">8 截屏函数</h3>
<p>PyAutoGUI可以截屏并保存为图片文件，然后定位这些截屏在屏幕上的位置。与<a href="http://www.sikuli.org/">sikuli</a>类似，把屏幕上的按键截取下来，然后定位，就可以执行点击等操作了。</p>
<p>截屏功能需要安装Pillow模块。OS X用<code>screencapture</code>命令，是系统自带的。Linux用户用<code>scrot</code>命令，可以通过<code>sudo apt-get install scrot</code>安装。</p>
<h3 id="81-ubuntu注意事项">8.1 Ubuntu注意事项</h3>
<p>由于Ubuntu上安装Pillow时缺少PNG和JPEG依赖，所以安装比较复杂，具体可以看<a href="http://conda.pydata.org/miniconda.html">Ubuntu论坛</a>。不过用<a href="http://conda.pydata.org/miniconda.html">miniconda</a>可以解决这些问题，如果Ubuntu或Mint上安装了miniconda，可以直接<code>conda install pillow</code>来安装。</p>
<h3 id="82-screenshot函数">8.2 <code>screenshot()</code>函数</h3>
<p><code>screenshot()</code>函数会返回<code>Image</code>对象（参考<a href="http://python-pillow.github.io/">Pillow或PIL模块文档</a>），也可以设置文件名：</p>
<p>In [ ]:</p>
<p>import pyautogui
im1 = pyautogui.screenshot()
im2 = pyautogui.screenshot('my_screenshot.png')</p>
<p>在一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1920</mn><mo>×</mo><mn>1080</mn></mrow><annotation encoding="application/x-tex">1920 \times 1080</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">8</span><span class="mord">0</span></span></span></span>的屏幕上，<code>screenshot()</code>函数要消耗100微秒——不快也不慢。</p>
<p>如果你不需要截取整个屏幕，还有一个可选的<code>region</code>参数。你可以把截取区域的左上角XY坐标值和宽度、高度传入截取。</p>
<p>In [ ]:</p>
<p>im = pyautogui.screenshot(region=(0, 0, 300 ,400))</p>
<h3 id="83-定位函数">8.3 定位函数</h3>
<p>可以定位截图在屏幕上的坐标位置。比如，你需要在计算器里输入：<img src="https://muxuezi.github.io/posts/pyautogui/calc.png" alt=""></p>
<p>如果你不知道按钮的位置，就不能用<code>moveTo()</code>定位和<code>click()</code>点击。而且每次计算器的位置可能会变化，这时即使有来坐标也不好用了。但是如果你有要点击按钮的截图，比如数字<code>7</code>：<img src="https://muxuezi.github.io/posts/pyautogui/calc7key.png" alt=""></p>
<p>你可以调用<code>pyautogui.locateOnScreen('calc7key.png')</code>函数来获得<code>7</code>的屏幕坐标。返回的是一个元组<code>(top, left, width, height)</code>。这个元组可以用<code>pyautogui.center()</code>函数来获取截图屏幕的中心坐标。如果截图没找到，<code>pyautogui.locateOnScreen()</code>函数返回<code>None</code>：</p>
<p>In [ ]:</p>
<p>import pyautogui
button7location = pyautogui.locateOnScreen('pyautogui/calc7key.png')
button7location</p>
<p>Out[ ]:</p>
<p>(1226, 546, 29, 28)</p>
<p>In [ ]:</p>
<p>button7x, button7y = pyautogui.center(button7location)
button7x, button7y</p>
<p>Out[ ]:</p>
<p>(1240, 560)</p>
<p>In [ ]:</p>
<p>pyautogui.click(button7x, button7y)</p>
<p><code>locateCenterOnScreen()</code>等价于上面的前两布操作，直接获得截屏屏幕中心坐标：</p>
<p>In [ ]:</p>
<p>import pyautogui
x, y = pyautogui.locateCenterOnScreen('pyautogui/calc7key.png')
pyautogui.click(x, y)</p>
<p>在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1920</mn><mo>×</mo><mn>1080</mn></mrow><annotation encoding="application/x-tex">1920 \times 1080</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">8</span><span class="mord">0</span></span></span></span>的屏幕上，定位函数需要1~2秒时间。对视频游戏（LOL、DOTA）来说就太慢了，但是上班干活还是绰绰有余。</p>
<p>还是几个定位函数。都是从左上角原点开始向右向下搜索截图位置：</p>
<ul>
<li>locateOnScreen(image, grayscale=False)：返回找到的第一个截图<code>Image</code>对象在屏幕上的坐标<code>(left, top, width, height)</code>，如果没找到返回<code>None</code></li>
<li>locateCenterOnScreen(image, grayscale=False)：返回找到的第一个截图<code>Image</code>对象在屏幕上的中心坐标<code>(x, y)</code>，如果没找到返回<code>None</code></li>
<li>locateAllOnScreen(image, grayscale=False)：返回找到的所有相同截图<code>Image</code>对象在屏幕上的坐标<code>(left, top, width, height)</code>的生成器</li>
<li>locate(needleImage, haystackImage, grayscale=False)：返回找到的第一个截图<code>Image</code>对象在<code>haystackImage</code>里面的坐标<code>(left, top, width, height)</code>，如果没找到返回<code>None</code></li>
<li>locateAll(needleImage, haystackImage, grayscale=False)：返回找到的所有相同截图<code>Image</code>对象在<code>haystackImage</code>里面的坐标<code>(left, top, width, height)</code>的生成器</li>
</ul>
<p>两个<code>locateAll*</code>函数都可以用<code>for</code>循环和<code>list()</code>输出：</p>
<p>In [ ]:</p>
<p>for pos in pyautogui.locateAllOnScreen('pyautogui/calc7key.png'):
print(pos)</p>
<p>(1227, 546, 29, 28)</p>
<p>In [ ]:</p>
<p>list(pyautogui.locateAllOnScreen('pyautogui/calc7key.png'))</p>
<p>Out[ ]:</p>
<p>[(1227, 546, 29, 28)]</p>
<h4 id="831-灰度值匹配">8.3.1 灰度值匹配</h4>
<p>可以把<code>grayscale</code>参数设置为<code>True</code>来加速定位（大约提升30%），默认为<code>False</code>。这种去色（desaturate）方法可以加速定位，但是也可能导致假阳性（false-positive）匹配：</p>
<p>In [ ]:</p>
<p>import pyautogui
button7location = pyautogui.locateOnScreen('pyautogui/calc7key.png', grayscale=True)
button7location</p>
<p>Out[ ]:</p>
<p>(1227, 546, 29, 28)</p>
<h4 id="832-像素匹配">8.3.2 像素匹配</h4>
<p>要获取截屏某个位置的RGB像素值，可以用<code>Image</code>对象的<code>getpixel()</code>方法：</p>
<p>In [ ]:</p>
<p>import pyautogui
im = pyautogui.screenshot()
im.getpixel((100, 200))</p>
<p>Out[ ]:</p>
<p>(255, 255, 255)</p>
<p>也可以用PyAutoGUI的<code>pixel()</code>函数，是之前调用的包装：</p>
<p>In [ ]:</p>
<p>pyautogui.pixel(100, 200)</p>
<p>Out[ ]:</p>
<p>(255, 255, 255)</p>
<p>如果你只是要检验一下指定位置的像素值，可以用<code>pixelMatchesColor()</code>函数，把X、Y和RGB元组值穿入即可：</p>
<p>In [ ]:</p>
<p>pyautogui.pixelMatchesColor(100, 200, (255, 255, 255))</p>
<p>Out[ ]:</p>
<p>True</p>
<p>In [ ]:</p>
<p>pyautogui.pixelMatchesColor(100, 200, (255, 255, 245))</p>
<p>Out[ ]:</p>
<p>False</p>
<p><code>tolerance</code>参数可以指定红、绿、蓝3种颜色误差范围：</p>
<p>In [ ]:</p>
<p>pyautogui.pixelMatchesColor(100, 200, (255, 255, 245), tolerance=10)</p>
<p>Out[ ]:</p>
<p>True</p>
<p>In [ ]:</p>
<p>pyautogui.pixelMatchesColor(100, 200, (248, 250, 245), tolerance=10)</p>
<p>Out[ ]:</p>
<p>True</p>
<p>In [ ]:</p>
<p>pyautogui.pixelMatchesColor(100, 200, (205, 255, 245), tolerance=10)</p>
<p>Out[ ]:</p>
<p>False</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[3D slicer 机械臂（ROS）]]></title>
        <id>https://blog.bioprinting.site/post/WBh3a3s5z</id>
        <link href="https://blog.bioprinting.site/post/WBh3a3s5z">
        </link>
        <updated>2019-06-02T09:05:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="ismr-2019规划">ISMR 2019规划</h1>
<h2 id=""><a href="https://github.com/rosmed/rosmed.github.io/wiki/ISMR2019#organizers"></a>主办单位</h2>
<ul>
<li>Junichi Tokuda，布莱根妇女医院和哈佛医学院（<a href="mailto:tokuda@bwh.harvard.edu">tokuda@bwh.harvard.edu</a>）</li>
<li>女王大学Tamas Ungi（<a href="mailto:ungi@queensu.ca">ungi@queensu.ca</a>）</li>
<li>马里兰大学Axel Krieger（<a href="mailto:axel@umd.edu">axel@umd.edu</a>）</li>
<li>约翰霍普金斯大学Simon Leonard（<a href="mailto:sleonard@jhu.edu">sleonard@jhu.edu</a>）</li>
</ul>
<h2 id="-2"><a href="https://github.com/rosmed/rosmed.github.io/wiki/ISMR2019#invited-talk"></a>特邀演讲</h2>
<ul>
<li>Junichi Tokuda，博士，布莱根妇女医院</li>
<li>Tamas Ungi，医学博士，女王大学博士，图像引导治疗原型软件</li>
<li>Axel Krieger，马里兰大学自主外科软件系统博士</li>
<li>伍斯特理工学院Gregory Fischer博士</li>
<li>范德比尔特大学博士罗伯特韦伯斯特
<ul>
<li>（演讲者变更）范德比尔特大学Stanley D. Herrell博士</li>
</ul>
</li>
<li>Niguhiko Hata，博士，布莱根妇女医院</li>
</ul>
<h2 id="-3"><a href="https://github.com/rosmed/rosmed.github.io/wiki/ISMR2019#time-table-draft"></a>时间表（草案）</h2>
<ul>
<li>下午1:30 - 1：40：开场白和介绍（Junichi Tokuda）</li>
<li>下午1:40至下午2:30：特邀演讲
<ul>
<li>下午1:40 :( Stanley Herrel）</li>
<li>下午1:50 :( Nobuhiko Hata）</li>
<li>下午2:00 :( Axel Krieger）</li>
<li>下午2:10 :(格雷戈里菲舍尔）</li>
<li>下午2:20 :( Tamas Ungi）</li>
</ul>
</li>
<li>下午2:30 - 下午3:00：教程第1节</li>
<li>下午3:00 - 下午3:30：喝咖啡休息时间</li>
<li>下午3:30 - 下午5:00：教程第2节</li>
</ul>
<h2 id="-4"><a href="https://github.com/rosmed/rosmed.github.io/wiki/ISMR2019#tutorial---workflow"></a>教程 - 工作流程</h2>
<p>请参见<a href="https://dl.dropboxusercontent.com/s/kamqj85tdhrgbgc/ROSIGTLTutorial-ISMR2019.pptx">教程幻灯片</a>。</p>
<p>以下工作流程是草稿。</p>
<ul>
<li>条件
<ul>
<li>切片机工作站
<ul>
<li>请参阅<a href="https://www.slicer.org/wiki/Documentation/4.8/SlicerApplication/HardwareConfiguration">www.slicer.org上的切片机4.8的硬件要求</a></li>
</ul>
</li>
<li>ROS计算机
<ul>
<li>[选项1]原生Linux机器 - 请参考[安装页面]）<a href="http://wiki.ros.org/kinetic/Installation">http://wiki.ros.org/kinetic/Installation</a>）</li>
<li>[选项2] Docker - 在这种情况下，不需要专用的ROS计算机。Docker容器可以在Slicer工作站上运行。</li>
<li>[选项3]可以使用其他虚拟化环境（VMWare，VirtualBox等）。VirtualBox在3D图形方面存在一些性能问题（rviz需要），此时不建议使用。</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://github.com/rosmed/rosmed.github.io/wiki/ROS_Environment">设置ROS环境</a>
<ul>
<li>安装ROS
<ul>
<li>[选项1/3]使用原生Linux或虚拟盒（不推荐）</li>
<li>[选项2]使用Docker</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://github.com/rosmed/rosmed.github.io/wiki/Slicer">设置3D切片器</a>
<ul>
<li>安装扩展（插件）</li>
<li>使用ROS-IGTL-Bridge测试3D Slicer-ROS通信</li>
</ul>
</li>
<li><a href="https://github.com/rosmed/rosmed.github.io/wiki/ROS_Robot">在ROS上设置通用机器人手臂</a>
<ul>
<li>使用rviz在ROS场景中加载机器人和患者模型</li>
<li>使用rviz上的指针功能将患者模型移动到机器人的工作空间中</li>
</ul>
</li>
<li><a href="https://github.com/rosmed/rosmed.github.io/wiki/Slicer_Planning">规划3D切片机</a>
<ul>
<li>加载患者模型</li>
<li>定义目标针轨迹（插入前和插入后）</li>
<li>加载机器人模型</li>
</ul>
</li>
<li><a href="https://github.com/rosmed/rosmed.github.io/wiki/Connecting_Slicer_and_ROS">在Slicer和ROS之间建立连接</a>
<ul>
<li>使用ROS-IGTL-Bridge将3D切片机与ROS连接</li>
<li>检查3D Slicer和ROS上的机器人模型的同步</li>
</ul>
</li>
<li><a href="https://github.com/rosmed/rosmed.github.io/wiki/Registration">注册</a>
<ul>
<li>（切片器）启动Fiducial Registration Wizard</li>
<li>（rviz）手动将末端执行器移动到头骨上的第一个界标</li>
<li>（切片器）记录尖端的当前位置，然后单击ull模型上的相应点</li>
<li>重复前两个步骤</li>
<li>运行地标注册。</li>
<li>将变换应用于机器人</li>
</ul>
</li>
<li><a href="https://github.com/rosmed/rosmed.github.io/wiki/Slicer_Visualization">规划针位置</a>
<ul>
<li>（切片器）设置音量Reslice驱动程序</li>
<li>（切片器）将插入前的末端效应器位置发送到ROS</li>
</ul>
</li>
<li><a href="https://github.com/rosmed/rosmed.github.io/wiki/Execution">执行计划</a>
<ul>
<li>（ROS）将手臂移至原位</li>
<li>（ROS）将手臂移动到插入前的位置</li>
<li>（ROS）将手臂移动到插入后位置</li>
</ul>
</li>
</ul>
<h2 id="-5"><a href="https://github.com/rosmed/rosmed.github.io/wiki/ISMR2019#memos"></a>备忘录</h2>
<ul>
<li>3D切片机教程
<ul>
<li><a href="https://www.slicer.org/wiki/Documentation/4.8/Training">入门教程</a></li>
<li><a href="https://onedrive.live.com/view.aspx?resid=7230D4DEC6058018!29379&amp;ithint=file%2cpptx&amp;authkey=!AL2fpr9tHQTEWNA">脑外科教程</a></li>
</ul>
</li>
<li><a href="https://github.com/rosmed/rosmed.github.io/wiki/VirtualEnvironments">虚拟环境解决方案</a></li>
<li><a href="https://github.com/rosmed/rosmed.github.io/wiki/DockerROS">设置Docker镜像</a></li>
</ul>
<p>关注<a href="https://github.com/openigtlink/ROS-IGTL-Bridge">https://github.com/openigtlink/ROS-IGTL-Bridge</a></p>
<h1 id="ros-igtl桥">ROS-IGTL桥</h1>
<p>作者：Tobias Frank，Junichi Tokuda（布莱根妇女医院）</p>
<p>该ROS-Node提供了一个OpenIGTLink桥，用于与ROS交换数据。它支持发送和接收转换，图像，字符串，PolyData，Points和Pointcloud。有关OpenIGTLink协议的更多信息，请参阅：</p>
<ul>
<li><a href="http://openigtlink.org/">http://openigtlink.org/</a></li>
</ul>
<hr>
<h2 id="-6"><a href="https://github.com/openigtlink/ROS-IGTL-Bridge#build-instruction"></a>构建指令</h2>
<p>测试了以下步骤：</p>
<ul>
<li>Ubuntu 14.04 + ROS Indigo</li>
<li>Ubuntu 16.04 + ROS Kinetic Kame</li>
</ul>
<p>首先，在本地计算机中安装OpenIGTLink。有关详细说明，请访问<a href="http://openigtlink.org/">http://openigtlink.org/</a>。在以下指令中，我们假设OpenIGTLink库的构建目录位于：〜/ igtl / OpenIGTLink-build</p>
<p><code>$ cd <your OpenIGTLink directory>
$ git clone https://github.com/openigtlink/OpenIGTLink.git
$ mkdir OpenIGTLink-build
$ cd OpenIGTLink-build
$ cmake -DBUILD_SHARED_LIBS:BOOL=ON ../OpenIGTLink
$ make</code></p>
<p>安装<a href="http://wiki.ros.org/">ROS</a>并按照标准<a href="http://wiki.ros.org/catkin/Tutorials/create_a_workspace">ROS说明</a>创建ROS工作区（如有必要）。</p>
<p><code>$ mkdir -p ~/catkin_ws/src
$ cd ~/catkin_ws
$ catkin_make
$ source devel/setup.bash</code></p>
<p>ROS-IGTL-Bridge需要VTK。您可以使用apt-get安装它：</p>
<p><code>$ sudo apt-get install libvtk6-dev</code></p>
<p>然后从GitHub下载ros_igtl_bridge包：</p>
<p><code>$ cd ~/catkin_ws/src
$ git clone https://github.com/openigtlink/ROS-IGTL-Bridge</code></p>
<p>并在工作区目录中执行catkin_make：</p>
<p><code>$ cd ~/catkin_ws/
$ catkin_make --cmake-args -DOpenIGTLink_DIR:PATH=<your OpenIGTLink directory>/OpenIGTLink-build</code></p>
<p>要运行网桥，请键入：</p>
<p><code>$ roslaunch ros_igtl_bridge bridge.launch</code></p>
<p>如果已设置桥接，则可以启动与[3D Slicer]（<a href="https://www.slicer.org/">https://www.slicer.org/</a>）进行通信的测试程序：</p>
<p><code>$ roslaunch ros_igtl_bridge test.launch</code></p>
<p>可以编辑启动文件并在文件中设置IP和端口。通过调整参数RIB_type将节点作为服务器或客户端运行。打开文件并取消注释行：</p>
<p><code>$ <!--param name="RIB_server_ip" value="111.111.111.111" type="str"/-->
$ <!--param name="RIB_port" value="18944" type="int"/-->
$ <!--param name="RIB_type" value="client" type="str"/--></code></p>
<p>该节点可以作为服务器或客户端运行。如果您执行了测试程序，该节点将发送带有随机翻译的“ROS_IGTL_Test_Transform”，随机的“ROS_IGTL_Test_Point”，包含20个点的随机“ROS_IGTL_Test_Pointcloud”，“ROS_IGTL_Test_String”和“ROS_IGTL_Test_PolyData”，这是一个渲染模型。 3D Slicer MRHead样本数据。从3D切片器接收的任何数据都由桥节点发布到ROS主题并由测试节点显示。</p>
<h2 id="-7"><a href="https://github.com/openigtlink/ROS-IGTL-Bridge#references"></a>参考</h2>
<ol>
<li>Frank T，Krieger A，Leonard S，Patel NA，Tokuda J. ROS-IGTL-Bridge：一种开放式网络接口，用于使用ROS环境进行图像引导治疗。Int J Comput Assist Radiol Surg。2017年5月31日doi：10.1007 / s11548-017-1618-1。PubMed PMID：<a href="https://www.ncbi.nlm.nih.gov/pubmed/?term=28567563">28567563</a>。</li>
</ol>
<h2 id="docker-image">Docker Image</h2>
<p>由Christian Henkel开发的基础Docker映像（vnc-ros-kinetic-full）源自<a href="https://hub.docker.com/r/ct2034/vnc-ros-kinetic-full/">Docker Hub存储库</a>。此Docker镜像附带：</p>
<ul>
<li>Ubuntu 16.04</li>
<li>ROS动力学</li>
<li>HTML5 VNC服务器</li>
</ul>
<p>我们的Docker镜像包含以下附加包：</p>
<ul>
<li>ROS-工业</li>
<li>ROS通用机器人包</li>
<li>ROS MoveIt！包</li>
<li>OpenIGTLink</li>
<li>ROS-IGTL桥</li>
</ul>
<p>我们的Dockerfile可以在<a href="https://github.com/rosmed/docker-ros-igtl">GitHub上获得</a>，它的图像在<a href="https://cloud.docker.com/u/rosmed/repository/docker/rosmed/docker-ros-igtl">Docker Hub上发布</a>。</p>
<h2 id="-8"><a href="https://github.com/rosmed/rosmed.github.io/wiki/DockerROS#building-docker-image-not-needed"></a>构建Docker镜像（不需要）</h2>
<p>要使用修改后的Dockerfile构建Docker镜像，请运行以下命令：</p>
<p><code>$ cd <working directory>
$ git clone https://github.com/rosmed/docker-ros-igtl
$ cd docker-ros-igtl
$ docker build -t docker-ros-igtl .</code></p>
<h2 id="-9"><a href="https://github.com/rosmed/rosmed.github.io/wiki/DockerROS#running-docker-image"></a>运行Docker镜像</h2>
<p>要执行docker镜像，请调用以下命令：</p>
<p><code>$ docker pull docker pull rosmed/docker-ros-igtl
$ docker run -it --rm -p 6080:80 rosmed/docker-ros-igtl</code></p>
<p>在此示例中，docker容器上的Web端口将映射到主机上的端口6080。' - rm'选项将在终止时删除容器。</p>
<h1 id="connecting_slicer_and_ros">Connecting_Slicer_and_ROS</h1>
<p>Junichi Tokuda编辑了这个页面 on 21 Mar · <a href="https://github.com/rosmed/rosmed.github.io/wiki/Connecting_Slicer_and_ROS/_history">3次修订</a></p>
<h1 id="-10"><a href="https://github.com/rosmed/rosmed.github.io/wiki/Connecting_Slicer_and_ROS#connecting-3d-slicer-with-ros"></a>连接3D切片机与ROS</h1>
<p>确保以下组件正在运行：</p>
<ul>
<li>ROS计算机
<ul>
<li>rviz上的通用机器人</li>
<li>IGTL出口商</li>
<li>ROS-IGTL桥</li>
</ul>
</li>
<li>切片机工作站
<ul>
<li>3D切片机</li>
</ul>
</li>
</ul>
<p>现在我们连接3D Slicer和来自OpenIGTLinkIF模块的ROS，正如我们在<a href="https://github.com/rosmed/rosmed.github.io/wiki/Slicer">上一步中</a>测试<a href="https://github.com/rosmed/rosmed.github.io/wiki/Slicer">的那样</a>。打开OpenIGTLinkIF模块（模块菜单 - &gt;“IGT” - &gt;“OpenIGTLinkIF”）。然后单击“连接器”列表下的“+”按钮创建一个新节点，并从“属性”部分进行配置，如下所示：</p>
<ul>
<li>名称：“IGTLConnector”（默认）</li>
<li>键入：“客户端”（默认）</li>
<li>状态：未选中（默认）</li>
<li>MRMLNodeAlgorithm：保持未选中状态</li>
<li>主机名：localhost（如果使用Docker）或ROS机器的IP（用于非Docker环境）</li>
<li>端口：28944（如果Docker与“-p 28944：18944”选项一起使用）或18944（非Docker环境的默认值）</li>
</ul>
<p>配置连接器后，单击“活动”复选框。如果3D Slicer成功连接到ROS-IGTL-Bridge，则OpenIGTLinkIF的连接器列表上的状态字段将显示为“ON”。</p>
<h1 id="加载mr图像和患者模型">加载MR图像和患者模型</h1>
<p>首先，下载<a href="http://bit.ly/2UZ8OaR">ISMR19的切片器场景</a>。这个场景包含：</p>
<ul>
<li>场景描述文件（Scene-ISMR19.mrml）</li>
<li>患者的MR图像（MRI.nrrd）</li>
<li>患者的3D模型（SkullDrilled1.stl）</li>
<li>机器人链接的3D模型（* .stl除了SkullDrilled1.stl）</li>
<li>链接的转换矩阵（* .h5）</li>
</ul>
<p>解压缩zip文件。在Linux / Mac上的终端上，可以通过以下方式完成：</p>
<p><code>$ unzip SlicerScene-ISMR19.zip
Archive:  SlicerScene-ISMR19.zip
inflating: SlicerScene/MRI.nrrd<br>
inflating: SlicerScene/Scene-ISMR19.mrml<br>
inflating: SlicerScene/Scene-ISMR19.png<br>
inflating: SlicerScene/SkullDrilled1_mm.stl<br>
inflating: SlicerScene/base_mm.stl<br>
inflating: SlicerScene/forearm_link.h5<br>
inflating: SlicerScene/forearm_mm.stl<br>
inflating: SlicerScene/needle.h5<br>
inflating: SlicerScene/needle_holder.h5<br>
inflating: SlicerScene/needle_holder_mm.stl<br>
inflating: SlicerScene/shoulder_link.h5<br>
inflating: SlicerScene/shoulder_mm.stl<br>
inflating: SlicerScene/tool0.h5<br>
inflating: SlicerScene/upper_arm_link.h5<br>
inflating: SlicerScene/upperarm_mm.stl<br>
inflating: SlicerScene/wrist1_mm.stl<br>
inflating: SlicerScene/wrist2_mm.stl<br>
inflating: SlicerScene/wrist3_mm.stl<br>
inflating: SlicerScene/wrist_1_link.h5<br>
inflating: SlicerScene/wrist_2_link.h5<br>
inflating: SlicerScene/wrist_3_link.h5</code></p>
<p>请注意，STL格式不包含单位信息。虽然文件应该以适当的比例加载到3D Slicer上，但它们可能无法在其他环境中运行。</p>
<p>提取完所有文件后，我们从3D Slicer加载场景，如下所示：</p>
<ul>
<li>打开“添加数据”对话框（“文件” - &gt;“添加数据”）。</li>
<li>单击“选择要添加的文件”按钮。</li>
<li>从“打开”对话框中选择“Scene-ISMR19.mrml”。</li>
<li>单击“打开”。文件名应出现在“选择要添加的文件”对话框中。单击“确定”后，3D切片器开始将文件加载到场景中。</li>
</ul>
<p>如果文件成功加载，您应该能够在红色/黄色/绿色查看器上看到MR图像，并在3D查看器上看到头骨和机器人的模型。头骨相对于机器人的位置是不现实的，但这是因为它们尚未注册（或校准）。我们将在本教程的后面注册它们。</p>
<h1 id="-11"><a href="https://github.com/rosmed/rosmed.github.io/wiki/Slicer_Planning#planning-needle-placement"></a>规划针位置</h1>
<p>我们通过定义1）目标点和2）皮肤上的针入口点来计划针放置轨迹。</p>
<p>首先，我们使头骨模型的部分在3轴平面上可见，如下所示：</p>
<ul>
<li>打开“模型”模块（“模块”菜单 - &gt;“模型”）</li>
<li>从模型列表中选择“SkullDrilled1_mm”。</li>
<li>在“切片显示”框中，选中“可见”。现在您应该看到头骨模型的部分覆盖在MR图像上。</li>
</ul>
<p>要定义条目和目标点：</p>
<ul>
<li>单击工具栏中的“创建并放置基准”按钮。</li>
<li>单击肿瘤中心作为目标点。（基准“F-1”应出现在MR图像上）</li>
<li>单击头骨上的孔的中心作为入口点。（基准“F-2”应出现在MR图像上）</li>
<li>从模块菜单中打开“Markups”模块。</li>
<li>下拉列表菜单，然后选择“重命名当前MarkupsFiducials”。</li>
<li>在弹出窗口中，键入“Plan”（区分大小写）作为新名称，然后单击“确定”。</li>
<li>通过单击名称（即“F-1”和“F-2”）将点的名称从“F-1”和“F-2”更改为“目标”和“条目”，然后输入新的名称名。名称区分大小写，因为它们将被转移到ROS并用于识别点。</li>
</ul>
<h1 id="ros_robot">ROS_Robot</h1>
<p>Simon Leonard编辑了此页面 on 29 Mar · <a href="https://github.com/rosmed/rosmed.github.io/wiki/ROS_Robot/_history">19次修订</a></p>
<h1 id="-12"><a href="https://github.com/rosmed/rosmed.github.io/wiki/ROS_Robot#installing-ros-packages"></a>安装ROS包</h1>
<p>（如果使用本教程中提供的Docker镜像设置ROS环境，则可以跳过此步骤。）</p>
<p>在ROS计算机上，我们打开一个终端并将两个ROS包复制到katkin工作区：</p>
<p><code>cd ~/catkin_ws/src
git clone https://github.com/rosmed/ismr19_description
git clone https://github.com/rosmed/ismr19_moveit
git clone https://github.com/rosmed/ismr19_control</code></p>
<p>此外，我们还复制了IGTL Exporter，它通过ROS-IGTL-Bridge将机器人链接的转换流式传输到3D Slicer。</p>
<p><code>cd ~/catkin_ws/src
git clone https://github.com/tokjun/ros_bx_robot_bridge</code></p>
<p>然后，运行catkin_make</p>
<p><code>cd ~/catkin_ws
catkin_make
source devel/setup.bash</code></p>
<h1 id="-13"><a href="https://github.com/rosmed/rosmed.github.io/wiki/ROS_Robot#launching-the-ros-packages"></a>启动ROS包</h1>
<p>！以下步骤将被修改 - 不确定我们是否将使用demo.launch !!</p>
<p>我们使用以下命令在rviz上使用自定义针头hodler启动通用机器人：</p>
<p><code>roslaunch ismr19_moveit demo.launch</code></p>
<h1 id="-14"><a href="https://github.com/rosmed/rosmed.github.io/wiki/ROS_Robot#launching-igtl-exporter"></a>启动IGTL Exporter</h1>
<p>要启动IGTL导出器，请打开另一个终端并运行以下命令：</p>
<p><code>cd ~/catkin_ws
source devel/setup.bash
rosrun bx_robot_bridge igtl_exporter.py</code></p>
<h1 id="-15"><a href="https://github.com/rosmed/rosmed.github.io/wiki/ROS_Robot#loading-patient-model"></a>加载患者模型</h1>
<p>我们将加载患者的表面模型。首先，我们下载模型：</p>
<p><code>cd ~
mkdir models
cd models
wget -O ismr19.scene https://bit.ly/2OpSdKM</code></p>
<p>从rviz中，打开“MotionPlanning”框中的“Scene Objects”选项卡，单击“Current Scene Objects”部分右下方区域的“Import From Text”按钮，选择下载的文件（“ismr19.scene”） ）在“导入场景几何体”对话框中，单击“打开”按钮。头骨模型出现在3D查看器上。</p>
<p>看到头骨后，单击“发布场景”按钮。</p>
<h1 id="切片机">切片机</h1>
<p>Simon Leonard编辑了此页面 on 29 Mar · <a href="https://github.com/rosmed/rosmed.github.io/wiki/Slicer/_history">19次修订</a></p>
<h1 id="-16"><a href="https://github.com/rosmed/rosmed.github.io/wiki/Slicer#installing-3d-slicer-and-extensions"></a>安装3D切片器和扩展</h1>
<p>在本教程中，我们将使用3D Slicer版本4.8.1二进制文件可从以下链接获得：</p>
<ul>
<li><a href="http://slicer.kitware.com/midas3/download/item/330417/Slicer-4.8.1-linux-amd64.tar.gz">适用于Linux的切片器4.8.1（Intel 64位）</a></li>
<li><a href="http://slicer.kitware.com/midas3/download/item/330418/Slicer-4.8.1-macosx-amd64.dmg">用于macOS的切片器4.8.1（Intel 64位）</a></li>
<li><a href="http://slicer.kitware.com/midas3/download/item/329467/Slicer-4.8.1-win-amd64.exe">适用于Windows的切片器4.8.1（Intel 64位）</a></li>
</ul>
<p>**Mac用户注意事项：**如果首次启动3D Slicer时系统弹出一个窗口警告“Slicer.app无法打开，因为它来自一位身份不明的开发人员”，请点击图标启动Slicer应用程序用鼠标右键（或用Ctrl键单击），然后从下拉菜单中选择“打开”。然后，系统将提示您确认是否正在打开该应用程序。单击“打开”按钮后将启动切片器。</p>
<p>在本教程中，我们不会使用最新版本的3D Slicer（自2019年3月起为4.10.1），因为它仍然存在一些与ROS-IGTL-Bridge之间传输点和多边形数据的问题。</p>
<p>安装并启动3D Slicer后，打开Extension Manager（“查看” - &gt;“Extension Manager”），并安装以下扩展名：</p>
<ul>
<li><strong>SlicerIGT</strong></li>
</ul>
<p>重新启动3D切片器后，您应该会在模块菜单的“IGT”部分下看到扩展中包含的插件模块。</p>
<h1 id="-17"><a href="https://github.com/rosmed/rosmed.github.io/wiki/Slicer#testing-communication-with-ros-using-ros-igtl-bridge"></a>使用ROS-IGTL-Bridge测试与ROS的通信</h1>
<p>首先，我们从Linux上的终端（使用ROS）启动roscore：</p>
<p><code>roscore</code></p>
<p>然后我们启动了ROS-IGTL-Bridge。打开另一个终端，然后运行以下命令：</p>
<p><code>cd ~/catkin_ws
source devel/setup.bash
roslaunch ros_igtl_bridge bridge.launch
..
[ROS-IGTL-Bridge] Please type &lt;1&gt; or &lt;2&gt; to run node as OpenIGTLink client or server
1 : Server
2 : Client</code></p>
<p>终端将提示选择类型（服务器或客户端），然后选择主机信息（两种情况下的端口号，如果网桥作为服务器启动，则为IP）。在本教程中，我们将桥接器作为服务器运行并使用端口18944.还可以编辑启动文件并在文件中设置IP和端口。通过调整参数RIB_type将节点作为服务器或客户端运行。打开文件并取消注释行：</p>
<p><code>$ <!--param name="RIB_server_ip" value="111.111.111.111" type="str"/-->
$ <!--param name="RIB_port" value="18944" type="int"/-->
$ <!--param name="RIB_type" value="client" type="str"/--></code></p>
<p>桥接器准备就绪后，打开3D Slicer（如果尚未打开），打开OpenIGTLinkIF模块（模块菜单 - &gt;“IGT” - &gt;“OpenIGTLinkIF”）。然后单击“连接器”列表下的“+”按钮创建一个新节点，并从“属性”部分进行配置，如下所示：</p>
<ul>
<li>名称：“IGTLConnector”（默认）</li>
<li>键入：“客户端”（默认）</li>
<li>状态：未选中（默认）</li>
<li>MRMLNodeAlgorithm：保持未选中状态</li>
<li>主机名：localhost（如果使用Docker）或ROS机器的IP（用于非Docker环境）</li>
<li>端口：28944（如果Docker与“-p 28944：18944”选项一起使用）或18944（非Docker环境的默认值）</li>
</ul>
<p>配置连接器后，单击“活动”复选框。如果3D Slicer成功连接到ROS-IGTL-Bridge，则OpenIGTLinkIF的连接器列表上的状态字段将显示为“ON”。</p>
<p>在Linux（使用ROS）上打开一个新终端，然后运行以下命令：</p>
<p><code>cd ~/catkin_ws
source devel/setup.bash
roslaunch ros_igtl_bridge test.launch</code></p>
<p>测试节点发送带有随机翻译的“ROS_IGTL_Test_Transform”，随机的“ROS_IGTL_Test_Point”，包括20个点的随机“ROS_IGTL_Test_Pointcloud”，“ROS_IGTL_Test_String”和“ROS_IGTL_Test_PolyData”。您可以在OpenIGTLinkIF模块的“I / O配置”中确认它们。（确保展开“场景” - &gt;“IGTLConnector1” - &gt;“IN”）。</p>
<p>这些数据将显示在3D Slicer上。在3D Slicer显示患者的表面模型之前，可能需要几秒到一分钟。</p>
<p>确认桥接器正常工作后，通过取消选中“Active”复选框来断开3D Slicer。在3D Slicer上连接状态变为“OFF”后，按终端上的Ctrl-C停止桥接和测试节点。关闭3D切片器上的场景（“文件” - &gt;“关闭场景”）或关闭3D切片器应用程序。</p>
<h1 id="ros_environment">ROS_Environment</h1>
<p>Simon Leonard编辑了此页面 3月29日 · <a href="https://github.com/rosmed/rosmed.github.io/wiki/ROS_Environment/_history">16次修订</a></p>
<h1 id="-18"><a href="https://github.com/rosmed/rosmed.github.io/wiki/ROS_Environment#setting-up-ros-environment-for-tutorial"></a>为教程设置ROS环境</h1>
<h2 id="-19"><a href="https://github.com/rosmed/rosmed.github.io/wiki/ROS_Environment#prerequisite"></a>条件</h2>
<p>在本教程中，我们将使用ROS Kinetic，它支持Wily（Ubuntu 15.10），Xenial（Ubuntu 16.04）和Jessie（Debian 8）用于Debian。请参阅<a href="http://wiki.ros.org/kinetic/Installation/Ubuntu">安装页面</a>了解详细信</p>
<h2 id="-20"><a href="https://github.com/rosmed/rosmed.github.io/wiki/ROS_Environment#option-1-installing-ros-on-dedicated-ros-computer"></a>[选项1]在专用ROS计算机上安装ROS</h2>
<p>请按照<a href="http://wiki.ros.org/kinetic/Installation/Ubuntu">安装页面</a>。</p>
<h3 id="-21"><a href="https://github.com/rosmed/rosmed.github.io/wiki/ROS_Environment#installing-ros-kinetic"></a>安装ROS Kinetic</h3>
<p>然后我们安装其他软件包，包括ROS-Industrial，MoveIt！，Universal Robot和libvtk6-dev。从终端，</p>
<p><code>sudo rosdep update -y
sudo apt-get update -y
sudo apt-get dist-upgrade -y
sudo apt-get install -y ros-kinetic-industrial-core
sudo apt-get install -y ros-kinetic-universal-robot
sudo apt-get install -y ros-kinetic-moveit
sudo apt-get install -y ros-kinetic-moveit-visual-tools
sudo apt-get install libvtk6-dev</code></p>
<h3 id="-22"><a href="https://github.com/rosmed/rosmed.github.io/wiki/ROS_Environment#building-openigtlink"></a>构建OpenIGTLink</h3>
<p>ROS-IGTL-Bridge依赖于OpenIGTLink库。我们在〜/ igtl / OpenIGTLink下安装libary的源文件，并在〜/ igtl / OpenIGTLink-build下构建文件</p>
<p><code>cd ~
mkdir igtl
cd igtl
git clone https://github.com/openigtlink/OpenIGTLink.git
mkdir OpenIGTLink-build
cd OpenIGTLink-build
cmake -DBUILD_SHARED_LIBS:BOOL=ON ../OpenIGTLink
make</code></p>
<h3 id="-23"><a href="https://github.com/rosmed/rosmed.github.io/wiki/ROS_Environment#installing-ros-igtl-bridge"></a>安装ROS-IGTL-Bridge</h3>
<p>首先，设置catkin工作目录（如果尚未设置）。我们将使用标准的ROS工作区“catkin_ws”。如果您已有现有的，我们建议您在本教程的持续时间内将其移至其他位置</p>
<p><code>mv ~/catkin_ws ~/catkin_ws_old</code></p>
<p>然后，继续创建一个干净的工作区</p>
<p><code>mkdir -p ~/catkin_ws/src
cd ~/catkin_ws
catkin_make
source devel/setup.bash</code></p>
<p>然后从github存储库中获取代码：</p>
<p><code>cd ~/catkin_ws/src
git clone https://github.com/openigtlink/ROS-IGTL-Bridge</code></p>
<p>要构建ROS-IGTL-Bridge，请运行</p>
<p><code>cd ~/catkin_ws/
catkin_make --cmake-args -DOpenIGTLink_DIR:PATH=~/igtl/OpenIGTLink-build</code></p>
<h2 id="-24"><a href="https://github.com/rosmed/rosmed.github.io/wiki/ROS_Environment#option-2-installing-ros-using-docker"></a>[选项2]使用Docker安装ROS</h2>
<p>必须在安装之前安装<a href="https://www.docker.com/">Docker</a>。要安装教程的Docker镜像，请打开终端并运行以下命令：</p>
<p><code>sudo docker pull rosmed/docker-ros-igtl
sudo docker run -it --rm -p 6080:80 -p 28944:18944 rosmed/docker-ros-igtl</code></p>
<p>在此示例中，docker容器上的HTTP端口（端口80）和OpenIGTLink端口（端口18944）分别映射到主机上的端口6080和28944。' - rm'选项将在终止时删除容器。</p>
<p>要访问桌面，请在同一台计算机上打开Web浏览器（与HTML5兼容），然后在地址栏中键入以下地址：</p>
<p><code>http://localhost:6080</code></p>
<p>如果Docker镜像容器成功运行，则浏览器应显示桌面屏幕。</p>
<p>此docker镜像包含本教程所需的所有软件，无需安装其他软件包（即OpenIGTLink和ROS-IGTL-Bridge）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[机械臂类似UR5]]></title>
        <id>https://blog.bioprinting.site/post/9WyZd7kxa</id>
        <link href="https://blog.bioprinting.site/post/9WyZd7kxa">
        </link>
        <updated>2019-06-02T08:32:46.000Z</updated>
        <content type="html"><![CDATA[<p>This is part 2 of my 3D printed robot arm. You can watch part 1 at <a href="https://www.youtube.com/watch?v=tEbJV32GyYU">https://www.youtube.com/watch?v=tEbJV...</a> in case you missed it. The CAD design of the extended wrist cap with the electronics inside is available at <a href="https://www.youtube.com/redirect?q=https%3A%2F%2Fgallery.autodesk.com%2Ffusion360%2Fprojects%2Frobot-arm-esp32-drv8825-actuator-controller&amp;event=video_description&amp;v=RdmdFIhCo4M&amp;redir_token=ii2yaoab_KuAW516O-i_OhpUBRh8MTU1OTU1MDI3OEAxNTU5NDYzODc4">https://gallery.autodesk.com/fusion36...</a> The PCB Eagle Board design is available at <a href="https://www.youtube.com/redirect?q=https%3A%2F%2Fgithub.com%2Fchilipeppr%2Frobot-actuator-controller-v1&amp;event=video_description&amp;v=RdmdFIhCo4M&amp;redir_token=ii2yaoab_KuAW516O-i_OhpUBRh8MTU1OTU1MDI3OEAxNTU5NDYzODc4">https://github.com/chilipeppr/robot-a...</a> as well as the Lua code that I used to test the actuators in this video. The NodeMCU.bin firmware is there too. This has the latest release of the firmware plus the stepper library built in. Just flash NodeMCU.bin via esptool to your ESP32 board. The ChiliPeppr ESP32 for Lua Workspace was used to program the board and is available at <a href="https://www.youtube.com/redirect?q=http%3A%2F%2Fchilipeppr.com%2Fesp32&amp;event=video_description&amp;v=RdmdFIhCo4M&amp;redir_token=ii2yaoab_KuAW516O-i_OhpUBRh8MTU1OTU1MDI3OEAxNTU5NDYzODc4">http://chilipeppr.com/esp32</a> Video on how to use the ESP32 for Lua workspace to upload firmware and Lua code on your ESP32. <a href="https://www.youtube.com/watch?v=njAeHfoVIoY">https://www.youtube.com/watch?v=njAeH...</a> Jeff Kerr's (LoboCNC) original 3D printed robot arm design is on Thingiverse at <a href="https://www.youtube.com/redirect?q=https%3A%2F%2Fwww.thingiverse.com%2Fthing%3A3327968%2F&amp;event=video_description&amp;v=RdmdFIhCo4M&amp;redir_token=ii2yaoab_KuAW516O-i_OhpUBRh8MTU1OTU1MDI3OEAxNTU5NDYzODc4">https://www.thingiverse.com/thing:332...</a> PCB Components ESP32 Wemos $8 (Many ESP32 devices are cheaper, but this is the smallest size broadly available to fit inside the small actuators) <a href="https://www.youtube.com/redirect?q=https%3A%2F%2Fwww.aliexpress.com%2Fitem%2FESP32-wemos-ESP32-WiFi-Modules-Bluetooth-Dual-ESP-32-ESP-32S-ESP8266%2F32815190965.html&amp;event=video_description&amp;v=RdmdFIhCo4M&amp;redir_token=ii2yaoab_KuAW516O-i_OhpUBRh8MTU1OTU1MDI3OEAxNTU5NDYzODc4">https://www.aliexpress.com/item/ESP32...</a> DRV8825 Stepper Board $0.95 <a href="https://www.youtube.com/redirect?q=https%3A%2F%2Fwww.aliexpress.com%2Fitem%2F5pcs-lot-3D-Printer-Stepstick-Drv8825-Stepper-Motor-Driver-Reprap-4-PCB-Board-Free-shipping-replace%2F32514641632.html&amp;event=video_description&amp;v=RdmdFIhCo4M&amp;redir_token=ii2yaoab_KuAW516O-i_OhpUBRh8MTU1OTU1MDI3OEAxNTU5NDYzODc4">https://www.aliexpress.com/item/5pcs-...</a> DC to DC Converter $0.90 (Pick the 5V version, not 3.3V) <a href="https://www.youtube.com/redirect?q=https%3A%2F%2Fwww.aliexpress.com%2Fitem%2FDC-DC-Power-Supply-Module-Step-Down-3A-output-24V-12V-to-5V-3-3V-Buck%2F32904709711.html&amp;event=video_description&amp;v=RdmdFIhCo4M&amp;redir_token=ii2yaoab_KuAW516O-i_OhpUBRh8MTU1OTU1MDI3OEAxNTU5NDYzODc4">https://www.aliexpress.com/item/DC-DC...</a> WS2812B LED $0.15 per (Choose white and WS2812B) <a href="https://www.youtube.com/redirect?q=https%3A%2F%2Fwww.aliexpress.com%2Fitem%2F10-1000pcs-4-Pin-WS2812B-WS2812-LED-Chip-Heatsink-5V-5050-RGB-WS2811-IC-Built-in%2F32634454437.html&amp;event=video_description&amp;v=RdmdFIhCo4M&amp;redir_token=ii2yaoab_KuAW516O-i_OhpUBRh8MTU1OTU1MDI3OEAxNTU5NDYzODc4">https://www.aliexpress.com/item/10-10...</a> Slide Switch $0.29 for 20 pieces <a href="https://www.youtube.com/redirect?q=https%3A%2F%2Fwww.aliexpress.com%2Fitem%2F20Pcs-Interruptor-on-off-mini-Slide-Switch-SS12D00-SS12D00G3-3pin-1P2T-2-Position-High-quality-toggle%2F32964400942.html&amp;event=video_description&amp;v=RdmdFIhCo4M&amp;redir_token=ii2yaoab_KuAW516O-i_OhpUBRh8MTU1OTU1MDI3OEAxNTU5NDYzODc4">https://www.aliexpress.com/item/20Pcs...</a> Screw Terminal <a href="https://www.youtube.com/redirect?q=https%3A%2F%2Fwww.aliexpress.com%2Fitem%2F20-pcs-2-Pin-Screw-blue-green-PCB-Terminal-Block-Connector-5mm-Pitch%2F32814618602.html&amp;event=video_description&amp;v=RdmdFIhCo4M&amp;redir_token=ii2yaoab_KuAW516O-i_OhpUBRh8MTU1OTU1MDI3OEAxNTU5NDYzODc4">https://www.aliexpress.com/item/20-pc...</a> 26AWG Silicone Ultra Flexible Wire for 24v (Use 2 of the 4 wires) <a href="https://www.youtube.com/redirect?q=https%3A%2F%2Fwww.aliexpress.com%2Fitem%2F2metre-26AWG-28AWG-30AWG-Silicone-Wire-Ultra-Flexiable-Test-Line-3P-4P-6P-0-08mm-Tinned%2F32870367030.html&amp;event=video_description&amp;v=RdmdFIhCo4M&amp;redir_token=ii2yaoab_KuAW516O-i_OhpUBRh8MTU1OTU1MDI3OEAxNTU5NDYzODc4">https://www.aliexpress.com/item/2metr...</a></p>
<p>这个机器人手臂（非常）粗略地称为UR3工业机器人的80％缩放版本。它采用了相同的设计理念，即在每个接头处简单地放置一个电机/减速器执行器单元，六个执行器堆叠起来形成一个6轴臂。现在UR3使用空心力矩电机和谐振驱动器（$$$）作为执行器，这个机器人使用我在这里发布的步进电机/复合行星执行器：<a href="https://www.thingiverse.com/thing:3293562">https</a>：//www.thingiverse.com/thing:3293562 。两个大型执行器用于前两个基座接头，其中一个中型执行器用于肘关节，三个小型执行器用于腕关节。还有我在这里发布的抓手*：<a href="https://www.thingiverse.com/thing:3116728">https</a>：<a href="https://www.thingiverse.com/thing:3116728">//www.thingiverse.com/thing</a>：<a href="https://www.thingiverse.com/thing:3116728">3116728</a>。</p>
<p>对于控制器，我使用了Pololu的Tic T500步进控制器中的七个，并使用我编写的自定义固件来支持协调运动。您可以在此处找到血淋淋的详细信息，包括Windows测试实用程序：<a href="https://drive.google.com/open?id=1rKRuWC4jAOekrds_WGUC7DkwlVsk2zdb">https</a>：<a href="https://drive.google.com/open?id=1rKRuWC4jAOekrds_WGUC7DkwlVsk2zdb">//drive.google.com/open？id = 1rKRuWC4jAOekrds_WGUC7DkwlVsk2zdb</a></p>
<p>这是一项非常重要的工作，我会在时间充裕的情况下填补空白。在此期间，如果您需要我尚未获得的详细信息，请随时在评论部分发布问题。请仔细阅读这里的所有材料，并在开始构建之前向我提出任何问题 - 这_不是_一个简单的周末项目！</p>
<p><a href="https://youtu.be/7u_UjMB8tJI">https://youtu.be/7u_UjMB8tJI</a></p>
<p>这是jlauer发布的关于他的手臂的精彩视频：<a href="https://www.youtube.com/watch?v=tEbJV32GyYU">https</a>：<a href="https://www.youtube.com/watch?v=tEbJV32GyYU">//www.youtube.com/watch？v =</a>tEbJV32GyYU</p>
<p>另外，jlauer开发了他的自定义控制器板：<a href="https://www.youtube.com/watch?v=RdmdFIhCo4M">https</a>：<a href="https://www.youtube.com/watch?v=RdmdFIhCo4M">//www.youtube.com/watch？v =</a> RMmdFIhCo4M</p>
<p>*视频中显示的抓手与贴出的抓手略有不同。</p>
<p>更新：我刚刚发布了一款小型手腕执行器的防反冲版本，它具有更大的扭矩，更小的间隙并且运行更平稳：<a href="https://www.thingiverse.com/thing:3566678">https</a>：<a href="https://www.thingiverse.com/thing:3566678">//www.thingiverse.com/thing</a>：<a href="https://www.thingiverse.com/thing:3566678">3566678</a></p>
<p><strong>购买零件</strong></p>
<p><em>螺丝（近似数字）</em>
20 4-40插头1/4“ 
20 4-40插头x 3/8” 
30 6-32插头x 3/8“ 
20 4-40螺母
20 6-32螺母
30 2- 56 x 1/8“螺丝</p>
<p><em>电机</em>
这些是推荐的电机，但你可以在ebay等上找到相同的电机：
基座旋转：17HS15-1504S1（OMC）
肩高：17HS19-2004S1（OMC）
弯头：17HS13-1334S（OMC）
手腕+ 抓手（ 4）：35 PM048S8-08001（月亮）</p>
<p><em>控制器</em>
7 Pololu Tic T500（使用自定义固件编程）
4英尺24ga，2根双绞线电缆（总共4根线）
100 Jameco 100766母压接针
3/32“ 热缩管</p>
<p><em>杂项。硬件</em>
150 6毫米直径。气枪BB</p>
<p><strong>部件</strong></p>
<p>首先打印组装执行器（<a href="https://www.thingiverse.com/thing:3293562">https://www.thingiverse.com/thing:3293562</a>） - 2个大型20节距执行器，30个节距执行器中的1个，以及3个小型40节距执行器。您还需要点击每个减速器外壳背面的安装孔。对于20和30螺距执行器，使用6-32螺距，对于40螺距执行器，使用4-40螺距。</p>
<p>装配最容易从基础开始。首先将基础锥体装配到20节距执行器，使用带有6-32螺钉的中等长度电机。将四个6-32螺母压入肩板底部的凹槽中，然后将肩板连接到第一个执行器的顶部。接下来，将肩部外壳拧到肩板上。要完成肩部，请将第二个20节距执行器（带有最长电机）插入肩部外壳。</p>
<p>对于肘部，首先敲击上臂末端的四个6-32孔，然后连接弯头外壳。将30节距执行器（使用最短的NEMA 17电机）插入外壳。然后将上臂连接到肩部提升执行器的表面。</p>
<p>手腕开始时轻拍上臂末端的四个4-40孔，然后连接其中一个腕壳。然后将40个俯仰执行器中的一个插入该外壳中。接下来，将第二个腕壳连接到该执行器的表面，然后插入另一个40螺距的执行器。最后，为最终关节添加最后一个外壳和执行器。</p>
<p><strong>布线</strong></p>
<p>接线是构建机器人手臂时最棘手的问题之一。不幸的是，这些执行器没有空心中心，如花式UR3执行器，因此电缆必须以足够的松弛度绕每个关节跳动以允许关节运动。为了最大限度地减少接线，串行总线（V +，GND，TX，RX）用于分布在臂上的小型控制器板，每个电机上有一个板。</p>
<p>每个控制器板都有一组冗余的V +，GND，TX和RX引脚。这样可以很容易地使用菊花链电缆从一块板到另一块板。对于V +和GND，电路板上实际上有第二组孔用于可选的螺钉端子，但是我焊接在第二组插头中。对于TX和RX，我选择了未使用的Step和Dir引脚（您必须移除两个限流电阻以隔离这些引脚），然后在Dir和RX之间以及Step和TX之间添加跳线。</p>
<p>在制作电缆时，您需要使用GND扭转RX，使用V +扭曲TX线以提高抗噪性。因为并非每个电缆末端的所有引脚都在一起（并且因为在某些接头中没有连接器外壳的空间），所以我只是将一个母针压接到每根电线上并用热缩管绝缘。然后，您必须非常小心地将每根导线分别连接到每个引脚。（V +引脚全部连接在一起，GND引脚全部连接在一起，来自主机的TX与所有Tic RX引脚连接在一起，主机的RX与所有Tic TX引脚连接在一起。</p>
<p>请注意，在连接机器人之前（事实上，在组装之前），您应该在工作台上布置所有控制器和电机，将它们连接起来并使用测试软件测试所有内容。</p>
<p>每个Tic板应安装在其中一个Tic底座上。对于接头1和3（基座旋转和弯头），您可以使用双面胶带将每个Tic基座直接安装到电机背面。对于腕关节，Tic板和底座也将位于电机的末端，但是您需要轻松地将底座拉开以拆卸接头。因此，您可以将其塞入到位并穿上贝壳帽将它固定在那里。在底座高度接头上，电机末端没有足够的空间，因此在插入电线后，可以将其滑入电机侧面。</p>
<p>我在每个外壳中都有凹槽，用于进出电缆，还有一个小孔，用于固定拉链以将电缆固定到位。在前臂和上臂，你可以在内部蛇行电缆。</p>
<p><strong>软件和测试</strong></p>
<p>Pololu的Tic T500主板的标准固件不支持这样的手臂所需的多轴协调运动。所以我编写了自己的固件，您需要将其编程到Tic控制器中。（你可以使用标准固件，但你不能很好地同步所有的手臂关节。）不幸的是，你不能使用Pololu的USB bootloader（他们不会给我访问）所以你有使用PicKit编程器直接对板载PIC18F25K50芯片进行编程。您可以在以下位置找到此固件的所有详细信息（源代码，文档）以及如何对电路板进行编程：</p>
<p><a href="https://drive.google.com/open?id=1rKRuWC4jAOekrds_WGUC7DkwlVsk2zdb">https://drive.google.com/open?id=1rKRuWC4jAOekrds_WGUC7DkwlVsk2zdb</a></p>
<p>该目录还包含一个Windows测试程序，可用于测试单个关节，并且（非常粗略地）执行简单的机器人运动序列。包含测试程序的C ++源代码。我使用C ++ Builder的古老版本（v5.0）编写了这个，但现在有一个免费的，更现代的C ++ Builder版本（Community Edition）。</p>
<p><strong>还有待做的东西......</strong></p>
<p><em>关节限位器</em>
您会注意到每个执行器在固定环中都有一个插槽。其设计用于保持浮动关节止动件，该止动件也接合下一个关节的配合部分上的槽，以形成大于360度的关节止动件。范围。不是必须在任何地方连接限位开关，而是计划在每个关节上运行以防止归位。这种浮动止动件仍然需要设计和测试。</p>
<p><em>修改Gripper</em>
我最初发布的夹具使用了一个小型直流电机，我计划从Tic步进驱动器的一个通道运行。不幸的是，电机刷噪声会对驱动芯片造成严重破坏，因此在视频中，我使用了较早的步进驱动夹具。步进夹具有点弱，需要一些工作。</p>
<p><em>机器人运动学</em>
我到目前为止所使用的测试软件非常简陋，并且没有任何正向或反向机器人运动学。我需要添加这些函数来获得笛卡尔运动，或者更好地获取，让整个手臂在ROS（一个开源机器人操作系统）内运行。</p>
<p><em>真实文档</em>
我需要编写一本真正的手册来打印，组装，接线和运行这个机器人</p>
]]></content>
    </entry>
</feed>