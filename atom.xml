<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lizhenzhublog.github.io/HTML</id>
    <title>Li Zhenzhu, Ph.D</title>
    <updated>2020-06-09T10:50:50.288Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lizhenzhublog.github.io/HTML"/>
    <link rel="self" href="https://lizhenzhublog.github.io/HTML/atom.xml"/>
    <subtitle>Binzhou Medical University Hospital, Email: timeanddoctor@gmail.com.</subtitle>
    <logo>https://lizhenzhublog.github.io/HTML/images/avatar.png</logo>
    <icon>https://lizhenzhublog.github.io/HTML/favicon.ico</icon>
    <rights>All rights reserved 2020, Li Zhenzhu, Ph.D</rights>
    <entry>
        <title type="html"><![CDATA[Python+OpenCV录制双目摄像头视频]]></title>
        <id>https://lizhenzhublog.github.io/HTML/post/dL-YnYF3i</id>
        <link href="https://lizhenzhublog.github.io/HTML/post/dL-YnYF3i">
        </link>
        <updated>2020-04-22T12:52:47.000Z</updated>
        <summary type="html"><![CDATA[<ul>
<li>第一个例子
说起来录制视频，我们可能有很多的软件，但是比较坑的是，好像很少的软件支持能够同时录制两个摄像头的视频，于是我们用python自己写一个。要是OpenCV+python
https://github.com/anonymouslycn/bjtu_BinocularCameraRecord</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<ul>
<li>第一个例子
说起来录制视频，我们可能有很多的软件，但是比较坑的是，好像很少的软件支持能够同时录制两个摄像头的视频，于是我们用python自己写一个。要是OpenCV+python
https://github.com/anonymouslycn/bjtu_BinocularCameraRecord</li>
</ul>
<!-- more -->
<pre><code>import cv2
import numpy as np
from PyQt5.QtWidgets import (QMainWindow, QApplication, QFileDialog)
import threading
import threadpool 
from CvPyGui import ImageCvQtContainer
from CvPyGui.ui import gui


#UI

class Image(QWidget):
 &quot;&quot;&quot;Common base for the images&quot;&quot;&quot;
 
 def __init__(self, name, label):
 super().__init__()
 
 # Label (frame) where the original image will be located, with scaling
 self.frame_lbl = label
 
 def updateImage(self, opencv_rgb_image):
 
 self.cv_img_rgb = opencv_rgb_image
 
 height, width, channel = self.cv_img_rgb.shape
 bytesPerLine = 3 * width
 self.q_image = QImage(self.cv_img_rgb.data, width,
  height, bytesPerLine, QImage.Format_RGB888)
 
 self.frame_lbl.setPixmap(QPixmap.fromImage(self.q_image))
 
 def saveImage(self):
 # Function for saving the processed image
 
 filter = &quot;Images (*.png *.jpg)&quot;
 
 image_path, _ = QFileDialog.getSaveFileName(self, filter=filter)
 
 cv_img_bgr = cv2.cvtColor(
 self.cv_img_rgb, cv2.COLOR_RGB2BGR)
 cv2.imwrite(image_path, cv_img_bgr)
 
 #获取视频
cap = cv2.VideoCapture(int(text))
cap.set(6 ,cv2.VideoWriter_fourcc('M', 'J', 'P', 'G') );
cap.set(3,w);
cap.set(4,h);
global update1
update1 = 1
global shotmark1
ret, frame = cap.read()


</code></pre>
<p>这样就能够获取到一帧图像了，其中cap.set()函数用来设置相机的参数，本来应该有宏定义的，但是在python里面老是报错，直接用数字替代了，其中3就是获取视频的宽度像素，4是高度，这个要和摄像头手册上的参数一致。一般的Webcam有两种图像获取格式：一种是YUV2格式这种事10bit回传的数据，理论上质量更好，但是有个很大的问题是分辨率高的时候，帧率就会变得十分低。另一种格式是MJPEG格式，这个是使用了压缩技术得到的视频流。通过这个格式，手册上说在1920x1080分辨率下都能获得30fps的表现，而YUV2只有5fps（后来发现，这个就是坑爹的，信了就怪了）。cap.set(6 ,cv2.VideoWriter_fourcc(‘M', ‘J', ‘P', ‘G') );这个参数就是使用MJPEG格式来读取摄像头的数据。</p>
<p>多线程</p>
<p>刚才我们呢也提到了，cap.read()这个函数是获取到了一帧图像，但是呢。我们要的是动画啊，要是写个循环的话，又会吧进程卡死在循环中，照成假死的状态，所以对于图像的绘制，一定要使用多线程技术。在这里我不仅要吐槽一下了。学了好多年计算机，讲了很多串行算法和编程，一讲到多线程，无非就是打印个Hello World！，根本就没有什么实践，理论倒是学了很多，感觉用的时候头真的好大！</p>
<p>其实这里的多线程也没有什么是吧，就是起调一下。但是要注意的是要控制线程的退出，在python这个我引入的多线程包里面，贼坑的是没有外界控制线程退出的办法！所以，我设置了一个全局变量，使用判断全局变量的值来判断是否让子线程继续下去。</p>
<p>结尾</p>
<p>实际上，还有分辨率/帧率设置功能呢，只不过懒得写了！！！</p>
<ul>
<li>另一例子</li>
</ul>
<pre><code>import cv2

cap = cv2.VideoCapture(0) #默认大小
# cap.set(3,1080)
# cap.set(4,720)
cv2.namedWindow(cv2.WINDOW_NORMAL)#任意调节大小

#显示
import cv2

# 初始化摄像头
cap = cv2.VideoCapture(0)

while cap.isOpened():
    # 采集一帧一帧的图像数据
    isSuccess,frame = cap.read()
    # 实时的将采集到的数据显示到界面上
    if isSuccess:
        cv2.imshow(&quot;My Capture&quot;,frame)
    # 实现按下“q”键退出程序
    if cv2.waitKey(1)&amp;0xFF == ord('q'):
        break

# 释放摄像头资源
cap.release()
cv2.destoryAllWindows()
</code></pre>
<p>录制视频</p>
<pre><code># coding:utf-8
import sys

reload(sys)
sys.setdefaultencoding('utf8')
#    __author__ = '郭 璞'
#    __date__ = '2016/9/7'
#    __Desc__ = 使用Python借助opencv实现对图像的读取，写入

import cv2
import numpy as np
# 选取摄像头，0为笔记本内置的摄像头，1,2···为外接的摄像头
cap = cv2.VideoCapture(0)
# cap.set(3,1080)
# cap.set(4,720)

# 为保存视频做准备
fourcc = cv2.cv.CV_FOURCC(&quot;D&quot;, &quot;I&quot;, &quot;B&quot;, &quot; &quot;)
# 第三个参数则是镜头快慢的，20为正常，小于二十为慢镜头
out = cv2.VideoWriter('output2.avi', fourcc,3.0,(640,480))
while True:
    # 一帧一帧的获取图像
    ret,frame = cap.read()
    if ret == True:
        frame = cv2.flip(frame, 1)
        # 在帧上进行操作
        # gray = cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)
        # 开始保存视频
        out.write(frame)
        # 显示结果帧
        cv2.imshow(&quot;frame&quot;, frame)
        if cv2.waitKey(1) &amp; 0xFF == ord('q'):
            break
    else:
        break
# 释放摄像头资源
cap.release()
out.release()
cv2.destroyAllWindows()
</code></pre>
<ul>
<li>另一个例子，我电脑上可以实现的</li>
</ul>
<pre><code>import numpy as np
import cv2

cap = cv2.VideoCapture(0)

fourcc = cv2.VideoWriter_fourcc(*'XVID')
#out = cv2.VideoWriter('output.mp4',fourcc, 30.0, (640,480))  #设置分辨率


# 获取捕获的分辨率
# propId可以直接写数字，也可以用OpenCV的符号表示
width, height = cap.get(3), cap.get(4)
print(width, height)
out = cv2.VideoWriter('output.mp4',fourcc, 30.0, (int(width),int(height)))
'''
# 以原分辨率的一倍来捕获
cap.set(cv2.CAP_PROP_FRAME_WIDTH, width * 2)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, height * 2)
'''


while(cap.isOpened()):
    ret, frame = cap.read()
    if ret==True:
        frame = cv2.flip(frame,1)
#        out.write(cv2.cvtColor(frame, cv2.COLOR_RGB2BGR))   将视频转换为灰色的源
        out.write(frame)

        cv2.imshow('frame', frame)
        if cv2.waitKey(1) &amp; 0xFF == ord('1'):
            break
    else:
        break

cap.release()
out.release()
cv2.destroyAllWindows()

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何将视频转换为图片]]></title>
        <id>https://lizhenzhublog.github.io/HTML/post/dx7xPaKP-</id>
        <link href="https://lizhenzhublog.github.io/HTML/post/dx7xPaKP-">
        </link>
        <updated>2020-04-22T11:30:05.000Z</updated>
        <summary type="html"><![CDATA[<ul>
<li>如何将视频转换为图片</li>
</ul>
<p>更具根据就</p>
]]></summary>
        <content type="html"><![CDATA[<ul>
<li>如何将视频转换为图片</li>
</ul>
<p>更具根据就</p>
<!-- more -->
<pre><code>import numpy as np
import cv2, PIL, os
from cv2 import aruco
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import matplotlib as mpl
import pandas as pd
%matplotlib nbagg

workdir = &quot;../Aruco/data/calib_tel_ludo2/&quot;
name = &quot;VID_20180406_104312.mp4&quot;
rootname = name.split(&quot;.&quot;)[0]
cap = cv2.VideoCapture(workdir + name)
counter = 0
each = 10
length = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
for i in range(length):
    ret, frame = cap.read()
    if i % each == 0: cv2.imwrite(workdir + rootname + &quot;_{0}&quot;.format(i) + &quot;.png&quot;, frame)

cap.release()

os.listdir(&quot;../Aruco/data/calib_tel_ludo/&quot;)
int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[另一个完整的例子]]></title>
        <id>https://lizhenzhublog.github.io/HTML/post/QAHUqM6yQ</id>
        <link href="https://lizhenzhublog.github.io/HTML/post/QAHUqM6yQ">
        </link>
        <updated>2020-04-22T11:10:21.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<ol>
<li>生成棋盘并且打印</li>
</ol>
</li>
</ul>
<pre><code>import numpy as np
import cv2, PIL, os
from cv2 import aruco
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import matplotlib as mpl
import pandas as pd
%matplotlib nbagg

#创建棋盘
workdir = &quot;./workdir/&quot;
aruco_dict = aruco.Dictionary_get(aruco.DICT_6X6_250)
board = aruco.CharucoBoard_create(7, 5, 1, .8, aruco_dict)
imboard = board.draw((2000, 2000))
cv2.imwrite(workdir + &quot;chessboard.tiff&quot;, imboard)
fig = plt.figure()
ax = fig.add_subplot(1,1,1)
plt.imshow(imboard, cmap = mpl.cm.gray, interpolation = &quot;nearest&quot;)
ax.axis(&quot;off&quot;)
plt.show()

#通过相机不同角度拍照

datadir = &quot;../../data/calib_tel_ludo/&quot;
images = np.array([datadir + f for f in os.listdir(datadir) if f.endswith(&quot;.png&quot;) ])
order = np.argsort([int(p.split(&quot;.&quot;)[-2].split(&quot;_&quot;)[-1]) for p in images])
images = images[order]
images
#读取一个照片并展示
im = PIL.Image.open(images[0])
fig = plt.figure()
ax = fig.add_subplot(1,1,1)
plt.imshow(im)
#ax.axis('off')
plt.show()
</code></pre>
<ul>
<li>2.现在，可以使用棋盘上的所有图像进行相机校准。两个功能是必需的：</li>
</ul>
<p>第一个将检测所有图像上的标记和。
第二秒将继续检测到的标记以估计相机校准数据。</p>
<pre><code>def read_chessboards(images):
    &quot;&quot;&quot;
    Charuco base pose estimation.
    &quot;&quot;&quot;
    print(&quot;POSE ESTIMATION STARTS:&quot;)
    allCorners = []
    allIds = []
    decimator = 0
    # SUB PIXEL CORNER DETECTION CRITERION
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 0.00001)

    for im in images:
        print(&quot;=&gt; Processing image {0}&quot;.format(im))
        frame = cv2.imread(im)
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        corners, ids, rejectedImgPoints = cv2.aruco.detectMarkers(gray, aruco_dict)

        if len(corners)&gt;0:
            # SUB PIXEL DETECTION
            for corner in corners:
                cv2.cornerSubPix(gray, corner,
                                 winSize = (3,3),
                                 zeroZone = (-1,-1),
                                 criteria = criteria)
            res2 = cv2.aruco.interpolateCornersCharuco(corners,ids,gray,board)
            if res2[1] is not None and res2[2] is not None and len(res2[1])&gt;3 and decimator%1==0:
                allCorners.append(res2[1])
                allIds.append(res2[2])

        decimator+=1

    imsize = gray.shape
    return allCorners,allIds,imsize


def calibrate_camera(allCorners,allIds,imsize):
    &quot;&quot;&quot;
    Calibrates the camera using the dected corners.
    &quot;&quot;&quot;
    print(&quot;CAMERA CALIBRATION&quot;)

    cameraMatrixInit = np.array([[ 1000.,    0., imsize[0]/2.],
                                 [    0., 1000., imsize[1]/2.],
                                 [    0.,    0.,           1.]])

    distCoeffsInit = np.zeros((5,1))
    flags = (cv2.CALIB_USE_INTRINSIC_GUESS + cv2.CALIB_RATIONAL_MODEL + cv2.CALIB_FIX_ASPECT_RATIO)
    #flags = (cv2.CALIB_RATIONAL_MODEL)
    (ret, camera_matrix, distortion_coefficients0,
     rotation_vectors, translation_vectors,
     stdDeviationsIntrinsics, stdDeviationsExtrinsics,
     perViewErrors) = cv2.aruco.calibrateCameraCharucoExtended(
                      charucoCorners=allCorners,
                      charucoIds=allIds,
                      board=board,
                      imageSize=imsize,
                      cameraMatrix=cameraMatrixInit,
                      distCoeffs=distCoeffsInit,
                      flags=flags,
                      criteria=(cv2.TERM_CRITERIA_EPS &amp; cv2.TERM_CRITERIA_COUNT, 10000, 1e-9))

    return ret, camera_matrix, distortion_coefficients0, rotation_vectors, translation_vectors


#读取所有的照片		
allCorners,allIds,imsize=read_chessboards(images)

#标定相机
%time
ret, mtx, dist, rvecs, tvecs = calibrate_camera(allCorners,allIds,imsize)


</code></pre>
<ul>
<li>3.检验标记结果</li>
</ul>
<pre><code>#Check calibration results
i=20 # 选择打开哪一个照片
plt.figure()
frame = cv2.imread(images[i])
img_undist = cv2.undistort(frame,mtx,dist,None)
plt.subplot(1,2,1)
plt.imshow(frame)
plt.title(&quot;Raw image&quot;)
plt.axis(&quot;off&quot;)
plt.subplot(1,2,2)
plt.imshow(img_undist)
plt.title(&quot;Corrected image&quot;)
plt.axis(&quot;off&quot;)
plt.show()
</code></pre>
<ul>
<li>4.开始使用相机并且预估3D</li>
</ul>
<pre><code>#读取照片
frame = cv2.imread(&quot;../../data/IMG_20180406_095219.jpg&quot;)
#frame = cv2.undistort(src = frame, cameraMatrix = mtx, distCoeffs = dist)
plt.figure()
plt.imshow(frame, interpolation = &quot;nearest&quot;)
plt.show()

#处理
gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
aruco_dict = aruco.Dictionary_get(aruco.DICT_6X6_250)
parameters =  aruco.DetectorParameters_create()
corners, ids, rejectedImgPoints = aruco.detectMarkers(gray, aruco_dict,
                                                      parameters=parameters)
# SUB PIXEL DETECTION
criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 0.0001)
for corner in corners:
    cv2.cornerSubPix(gray, corner, winSize = (3,3), zeroZone = (-1,-1), criteria = criteria)

frame_markers = aruco.drawDetectedMarkers(frame.copy(), corners, ids)

print(corners)

#画出图片
plt.figure()
plt.imshow(frame_markers, interpolation = &quot;nearest&quot;)

plt.show()
</code></pre>
<ul>
<li>5.添加3轴标识</li>
</ul>
<pre><code>size_of_marker =  0.0285 # side lenght of the marker in meter
rvecs,tvecs = aruco.estimatePoseSingleMarkers(corners, size_of_marker , mtx, dist)

#添加轴
length_of_axis = 0.1
imaxis = aruco.drawDetectedMarkers(frame.copy(), corners, ids)

for i in range(len(tvecs)):
    imaxis = aruco.drawAxis(imaxis, mtx, dist, rvecs[i], tvecs[i], length_of_axis)
		
plt.figure()
plt.imshow(imaxis)
plt.grid()
plt.show()

#表格展示移动参数
data = pd.DataFrame(data = tvecs.reshape(len(tvecs),3), columns = [&quot;tx&quot;, &quot;ty&quot;, &quot;tz&quot;],
                    index = ids.flatten())
data.index.name = &quot;marker&quot;
data.sort_index(inplace= True)
print(data)
#表格展示旋转参数
datar = pd.DataFrame(data = tvecs.reshape(len(rvecs),3), columns = [&quot;rx&quot;, &quot;ry&quot;, &quot;rz&quot;],
                    index = ids.flatten())
datar.index.name = &quot;marker&quot;
datar.sort_index(inplace= True)
np.degrees(datar)
</code></pre>
<ul>
<li>6.后期处理相关的数据</li>
</ul>
<pre><code>v = data.loc[3:6].values
((v[1:] - v[:-1])**2).sum(axis = 1)**.5
cv2.Rodrigues(rvecs[0], np.zeros((3,3)))
fig = plt.figure()
#ax = fig.add_subplot(111, projection='3d')
ax = fig.add_subplot(1,2,1)
ax.set_aspect(&quot;equal&quot;)
plt.plot(data.tx, data.ty, &quot;or-&quot;)
plt.grid()
ax = fig.add_subplot(1,2,2)
plt.imshow(imaxis, origin = &quot;upper&quot;)
plt.plot(np.array(corners)[:, 0, 0,0], np.array(corners)[:, 0, 0,1], &quot;or&quot;)
plt.show()
</code></pre>
<ul>
<li>7.开始定义在图片中的位置</li>
</ul>
<pre><code>a = np.arange(50)
import pickle
f = open(&quot;truc.pckl&quot;, &quot;wb&quot;)
pickle.dump(a, f)
f.close()

f = open(&quot;truc.pckl&quot;, &quot;rb&quot;)
b = pickle.load(f)
b == a

corners = np.array(corners)
data2 = pd.DataFrame({&quot;px&quot;: corners[:, 0, 0, 1],
                      &quot;py&quot;: corners[:, 0, 0, 0]}, index = ids.flatten())
data2.sort_index(inplace=True)
print(data2)

m0 = data2.loc[0]
m43 = data2.loc[43]
d01 = ((m0 - m43).values**2).sum()**.5
d = 42.5e-3 * (3.5**2 + 4.5**2)**.5
factor = d / d01
data2[&quot;x&quot;] = data2.px * factor
data2[&quot;y&quot;] = data2.py * factor
((data2[[&quot;x&quot;, &quot;y&quot;]].loc[11] - data2[[&quot;x&quot;, &quot;y&quot;]].loc[0]).values**2).sum()**.5
c = np.array(corners).astype(np.float64).reshape(44,4,2)
(((c[:, 1:] - c[:, :-1])**2).sum(axis = 2)**.5).mean(axis =1)
</code></pre>
<ul>
<li>9.利用help函数查看帮助文档</li>
</ul>
<pre><code>help(cv2.aruco.detectMarkers)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[机器视觉2 创建标记并识别]]></title>
        <id>https://lizhenzhublog.github.io/HTML/post/O_TkJInMU</id>
        <link href="https://lizhenzhublog.github.io/HTML/post/O_TkJInMU">
        </link>
        <updated>2020-04-22T11:00:59.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>创建</li>
</ul>
<pre><code>import numpy as np
import cv2, PIL
from cv2 import aruco
import matplotlib.pyplot as plt
import matplotlib as mpl
import pandas as pd
%matplotlib nbagg


aruco_dict = aruco.Dictionary_get(aruco.DICT_6X6_250)

fig = plt.figure()
nx = 4
ny = 3
for i in range(1, nx*ny+1):
    ax = fig.add_subplot(ny,nx, i)
    img = aruco.drawMarker(aruco_dict,i, 700)
    plt.imshow(img, cmap = mpl.cm.gray, interpolation = &quot;nearest&quot;)
    ax.axis(&quot;off&quot;)

plt.savefig(&quot;_data/markers.pdf&quot;)  #保存为pdf
plt.show()

#通过打印机打印，裁剪后拍照
#读取照片
frame = cv2.imread(&quot;_data/aruco_photo.jpg&quot;)
plt.figure()
plt.imshow(frame)
plt.show()

#追踪
%%time
gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
aruco_dict = aruco.Dictionary_get(aruco.DICT_6X6_250)
parameters =  aruco.DetectorParameters_create()
corners, ids, rejectedImgPoints = aruco.detectMarkers(gray, aruco_dict, parameters=parameters)
frame_markers = aruco.drawDetectedMarkers(frame.copy(), corners, ids)

#把追踪的结果图片展示
plt.figure()
plt.imshow(frame_markers)
for i in range(len(ids)):
    c = corners[i][0]
    plt.plot([c[:, 0].mean()], [c[:, 1].mean()], &quot;o&quot;, label = &quot;id={0}&quot;.format(ids[i]))
plt.legend()
plt.show()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[机器视觉]]></title>
        <id>https://lizhenzhublog.github.io/HTML/post/XMhGzY5TR</id>
        <link href="https://lizhenzhublog.github.io/HTML/post/XMhGzY5TR">
        </link>
        <updated>2020-04-22T10:23:31.000Z</updated>
        <content type="html"><![CDATA[<p><strong>Aruco</strong></p>
<ul>
<li><a href="https://mecaruco2.readthedocs.io/en/latest/notebooks_rst/Aruco/Projet+calibration-Paul.html">检查校准</a>
<ul>
<li><a href="https://mecaruco2.readthedocs.io/en/latest/notebooks_rst/Aruco/Projet+calibration-Paul.html#use-of-camera-calibration-to-estimate-3d-translation-and-rotation-of-each-marker-on-a-scene">使用相机校准来估计场景中每个标记的3D平移和旋转</a></li>
<li><a href="https://mecaruco2.readthedocs.io/en/latest/notebooks_rst/Aruco/Projet+calibration-Paul.html#post-processing">后期处理</a></li>
<li><a href="https://mecaruco2.readthedocs.io/en/latest/notebooks_rst/Aruco/Projet+calibration-Paul.html#result">结果</a>
<ul>
<li><a href="https://mecaruco2.readthedocs.io/en/latest/notebooks_rst/Aruco/Projet+calibration-Paul.html#add-local-axis-on-each-maker">在每个制造商上添加局部轴</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://mecaruco2.readthedocs.io/en/latest/notebooks_rst/Aruco/aruco_basics.html">ARUCO标记：基础知识</a>
<ul>
<li><a href="https://mecaruco2.readthedocs.io/en/latest/notebooks_rst/Aruco/aruco_basics.html#marker-creation">1：标记创建</a></li>
<li><a href="https://mecaruco2.readthedocs.io/en/latest/notebooks_rst/Aruco/aruco_basics.html#print-cut-stick-and-take-a-picture">2：打印，剪切，粘贴并拍照</a></li>
<li><a href="https://mecaruco2.readthedocs.io/en/latest/notebooks_rst/Aruco/aruco_basics.html#post-processing">3：后期处理</a></li>
<li><a href="https://mecaruco2.readthedocs.io/en/latest/notebooks_rst/Aruco/aruco_basics.html#results">4：结果</a></li>
</ul>
</li>
<li><a href="https://mecaruco2.readthedocs.io/en/latest/notebooks_rst/Aruco/aruco_basics_video.html">ARUCO标记：基础知识</a>
<ul>
<li><a href="https://mecaruco2.readthedocs.io/en/latest/notebooks_rst/Aruco/aruco_basics_video.html#marker-creation">1：标记创建</a></li>
<li><a href="https://mecaruco2.readthedocs.io/en/latest/notebooks_rst/Aruco/aruco_basics_video.html#print-cut-stick-and-take-a-picture">2：打印，剪切，粘贴并拍照</a></li>
<li><a href="https://mecaruco2.readthedocs.io/en/latest/notebooks_rst/Aruco/aruco_basics_video.html#post-processing">3：后期处理</a></li>
<li><a href="https://mecaruco2.readthedocs.io/en/latest/notebooks_rst/Aruco/aruco_basics_video.html#results">4：结果</a></li>
</ul>
</li>
<li><a href="https://mecaruco2.readthedocs.io/en/latest/notebooks_rst/Aruco/sandbox/sandbox.html">沙盒</a>
<ul>
<li><a href="https://mecaruco2.readthedocs.io/en/latest/notebooks_rst/Aruco/sandbox/ludovic/ludovic.html">鲁多维奇</a>
<ul>
<li><a href="https://mecaruco2.readthedocs.io/en/latest/notebooks_rst/Aruco/sandbox/ludovic/aruco_calibration_rotation.html">使用CHARUCO进行相机校准</a>
<ul>
<li><a href="https://mecaruco2.readthedocs.io/en/latest/notebooks_rst/Aruco/sandbox/ludovic/aruco_calibration_rotation.html#camera-pose-estimation-using-charuco-chessboard">2.使用CHARUCO国际象棋棋盘估算相机姿势</a>
<ul>
<li><a href="https://mecaruco2.readthedocs.io/en/latest/notebooks_rst/Aruco/sandbox/ludovic/aruco_calibration_rotation.html#check-calibration-results">检查校准结果</a></li>
</ul>
</li>
<li><a href="https://mecaruco2.readthedocs.io/en/latest/notebooks_rst/Aruco/sandbox/ludovic/aruco_calibration_rotation.html#use-of-camera-calibration-to-estimate-3d-translation-and-rotation-of-each-marker-on-a-scene">3。使用相机校准来估计场景中每个标记的3D平移和旋转</a></li>
<li><a href="https://mecaruco2.readthedocs.io/en/latest/notebooks_rst/Aruco/sandbox/ludovic/aruco_calibration_rotation.html#post-processing">后期处理</a></li>
<li><a href="https://mecaruco2.readthedocs.io/en/latest/notebooks_rst/Aruco/sandbox/ludovic/aruco_calibration_rotation.html#results">结果</a>
<ul>
<li><a href="https://mecaruco2.readthedocs.io/en/latest/notebooks_rst/Aruco/sandbox/ludovic/aruco_calibration_rotation.html#add-local-axis-on-each-marker">在每个标记上添加局部轴</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[儿童脑干肿瘤及手术入路]]></title>
        <id>https://lizhenzhublog.github.io/HTML/post/2IgPVMzQH</id>
        <link href="https://lizhenzhublog.github.io/HTML/post/2IgPVMzQH">
        </link>
        <updated>2019-10-05T11:42:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="目的">目的</h3>
<p>分析儿童期脑干肿瘤的通路以及安全进入区。</p>
<h3 id="方法">方法</h3>
<p>我们对第一位作者（Cavalheiro，S.）于1991年至2011年在圣保罗联邦大学神经外科和儿科肿瘤研究所进行的脑干肿瘤切除术的207例年龄小于18岁的患者进行了回顾性研究。</p>
<h3 id="结果">结果</h3>
<p>脑干肿瘤占同期所有手术儿科肿瘤的9.1％。使用了11个先前描述的“安全进入区”。我们描述了位于上腹桥的一个新的安全区，我们将其称为超上路法。术后头两个月的手术死亡率为1.9％（四名患者），发病率为21.2％。</p>
<h3 id="结论">结论</h3>
<p>内在和外在的脑干结构的解剖学知识，结合完善的神经外科技术，并借助术中监测，以及基于磁共振成像（MRI）和超声成像的外科手术计划，已广泛切除了脑干病变，具有低死亡率和可接受的发病率。</p>
<p>**关键词：**小儿脑干神经胶质瘤，脑干手术，安全进入区，白色纤维解剖学，三叉神经上入路，低度星形细胞瘤</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/" title="转到此页面的其他部分">去：</a></p>
<h2 id="介绍">介绍</h2>
<p>脑干是人体内最复杂的结构之一，包含最复杂的颅内解剖结构[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR55">55</a> ]。这种紧凑的中线器官在前部受到锁骨保护，在侧面受到颞骨的小部分的保护，在上方受到中脑的保护，而在后部则受到小脑的保护。所有运动，感觉，交感和副交感神经功能都已整合并通过脑干。脑干的结构复杂性使得在那里的外科手术极其困难，并且需要完善的技术。脑干肿瘤在儿童中更为常见，占儿童脑肿瘤的18％和颅后窝肿瘤的25％。没有性别偏爱。这些肿瘤的平均年龄发生在5至10岁左右<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR54"> [54]</a>]。在30至40岁之间的成年人中出现第二个发病高峰。近年来，一些文章已经在脑干解剖和出版了“安全进区。”其中的大多数都与海绵状血管瘤手术，很少在儿童[相关脑干肿瘤手术入路<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR9">9</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR19">19</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR22">22</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR26">26</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR53">53</a> ]。这项研究的目的是回顾本文所述的手术方法以及本文的第一作者（Cavalheiro，S.）基于207例年龄小于18岁的接受脑干肿瘤手术的患者所进行的手术方法。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/" title="转到此页面的其他部分">去：</a></p>
<h2 id="分类">分类</h2>
<p>纤维的各种排列，Virchow-Robin空间以及包括脑干的结构有时使肿瘤无症状地大量生长。这可以允许弥漫性桥脑肿瘤在桥内生长而不会渗入中脑或髓质。当中脑肿瘤生长时，它们向丘脑扩散，不会浸入脑桥。延髓的肿瘤倾向于生长到第四脑室而不会侵入脑桥，或者朝脊髓尾部生长。</p>
<p>已经提出了针对脑干肿瘤的许多分类。我们使用了Choux等人的建议：I型，弥漫性脑干神经胶质瘤；II型，局灶性内在肿瘤（实体或囊性）；III型，外生的；和IV型，颈髓[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR14">14</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR15">15</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR17">17</a> ]。</p>
<h3 id="弥漫性肿瘤i型">弥漫性肿瘤（I型）</h3>
<p>弥漫性肿瘤是最常见的，占脑干肿瘤的80％。它们同时影响多个核和通路，并典型地引起颅神经VI和VII的双侧麻痹，发展为偏瘫和四肢瘫痪。它们表现出快速的临床发展，就组织病理学而言，大多数是Ⅲ或Ⅳ级恶性星形细胞瘤（WHO）。在放射学上，它们的特征是桥脑被截留的桥脑增大。它们在T1磁共振成像（MRI），在T2高，高信号上FLAIR低信号，并表现出最小的对比度增强[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR6">6</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR44">44</a> ]。</p>
<p>这些患者的生存期很短，大多数在诊断后的前两年内死亡。但是，少数情况可能对化学疗法和放射疗法有反应。使用常规或多级放疗的预后没有差异。神经轴的转移可以在5至30％的病例[发生<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR10">10</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR18">18</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR25">25</a> ]。</p>
<p>在几个中心进行了弥漫性脑干肿瘤的立体定向活检。它的用途主要是重要的分子生物学研究[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR52">52</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR57">57</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR62">62</a> ]。但是，活检与某些并发症有关。Pincus等。（2006）[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR49">49</a>）对13例儿童弥漫性桥脑病变报告中的182例立体定向活检病例进行了回顾性研究。他们指出，有75至100％的病例证实了肿瘤的诊断。在87％的病例中，病变为神经胶质瘤，其余的13％为原始神经外胚层肿瘤，神经细胞瘤，室管膜瘤和脱髓鞘性病变。发病率从0％到16％不等，死亡率达到5％。因此，活检表明只有在与非特征图像的情况下或在分子生物学研究中心[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR32">32</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR59">59</a> ]。立体定向活检可以通过额叶区域的进入点或后颅窝进行。</p>
<h3 id="局灶性肿瘤ii型">局灶性肿瘤（II型）</h3>
<p>局灶性肿瘤的行为与弥漫性肿瘤不同。它们是生长缓慢的病灶，症状是惰性的。它们可能是实性或囊性的，与弥漫性肿瘤相反，局部病变边界清晰。较少的水肿与局灶性肿瘤有关，局灶性肿瘤主要是低度神经胶质瘤。它们通常在T1上表现低下，并伴有弥漫性肿瘤增强。focal的浸润在局灶性肿瘤中有所不同。然而，均一性增强强烈提示细胞性星形细胞瘤[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR29">29</a> ]。</p>
<p>如果肿瘤是浅表的，建议手术治疗；但是，如果肿瘤很深，则应保守治疗，以期肿瘤本身可以为切除术提供“开门”。对于这些肿瘤的外科手术方法，使用射线照相术可以提供更好的选择。四边形板中的肿瘤通常是局灶性的，大部分是毛细胞星形细胞瘤[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR33">33</a> ]。</p>
<h3 id="外生性肿瘤iii型">外生性肿瘤（III型）</h3>
<p>外生性肿瘤更容易通过手术获得。它们往往是大的肿瘤，脑干中有很大的成分，有利于手术。它们可能具有囊性成分，这是促进其切除的另一个因素。它们主要是低度星形细胞瘤[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR48">48</a> ]。</p>
<h3 id="颈髓交界性肿瘤iv型">颈髓交界性肿瘤（IV型）</h3>
<p>颈髓交界处肿瘤通常表现为外生性生长，使外科医生无需切开脑干即可直接进入。这些病变通常不渗入脑桥，并从颅脑逐渐生长到第四脑室。它们可能尾部延伸到脊髓中。当向第四脑室生长时，脑积水可能在早期发生。当朝向脊髓生长时，由于脑脊髓液动力学的变化，它们可能会产生脊髓空洞症。尽管地形有利于手术入路，但这些情况最常伴随严重的病情发展。术后，这些患者可能呼吸困难，导致长时间的辅助机械通气和吞咽困难，继而可能引起严重的吸入性肺炎。患者可能需要进行气管造口术和胃造口术，必须进行言语治疗。手术期间使用电生理监测有助于预防这些并发症[<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR16">16</a>]。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/" title="转到此页面的其他部分">去：</a></p>
<h2 id="患者和方法">患者和方法</h2>
<p>1991年至2011年，圣保罗联邦大学神经外科和儿科肿瘤研究所对303名18岁以下脑干肿瘤患者进行了治疗。其中，本文的第一作者对207进行了手术治疗。其余96例为弥漫性肿瘤。在这里，我们描述了手术方法和相关的外部/内部解剖学要点。</p>
<p>脑干分为三个部分：中脑，脑桥和延髓。为了选择最有效，最安全的去除病变的方法，我们将脑干分为七个部分（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig1/">1e</a>）。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig1_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig1_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig1_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig1/?report=objectonly">在单独的窗口中打开</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig1/">图。1</a></p>
<p><strong>一个</strong>。脑干表面解剖。脑干分为三个部分：中脑，脑桥和延髓。中脑受视道（OT）与小脑之间的沟的限制较高，而受脑脊髓沟（Pon。Mes。Sulc。）的限制较低。桥位于上方的桥脑脑沟和下方的桥脑髓沟之间（Pont。Med。Sulc。）。延髓从桥状沟延伸至C1神经根的出口区。<strong>b</strong>，**c **<strong><em>，</em></strong> <strong>d</strong>脑干血管化。椎动脉（VA）汇合在一起，形成桥椎沟水平的基底动脉。基底动脉（BA）在脑桥脑沟水平处引起后脑动脉（PCA）。小脑具有三个表面：腱膜，岩膜和枕下。小脑和延髓的枕下表面由小脑后下动脉（PICA）提供。小脑和脑桥的椎体表面由AICA和基底动脉穿孔器提供，而小脑的中脑和腱膜表面由小脑上动脉（SCA）分支提供。<strong>Ë</strong>脑干又分为七个部分：腹侧，中央和背侧中脑。腹桥和背桥; 和腹和背髓质。<strong>f</strong>根据内侧马鞭草（ML）的病程对脑干进行解剖划分。在ML的前面可以认为是腹侧脑干，而在内侧的lemniscus后面可以视为背侧脑干</p>
<p>中脑分为三个部分：前，中和后。前段由黑质向后定界。中脑从黑质延伸到渡槽。后部仅限于四边形板。桥被分为两个部分：前部和后部，或腹侧和背侧。同样，延髓被分为前壁和后壁，或腹侧和背侧。对脑干外部和内部解剖结构的详细了解对于避免手术方法中的发病至关重要。</p>
<h3 id="中脑">中脑</h3>
<p>中脑通过视道和脑梗之间的沟与二脑分开，而脑桥沟则与中脑分开。在解剖学上，三个结构应当广泛认可中脑：位于脑前外侧部的锥体束，所述第三和第四颅神经[细胞核<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR63">63</a> ]（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig1/">1</a>和<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig2/">and2a）。</a><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig2/">2a</a>）。第三颅神经的核水平在上丘的下半部和下丘的上半部。滑车核位于下丘的下半部尾侧。这些核位于中线附近，平均在外侧中脑沟表面内侧9.5 mm处。中脑外侧沟从内侧膝状体向下延伸到脑桥脑沟以下。该沟被认为是腹外侧中脑的后极限。第三颅神经沿着中脑的整个中央部分有很长的路程，而第四颅神经的内在部分较小，并且贯穿对侧小脑间脑裂隙。第三颅神经从中脑梗的内侧沟流出，并向动眼三角形移动，进入其进入海绵窦。中脑通过中脑穿孔的基底动脉分支接受血液供应。它们分为前内侧，前外侧，外侧和后分支。前内侧分支分为外侧和内侧。内侧分支供应红色核，导水管周围的灰质以及第三和第四颅神经核。外侧分支供应内侧的圆盘菌，黑质和上小脑梗。前脑中脑动脉被称为小脑分支，并供应小腿，黑质和内侧韧带。它们来自许多动脉，包括胶状，后脉络膜内侧，后交通动脉，小脑上动脉和脉络膜前动脉。后动脉由小脑上动脉的分支和胶状动脉形成，并形成一个累及四头肌板的神经丛[<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR55">55</a> ]。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig2_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig2_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig2_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig2/">图2</a></p>
<p><strong>一</strong>中脑的动眼神经的水平示意图。黑质和lemanscus内侧是中脑腹侧（<em>前</em>）和中部之间的边界，而大脑输水管的水平是中脑中央（<em>蓝色</em>）和背侧（<em>后部</em>）（<em>绿色</em>）之间的边界。腹中脑的皮质脊髓束（<em>黄色</em>）（<em>红色</em>）; 中枢（<em>蓝色</em>）和背中脑的CN III（<em>黄色</em>）和IV（<em>红色</em>）的核和进程。<strong>b</strong>中脑的侧面图。腹侧（前）中脑，包含皮质脊髓束（CST），位于内侧盘球菌（ML）和黑质前面。中央的中脑包含红色，动眼神经和滑车核，位于中部圆盘菌和渡槽之间。由上侧（SC）和下侧结肠（IC）组成的背中（<em>后</em>）中脑位于大脑导水管的后面。CN III和IV的核正好位于渡槽的腹侧。<strong>c</strong>中脑前视图。_1_周期性运动进入区的内侧为CN III的出口点，外侧为皮质脊髓束（CST）。<strong>d</strong> 周围运动区受大脑后动脉（PCA）的限制，受小脑上动脉（SCA）的限制</p>
<h3 id="前中脑">前中脑</h3>
<p>中脑前部的肿瘤通常沿两个方向生长：朝向第三脑室和朝向椎间盘水箱。对于生长到第三脑室的肿瘤，使用了跨孔，经call，经脉络膜或经孔的方法。当病变的大小小于2 cm时，可以使用与超声抽吸器相连的神经内窥镜切除肿瘤，其中大多数是低度星形细胞瘤（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig3/">3</a>）。当这些肿瘤向椎间盘水箱生长时，通常会出现韦伯综合征（第三颅神经损伤和对侧偏瘫）（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig4/">4</a>）。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig3_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig3_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig3_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig3/">图3</a></p>
<p><strong>一</strong>内窥镜访问位于中脑的前部和上部分肿瘤。<strong>b</strong>一名8岁的颅内高压患者。病变存在于中脑的前部和上部地形中。<strong>c</strong>在内镜下彻底清除病变并进行脑导水管通畅后的3年随访。诊断为低度星形细胞瘤。<strong>d</strong>。大脑中部及完全切除后外生性肿瘤的术中内窥镜检查。通过门罗的孔后，在第三脑室的底部看到并去除了病变</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig4_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig4_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig4_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig4/">图4</a></p>
<p><strong>a</strong>，<strong>b</strong> 4岁女孩患有右Weber综合征，其实性/囊性中脑前病变，向椎间盘池扩展。<strong>c</strong>，<strong>d的</strong> 6年随访显示，额眶眶骨入路（上皮星形细胞瘤）全切除</p>
<p>经中枢神经的途径可通过经典的翼状,、眶额front合zy或颞temporal途径来接近中脑的前部和前外侧病变。通过这些途径，可以通过颞极方法（颞下或颞下颞下）结合方法。Sano在1980年描述了颞极方法[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR58">58</a> ]。它允许在后上方向的颞叶上开放并可视化前外侧椎间窝。另一种使用的方法是颞下颞叶，如Krause在1911年所描述的[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR36">36</a>]。这种方法增加了由于拉贝复合体的静脉损伤而引起的静脉梗死的风险，以及由于沿腱弓ci裂引起的第三和第四次颅神经损伤而引起的眼瘫。另一方面，这种方法可以很好地观察切牙空间。切口可确保基底动脉，椎间盘池，脑干和脑桥腹侧表面良好暴露。Bricolo和Turazzi [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR7">7</a> ] 描述了一个进入前外侧中脑的“相当安全”的进入区域，因为皮质脊髓束的纤维仅占据了花梗的中间五分之三（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig2/">2c）。</a>）。该狭窄的窗口在上方由大脑后动脉界定，在下方由小脑上动脉界定，在内侧由颅神经III和基底动脉出现，在外侧由锥体束界定（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig5/">5</a>）。这里的肿瘤通常是外生的，因此不必进入脑干，并且可以在病变的出口处切开肿瘤。在局灶性肿瘤的情况下，需要切开脑干，可使用菱形手术刀。不使用双极凝血。平行于第三颅神经切开切口，以防止锥体束损伤。以这种方式进入被称为周运动。此策略必须格外小心，以免损伤红色核，锥体束和动眼神经。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig5_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig5_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig5_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig5/">图5</a></p>
<p><strong>一个</strong>。一名7岁的患有复视和右侧动眼神经麻痹的患者。MRI显示局灶性和固有病变与中脑第三神经的固有进程平行。<strong>b</strong>。完全切除后5年的随访，无残留病变</p>
<h3 id="中脑-2">中脑</h3>
<p>位于中脑中部的肿瘤也可以沿两个方向生长：朝向松果体区域或进入第四脑室。当它们向第四脑室生长时，采用枕下cip骨入路。它们生长时朝向松果体区，我们使用在1911 [由克劳斯建议的路径<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR37">37</a>]和普及斯坦因[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR60">60</a> ]，这是枕下幕上入路线（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig6/">6</a>和<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig7/">和7），</a><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig7/">7</a>），进一步分为中位数或次中位数。这种方法通常使患者处于坐姿。进行广泛的后颅窝开颅手术，并切除C1弓。这种方法允许小脑的广泛运动。在Vermian静脉凝结后，小脑下降以允许进入中脑。当病变位于内侧时，我们也会使小脑前中央静脉凝固。当病变位于外侧时，无需凝固该静脉（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig8/">8）。</a>）。在该区域应小心，因为第四颅神经位于下丘的正下方。对于有外生性病变的患者，无需切开脑干，我们可以直接接近肿瘤，除了小海绵状瘤，我们使用了三种通路：上，下周围胶体和通过中脑沟。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig6_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig6_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig6_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig6/?report=objectonly">在单独的窗口中打开</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig6/">图6</a></p>
<p><strong>一个</strong>。肿瘤位于中脑中央，并向松果体区域生长。<strong>b</strong>幕下race上小脑入路。<strong>c</strong>通过腹下sup上小脑途径的松果体区域的解剖图。_SC_上丘，_IC_下丘</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig7_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig7_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig7_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig7/?report=objectonly">在单独的窗口中打开</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig7/">图7</a></p>
<p><strong>a</strong>，<strong>b</strong>通过中央下ten上小脑入路切除了中脑中央的一个实体囊性肿瘤，其中g的增强朝向松果体区域生长。<strong>c</strong>，<strong>d</strong>十年随访没有发现病变的证据，这是一个毛细血管星形细胞瘤</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig8_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig8_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig8_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig8/">图8</a></p>
<p><strong>一</strong>中脑的侧视图。中脑外侧沟（LMS）在中脑表面延伸，从上方的内侧膝状体（MGB）延伸至下方的脑桥脑沟（Pont。Mes。Sulc。）。LMS沿着内侧马鞭草（ML）的外侧边缘延伸。<strong>b</strong> ML将中脑分为腹侧（<em>前</em>）和背侧（<em>后</em>）部分。通过LMS进入时的神经关键结构是前中脑的皮质脊髓束，中脑（盖骨）中枢的红色，动眼和滑车核，后上（_后背）上_丘的核。） 中脑。动眼神经核在中线位于上丘的下半部和下丘的上半部，而滑车核在中线上位于下丘的下半部。<strong>c</strong>沿中脑外侧沟经下sup上小脑途径到达中脑中央的侧部病变。<strong>d</strong>完全切除后五年随访，无病变迹象，细胞性星形细胞瘤</p>
<p>从关节周围进入点，可以进入两个“安全区”：在下大脑以下或中枢神经下或在滑车神经上或在关节上神经上方的中脑切口。在颈上方法中，在上睑上方正好做一个横向切口，并应由导水管限制。这种方法的进一步扩展会损害颅神经III和IV的神经核，以及内侧纵筋膜。通过颈下通路，在滑车神经与下丘的下缘之间进行横向切口。至于上上路，比脑导水管更深的切口会损伤第三和第四颅神经的核以及内侧纵筋膜。</p>
<p>对于扩展到第四脑室的病变，我们可以切开小脑的四角形叶，以便更大程度地进入小脑中脑裂隙。在这种方法中，必须对第三和第四神经核以及它们在中脑内部的活动进行空间想象。</p>
<p>在这种情况下，超声抽吸器非常重要，肿瘤的颜色对于完全切除也最有帮助。但是，有些肿瘤的颜色与脑干的颜色相同，因此外科医生必须依靠纤维的位置以及肿瘤的质地和循环。肿瘤通常比正常的脑干更柔软，血管也更多，因此更容易切除。</p>
<h3 id="后背中脑">后（背）中脑</h3>
<p>后脑或四肢后板是大脑输水管后的中脑部分的名称。四边形板的肿瘤是最小的脑瘤，有可能杀死脑积水患者。它们约占脑干小儿肿瘤的5％[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR24">24</a> ]。它们通常是惰性病变，其治疗仅限于脑积水的治疗。大多数时候，这些肿瘤在T1加权图像上是等强度的，而在T2加权图像上是高强度的。多达19％的病例可能进行了lin增强MRI检查[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR23">23</a> ]。</p>
<p>脑积水最好通过内镜第三脑室造口术治疗[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR38">38</a> ]。由于活检区域远端有出血的可能，应避免内镜活检（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig9/">9</a>），大多数此类病变为低度星形细胞瘤，例如毛细胞性和非星形细胞性星形细胞瘤，混合性神经胶质瘤和极少数更具侵略性的肿瘤作为间变性星形细胞瘤[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR50">50</a> ]。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig9_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig9_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig9_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig9/?report=objectonly">在单独的窗口中打开</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig9/">图9</a></p>
<p>内镜活检四头肌钢板病变-上皮星形胶质细胞瘤后脑室内出血</p>
<p>一些肿瘤可能会生长并需要手术。在这种情况下，已经使用了两种类型的方法：当它们向第三脑室生长时，选择了小脑上fra肌下肌上神经支配途径（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig11/">11</a>）。然而，如果它们向第四脑室的上部生长，则首选由Poppen [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR51">51</a> ] 提出并经Ausman [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR3">3</a> ] 修改的经枕后入路（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig10/">10</a>）。经颅枕后入路由Horrax于1937年首次描述[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR28">28</a> ]，由Poppen于1968年提出[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR51">51</a> ]，并于1971年由Jameson推广<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR30"> [30]。</a>]。已经描述了几种手术位置，例如坐着，俯卧，协和和四分之三俯卧。Ausmann（1988）[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR3">3</a> ]描述了经枕后入路，四分之三的俯卧位，病变侧向下，冠状平面与地板成45度角，头部弯曲30度和15度仰角。这使得枕叶在重力的作用下掉落，因此脑部回缩的需求减少，并且因枕叶回缩而导致同名偏盲的风险也降低了。这种方法可以很好地观察松果体区域，中脑的后外侧表面，小脑的腱膜表面，call体的脾脏以及第三脑室的后三分之一。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig10_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig10_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig10_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig10/?report=objectonly">在单独的窗口中打开</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig10/">图10</a></p>
<p>四头肌板中的<strong>一个</strong>肿瘤向第四脑室生长。<strong>b</strong>经枕后入路。<strong>c</strong>枕骨右后视图。松果体和脾脏暴露。<strong>d</strong>。四头肌板状肿瘤生长至第四脑室，通过经枕骨入路手术。<strong>e</strong>。病变完全切除后9年的术后影像学检查，未显示肿瘤的证据，这是毛细血管星形细胞瘤</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig11_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig11_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig11_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig11/?report=objectonly">在单独的窗口中打开</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig11/">图11</a></p>
<p><strong>一个</strong>后验（<em>背</em>）中脑由一对上级（SC）和下丘（IC）的。在上丘的上边缘的正上方制作横颈上切口（<em>1</em>）。鞘膜下切口（<em>2</em>）在CN IV与下丘的下边缘之间横向指向。<strong>b</strong>进一步解剖背（后）中脑。重要的标志是大脑导水管，它位于中线内侧纵筋膜（MLF），动眼神经和滑车核的后面。红色核从下丘的中层延伸到第三脑室的侧壁。<strong>C</strong>朝第三和第四脑室生长的大肿瘤的卡通，可以通过合并下in上小脑然后再进行枕下小脑入路来接近。<strong>d</strong>一名5岁患者的四头肌板的大型毛细细胞星形细胞瘤，向着第三脑室和第四脑室生长，通过合并的小脑下-下肌腱膜和telovelar通路穿过菱形窝。<strong>e</strong>术后MRI扫描显示完全切除</p>
<p>该方法主要推荐用于具有较大的上，外侧延伸的肿瘤，移位的静脉复合体会通过后内侧通路损害肿瘤的视野。</p>
<p>在这种方法中，进行枕骨开颅手术，包括枕骨缝线并与横断和上矢状窦相连。硬脑膜可以C形打开，其底部朝向上矢状窦，或者以两个三角形打开，底部朝向上矢状和横窦。小脑腱鞘平行于直窦打开1.5至2厘米。还可以在call体脾小切口上做一个小切口，以扩大肿瘤延伸到III脑室后三分之一的视野。当肿瘤向第三脑室和第四脑室的上部生长时，该区域变为“盲区”，因此，我们使用枕下上小脑与下枕小脑上入路相关联，以到达第四脑室[图<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR4">4</a> ]（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig11/">11</a>）。</p>
<p>因此，对于中脑手术，我们有四个“安全区”：通过前区病变的动眼区，上眼睑上皮，下眼睑下皮以及通过中脑外侧沟至中脑中段。中脑后部病变通常是外生性的，不需要脑干切口。</p>
<h3 id="庞斯">庞斯</h3>
<p>多数桥脑肿瘤是弥漫性的。因此，切除手术是无益的，并建议进行化学疗法/放射疗法。神经外科医生必须区分局灶性，低度外生性和弥漫性肿瘤，患者才能从手术中受益。</p>
<p>桥位于桥上脑桥和桥下脑桥之间。桥脑桥在内侧盘区被分为两部分，分别为前，后或腹侧和背侧。桥包含锥体束，比中脑的锥体束更位于内侧和前方，以及三叉神经，外展肌，面部神经和前庭脉络神经和核。因此，必须了解脑桥中第五，第六和第七颅神经的内在和外在解剖结构（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig12/">12</a>）。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig12_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig12_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig12_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig12/">图12</a></p>
<p><strong>一个</strong>。脑桥的皮质脊髓束的地形（<em>黄色</em>）。VI（<em>绿色</em>）和VII（<em>橙色</em> / <em>红色</em>）颅对的核和过程。<strong>b</strong>侧面图。位于内侧马鞭草（ML）前面的腹桥和位于ML后面的背桥已经暴露。<strong>c</strong> pons的前视图。三角肌上（<em>1</em>）和三叉神经周围（<em>2）</em>）安全进入区用于位于腹桥的病变。在脊椎脑沟下方4 mm处做上神经上切口，矢状位与CN III的出口相同。三叉神经周围的切口位于CN V的进入区域的中间，并位于CN V和CN VII之间。<strong>d</strong>腹桥的侧面图。处于危险状态的神经关键结构是皮质脊髓束，三叉神经运动核和CN V–VIII的桥脑段</p>
<p>面神经围绕第六神经核行进。当通过菱形窝接近肿瘤时，必须很好地建立这种关系。三个动脉组为桥提供血液：前内侧，外侧和背侧。前内侧动脉来自基底动脉和末端椎动脉分支。这些动脉可滋养中上睑板（包括锥体束），内侧马鞭草，内侧纵向筋膜，网状结构和外展核。小脑上动脉（SCA），小脑前下动脉（AICA）和桥脑长动脉产生了穿孔侧支。它们提供小脑上皮梗，中央被膜束，列氏菌侧，蓝斑，运动和感觉三叉神经主要核，外展核，面核，上橄榄核，桥状网状核，盘生侧和锥体束。SCA终末分支包括脑桥的后动脉供应。他们灌注上小脑梗，三叉神经的中脑核和蓝斑[<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR55">55</a> ]（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig13/">13</a>）。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig13_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig13_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig13_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig13/">图13</a></p>
<p><strong>a</strong>后乙状结肠入路可用于三叉神经上和三叉神经进入区。<strong>b</strong>前乙状突入路为三叉神经上缘和三叉神经进入区提供了良好的暴露</p>
<h3 id="前桥">前桥</h3>
<p>前桥和上桥的肿瘤可使用眶额front合途径进行，这是Jane等人描述的眶上颅骨开颅术的一种改进。1982年[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR31">31</a> ]。第三颅神经是该方法的关键参考点。为了暴露桥的上部，有必要用腱鞘自由边缘的硬膜切开术解剖椎间孔和桥前池。入口点是原始的。在中脑桥脑沟下方从第三至第五颅神经的直线上切一个4毫米的垂直切口; 因此，我们将这种进入途径命名为“ supratrigeminal”。我们已经将该途径用于上腹部损伤，而没有额外的患者发病率（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig14/">14</a>）。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig14_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig14_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig14_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig14/?report=objectonly">在单独的窗口中打开</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig14/">图14</a></p>
<p><strong>a</strong>，<strong>b</strong> 8个月大的患者，在桥的前部和上半部有较大病变，通过眶上front行经上原肌进入区进入。<strong>c</strong>，<strong>d</strong>病变完全切除后6个月的术后随访</p>
<p>对于位于脑桥前部和下部的病变，或对于腹侧病变，已使用了乙状结肠前入路（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig15/">15</a>）。在脑桥的切口是在第五和第七颅神经的出现点之间纵向进行的。但是，该走廊太窄，仅适合活组织检查或清除其中的海绵状瘤。这种方法可以通过枕骨旁正中途径或岩相途径来实现。在脑桥的前入路中，第五神经出现周围的区域是一个安全区域，该区域应在距中线1 cm处打开1 cm宽，但应注意不要太前移以避免皮质脊髓束。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig15_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig15_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig15_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig15/?report=objectonly">在单独的窗口中打开</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig15/">图15</a></p>
<p><strong>a</strong>，<strong>b</strong> 10岁四肢轻瘫患者。肿瘤采用前乙状结肠入路手术。<strong>c</strong>，<strong>d</strong>完全切除后10年的术后控制，无肿瘤迹象</p>
<h3 id="后桥">后桥</h3>
<p>桥后病变通过菱形窝进入（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig16/">16</a>）。优越和后脑桥病变由telovelar路线访问，也称为小脑延髓裂入[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR42">42</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR43">43</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR46">46</a> ]。面神经上方脑干的开口称为上颌三角，由内侧纵向筋膜（即中沟）在内侧定义，由面神经尾部（以面部胶原作为参考）定义，由外侧上小脑梗。这个三角形大约是1 cm <sup>2</sup>。尽管这是一个安全的进入三角形，但谨慎地建议在表面上进行双极刺激以定位面神经的走向，这可能由于肿瘤的生长而偏离了方向。进入该区域的距离必须始终距中线2毫米，以保持内侧纵筋膜。但是，与部分面神经受累相比，该束损伤后的恢复非常快。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig16_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig16_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig16_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig16/?report=objectonly">在单独的窗口中打开</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig16/">图16</a></p>
<p>脑桥皮质脊髓束<strong>的</strong>地形图（<em>黄色</em>）。CN VI（<em>绿色</em>）和VII（<em>橙色</em> / <em>红色</em>）颅对的核和过程。<strong>b</strong>由CN VI核和CN VII的桥脑内节段产生的面部丘疹是第四脑室底部最重要的标志。<strong>c</strong>有四个避免损坏的重要结构：内侧纵筋膜（MLF），中央被膜束（CTT），三叉神经中脑（TMT）和脊柱（TST）。<strong>d</strong>后脑干安全区：_1个_胶束周围，_2 __个_筋膜上，_3个_界面，_4个_侧沟局限，_5个_下面部和_6个_中部。<strong>e</strong>面上进入区（<em>2</em>）的上方是含CN IV的腓肠葡萄膜缘，下方是面部胶束（FC），内侧是纵向纵筋膜（MLF），外侧是龈沟，外侧沟。<strong>f上</strong>中央凹，是由沟沟形成的凹陷，呈三角形（<em>绿色三角形</em>）。该三角形的顶点与面部眼睑的最上边缘在相同的轴向水平处。三叉神经运动核（<em>黄色圆圈</em>）位于该三角形的上外侧边缘的较深点。<strong>g</strong>面下进入区的上方是面部胶原，下方是舌下（CN XII）三角形，内侧是纵向纵束（MLF），中间是CN VII核和歧核。<strong>^ h</strong>。中枕下入路被用来到达第四脑室的底部。<strong>我</strong>切开了Telovelar交界处。<strong>j</strong>暴露于第四脑室的地板</p>
<p>该形貌在上，横向方向略微缩回，而应尽可能避免在尾端方向缩回（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig17/">17</a>）。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig17_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig17_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig17_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig17/?report=objectonly">在单独的窗口中打开</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig17/">图17</a></p>
<p><strong>a</strong>，<strong>b</strong>桥上和后桥肿瘤通过枕下小脑门入路进入，并通过point上三角进入桥脑。星形细胞瘤II级。<strong>c</strong>，<strong>d</strong>术后控制显示总切除</p>
<p>对于后部和下部病变，使用经下三角肌（图<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig18/">18</a>）的颈下途径，该三角肌  以内侧边界为内侧纵束，并以延髓纹尾部为界，面神经以外侧为界。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig18_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig18_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig18_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig18/?report=objectonly">在单独的窗口中打开</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig18/">图18</a></p>
<p><strong>a</strong>，<strong>b</strong> 5岁的桥脑病变患者通过面下入路接近。<strong>c</strong>，<strong>d</strong> 8年随访。星形细胞瘤</p>
<p>这是一个较小的三角形，安全距离并不总是相同，因此必须进行术中监护。如Kyoshima等人所述，进入颈下三角形的安全区域。[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR39">39</a> ]将从平均距上肢6.5毫米处开始，沿颅尾方向延伸9.2毫米；颈上三角在上颌骨上方平均22.5 mm，延伸13.6 mm。</p>
<p>当在菱形窝中没有发现空间时，我们使用了第三种方法，即界面方法。Bricolo和Turazzi [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR7">7</a> ]描述了菱形窝中线进入可能在面部神经丛的水平，靠近第六神经核，因为内侧纵筋膜的纤维尚未在该水平交叉。在这种方法中，内侧纵筋膜被破坏，这可能会干扰眼睛的共轭运动。从外科手术的角度来看，我们采用了双侧小脑入路，第四脑室的脉络膜丛凝结，从而可以从足尖到脑导水管充分进入，而无需损害小脑ver骨。</p>
<p>通过侧沟限制器也可以通过telovelar方法接近更多的侧部病变[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR40">40</a> ]。</p>
<p>劳顿等。[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR40">40</a> ]提出了上小脑上梗的上颌骨入路，而无需打开静脉室并进行扩大的小脑入路。已经针对海绵状瘤描述了该途径，但是对于延伸至中线的小脑下脚蒂的肿瘤病变可能就足够了。最好在神经导航的帮助下使用此技术。</p>
<p>因此，对于pons，我们有以下“安全区”：原始肌上，三叉神经周围，肌上，基底下，界面以及通过侧沟限界。</p>
<h3 id="髓质">髓质</h3>
<p>延髓是脑干的最尾部，它通过球囊沟与脑桥分开（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig19/">19）。</a>）。延髓的下限是腹面的金字塔形肉瘤和大孔。后表面是尖顶。它从椎动脉和脊柱前动脉的分支接收血液供应。前外侧穿孔动脉浸润锥体束和下橄榄核。外侧动脉是小脑后下动脉（PICA），小脑前小动脉（AICA）以及椎动脉和基底动脉的分支，它们灌注小脑下花梗，脊髓丘脑束，脊髓小脑中央束，椎管，视网膜迷走神经的背运动核，孤束核和束道，以及舌下，前庭，耳蜗，楔形和big义核。卵状和楔形的核，后区域和迷走神经，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR55">55</a> ]。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig19_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig19_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig19_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig19/">图19</a></p>
<p>橄榄状髓质<strong>的</strong>示意图，其中存在IX，X（<em>绿色和粉红色</em>），XI和XII（<em>红色</em>）颅对，以及皮质脊髓束道（<em>黄色</em>）的形貌与pons和中脑相比 <strong>b</strong>腹髓质。腹侧髓质的安全进入区是食管前和食管后沟。橄榄前沟位于橄榄和金字塔之间，而金字塔是CST所在的地方。橄榄上凹陷的凹陷，即上眼窝突节，正好位于面部和前庭静脉神经与脑干交界处的下方。舌咽，迷走神经和副神经离开橄榄核正下方的延髓，位于橄榄和小脑小脑梗（ICP）之间。舌下根沿着小窝前沟离开延髓。<strong>c</strong>远侧入路用于卵巢前和后沟。<strong>d</strong>背髓质。后中位（PMS），中位（PIS）和后外侧（PLS）沟已被建议作为安全进入区。枕下正中入路</p>
<h3 id="延髓前">延髓前</h3>
<p>髓质可能是最难接近的结构，因为位于其中的IX至XII颅神经对的细胞核密度很高。位于髓质前部的病变可通过远侧入路进入。最初由Heros [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR27">27</a> ]和George等人描述了这种方法。[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR21">21</a> ]在颅脑交界处。根据要切除的con的部位，方法有很多变化：trans突、,上和para旁暴露[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR56">56</a> ]。对于儿童，可以在不去除the的情况下进入髓质的前部（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig20/">20）。</a>）。齿状韧带靠近椎动脉入口的部分有助于髓质的活动性，因此侧向进入变得更容易，因为它避免了开放opening。访问脑干可以是前橄榄，后橄榄，或有时通过橄榄体，优选地在后-橄榄沟（图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig20/">20</a>和<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig21/">AND21）。</a><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig21/">21</a>）。可以通过前外侧沟进入延髓。该进入区沿乳腺前沟，位于尾部舌下和头侧C1小根之间。它位于锥体束附近，靠近椎体折返处，仅应用于胞外病变[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR9">9</a><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR9"></a>]。橄榄后沟是一个安全的进入区域。据雷卡尔德等。[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR53">53</a> ]，橄榄体在颅尾轴上提供大约13.5 mm的手术空间，在横轴上提供大约7 mm的空间，在前闻轴上提供大约2.5 mm的手术空间。进入区穿过橄榄后沟，位于橄榄和小舌根下腹腹面至舌咽和迷走神经小根之间[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR53">53</a> ]。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig20_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig20_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig20_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig20/?report=objectonly">在单独的窗口中打开</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig20/">图20</a></p>
<p><strong>a</strong>，<strong>b</strong> 2岁患者发展为四肢瘫痪。存在髓质前部的大肿瘤。远侧入路和经橄榄石切入点用于切除细胞性星形细胞瘤。<strong>c</strong>，<strong>d</strong>十一年随访，未显示肿瘤证据</p>
<p><a href="https://www.ncbi.nlm.nih.gov/core/lw/2.0/html/tileshop_pmc/tileshop_pmc_inline.html?title=Click%20on%20image%20to%20zoom&amp;p=PMC3&amp;id=4564452_381_2015_2799_Fig21_HTML.jpg"><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig21_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig21_HTML.jpg" title="点击图片放大"></a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig21/">图21</a></p>
<p><strong>a</strong>，<strong>b</strong>在第四脑室有外生性延伸的颈髓肿瘤。术后5年的<strong>c</strong>，<strong>d</strong> MRI无肿瘤迹象</p>
<h3 id="后延髓">后延髓</h3>
<p>髓质后部的内在病变很难接近，因为该区域的细胞核数量巨大。另一方面，其中的大多数损伤具有外生成分，这有助于进入。这些肿瘤称为宫颈髓样。可以通过中线穿过后正中沟进入下位点下方的髓样病变，而髓内病变也是如此。</p>
<p>在术中，可能发生严重的营养改变，例如右侧的髓质病变为高血压和心动过速，左侧的髓质病变为心动过缓。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/" title="转到此页面的其他部分">去：</a></p>
<h2 id="结果-2">结果</h2>
<p>从1991年到2011年，我们评估了303名年龄在18岁以下，肿瘤位于脑干的患者，这些患者位于圣保罗联邦大学小儿神经外科服务中心和儿科肿瘤研究所。96例为扩散性肿瘤，接受了化学疗法/放射疗法。本文的第一作者对其余207例患者进行了手术，占同期该服务手术的所有患者（2015年患者）的9.1％。年龄从8个月到18岁不等，平均年龄为10岁。在这些患者中使用了之前描述的所有“安全区”，而在三名患者中，对于前桥和上桥的肿瘤，使用了一个新的“安全区”，即所谓的上皮肌瘤。一百例患者未进行术中监护，而有107例进行了监护。 <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/table/Tab1/">1</a>。</p>
<h3 id="表格1">表格1</h3>
<p>根据地形，方法，安全区入口点和发病率/死亡率划分的207例手术病例的分布</p>
<table>
<thead>
<tr>
<th>地形</th>
<th>师</th>
<th>方法</th>
<th>安全区入口点</th>
<th>发病率/死亡率</th>
</tr>
</thead>
<tbody>
<tr>
<td>中脑（84）</td>
<td>前部（16）</td>
<td>经室经孔内镜入路（6）</td>
<td>外生性病变</td>
<td>没有</td>
</tr>
<tr>
<td>翼状或额-融合go突入路（10）</td>
<td>眼动马达（10）</td>
<td>没有</td>
<td></td>
<td></td>
</tr>
<tr>
<td>中位数（59）</td>
<td>腹下sup上小脑（53）</td>
<td>中位数（41）</td>
<td>颈上和/或颈下</td>
<td>-空气栓塞（2）-</td>
</tr>
</tbody>
</table>
<p>高血压性
脑室（10）
-震颤（2） |
| 半正中（12） | 中脑外侧沟 |
| ten下上臂小脑结合Telovelar入路（6） | 颈上和/或颈下 | 没有 |
| 后方（9） | 枕骨下颌（8） | 外生性病变 | 没有 |
| ten下上臂小脑结合小脑入路（1） |
| 庞斯（72） | 前部（11） | Fronto-obito go行transylvian方法（3） | 三叉神经上（3） | 没有 |
| 乙状结肠（8） | 原始的（8） | 没有 |
| 后方（61） | 枕下颅骨开颅手术，采用小脑入路（61） | 面部上的（45） | -MLFI（6）- 
面部轻瘫（3）- 
死亡（1） |
| 界面（3） | -MLFI *（2） |
| 面下（13） | 面部轻瘫（9） |
| 灯泡（51） | 前部（11） | 远侧方法（11） | Transolivar | 没有 |
| 后方（40） | 枕骨下开颅配合Telovelar入路（40） | 中线 | -死亡（3）-呼吸
和吞咽障碍（9）
-声带不协调（2） |</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/table/Tab1/?report=objectonly">在单独的窗口中打开</a></p>
<p>_MLFI_内侧纵筋膜损伤</p>
<p>84名患者患有中脑肿瘤。十六个位于中脑的前部，59个位于中脑中央，九个位于四头肌板中。6例肿瘤位于前部并延伸至第三脑室的患者接受了纯净的神经内窥镜检查，并配有超声抽吸器设备（Sonoca 300和92–030微型手机-Söring）。所有病变均为外生性的，无需切开脑干。肿瘤出血不多，可以用低功率的超声吸引器轻松吸出。这些患者的主要临床表现是因脑积水引起的颅内高压。所有肿瘤均为毛细血管星形细胞瘤，无需完成心室分流即可完成切除。十例中脑前部肿瘤延伸至椎间窝窝的患者通过经椎弓根入路手术。对于外生性肿瘤，通过经典的翼状ional肉获得了6次通入，通过额眶眶go合术获得了4次通入，并且进入脑干的通路位于第三神经的侧面（周期性运动进入）。对于中部中脑（59例），有53例患者在坐位时经bell上下臂入路入路，中位41例，中位12例。在六例患者中，通过合并中上小脑下肌下肌入路和通过枕形颅窝进入枕​​下下颌小路，实现了入路。对于内侧上小脑腓肠肌入路，在所有情况下小脑中枢静脉均已凝结，未发生并发症。在旁中位通路中，小脑前中央静脉的凝结是没有必要的，而脑干的进入点是通过外侧中脑沟。两名患者发生了空气栓塞，需要通过中央静脉导管进行抽吸以解决该问题。进气点位于乙状窦附近的横窦，这是硬脑膜开口的最高和最侧向的点。十名患者患有高血压的脑室，其中两名接受了神经内镜检查。两名患者患有氯硝西controlled控制的手部震颤。9例患者的四肢椎板肿瘤，其中8例通过四分之三俯卧位进行手术，另外1例通过in下上臂小脑和枕后小脑下入路联合手术。所有中脑肿瘤均为低度星形细胞瘤，</p>
<p>在168例脑桥肿瘤患者中，有96例为弥漫性且未进行手术。手术切除了72个肿瘤。肿瘤位于前桥和上桥的4例，前桥和下桥的7例，上桥和后桥的48例，下桥和后桥的13例</p>
<p>对位于前桥和上桥的三个肿瘤采用额眶-合手术，脑干进入点位于上颅骨上方，在第三颅神经和三叉神经之间，距中脑桥脑沟以下4 mm。一例采用乙状结肠前手术治疗。这些在脑桥的前部和上半部均患有肿瘤的患者均未发病。在七例中，肿瘤位于桥的前部和下部，并通过乙状结肠前路进入。48个肿瘤位于后桥和上桥，十三个肿瘤位于桥的后桥和下桥。所有位于桥脑后部的肿瘤均通过一条经鼻菱形窝的条状路径进行手术，患者处于俯卧位。上桥和后桥的肿瘤有45个，通过面上通路进行治疗，其中3例使用了在面部上丘上方的界面通路。在6例采用经上路手术的患者中，有3例发生了内侧纵筋膜和面部轻瘫的损伤。在所有情况下，术后6个月症状都会消退。一名患者发生了急性脑积水，并在3天后死亡。在使用界面途径进行手术的三例中，两个发展中的内侧纵筋膜损伤症状在6个月内消失。没有观察到面神经受累。13名患者在桥的后部和下部有肿瘤，并通过面下途径进行手术。其中八名患者出现面瘫，5例导致永久性瘫痪。III级和IV级星形细胞瘤22例，低级星形细胞瘤50例。</p>
<p>51名患者患有髓样肿瘤，其中11个位于前部，40个位于所谓的子宫颈髓交界处。使用远侧入路进入前部肿瘤，其进入点通过橄榄髓延髓途径或外生性肿瘤所在。在所有情况下均使用该途径进行齿状韧带切除术。宫颈肾小球交界处肿瘤采用中腹线纵向切开的髓腔的条状小路手术。9名患者出现呼吸和吞咽恶化。3例患者仍处于呼吸衰竭，并在手术后2个月内死于肺炎。两名患者由于声带不协调而需要进行永久性气管切开术。在髓样肿瘤中，有8个是神经节神经胶质瘤，3个是血管母细胞瘤，29个是星形细胞瘤，8个是III级和IV级星形细胞瘤，</p>
<p>对于整个207例经脑干手术治疗的肿瘤系列，术后头2个月的手术死亡率为1.9％（4例），而手术发病率为21.2％（45例）。本系列中的所有中脑肿瘤均为低度星形细胞瘤。在脑桥中，有50例为低度星形细胞瘤，22例为高度肿瘤。在51个髓样肿瘤中，只有8个是高度星形细胞瘤。因此，在207例脑干肿瘤患儿中，有30例（占14.4％）是高度恶性肿瘤，而有177例是低度恶性肿瘤。随访时间为3至20年，平均13年。良性肿瘤的无病生存期（5年）为92％，而高级神经胶质瘤的中位生存期为18个月。表  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/table/Tab1/">1</a> 总结了207例患者中使用的患者和安全区入口。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/" title="转到此页面的其他部分">去：</a></p>
<h2 id="讨论区">讨论区</h2>
<p>儿童比成人更常见脑干肿瘤。很少有出版物谈到儿童脑干肿瘤的手术方法。它们中的大多数与外科治疗海绵状瘤的脑干方法有关。在这个位置切除海绵状瘤的手术与切除脑干肿瘤的手术有很大不同。海绵状瘤的一个特殊特征是，由Virchow-Robin空间的扩大和凝块的固结所产生的空腔在去除凝块后会引起较大的空间，从而有利于海绵体瘤的切除。因此，在脑干表面的小切口足以去除肿大的海绵状瘤。在脑干的小儿肿瘤中，第一个缺点是与成年人的脑干相比，其结构非常小，除了罕见的囊性病变。另一方面，</p>
<p>高分辨率MRI和MRI结合对诊断的改善，对于手术决策以及选择最安全，更精确的手术方法非常有帮助。神经麻醉学，术中电生理监测和术后重症监护的进步提供了更高的安全性，允许进行更具侵略性的手术切除并防止损伤[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR61">61</a> ]。</p>
<p>神经外科手术器械也已显着发展。今天，我们拥有高亮度的显微镜，其清晰度可以更好地识别肿瘤的结束位置和正常组织的开始位置。带有钻石尖端手术刀的更轻巧，更精致的器械可以精确切开脑干。常规使用带有1毫米尖端的超声外科手术吸气器，使我们能够通过脑干的小开口去除较大的病变。与脑干解剖学的内在和外在知识相关的最合适的获取途径的手术计划，也是取得手术成功的关键。</p>
<p>脑干通常分为三部分：中脑，脑桥和延髓[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR41">41</a> ]。我们进一步将脑干分为七个部分：中脑前部，中部和后部。前桥和后桥; 和前，后延，这帮助我们选择最佳的手术方式[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR11">11</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR12">12</a> ]。</p>
<p>Cantore等。[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR9">9</a> ]将脑干分为两个手术平面-前部和后部。因此，他们将脑干中的六个区域分类。我们将中脑分为三部分的原因是因为四边形板块肿瘤的特征不同于前脑和中脑的特征。四边形板中的大多数肿瘤是惰性的，很少需要手术，将治疗局限于脑积水的控制[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR13">13</a> ]。</p>
<p>Four “safe entry zones” for the midbrain have been described. The most complex and anterior, called the perioculomotor zone, has been described by Bricolo et al. [<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR8">8</a>] There is a space between the oculomotor nerve and the pyramidal tract which can be accessed through an incision parallel and lateral to the oculomotor nerve. The presence of a tumor may increase this distance, facilitating surgery. When tumors have an exophytic component, the brainstem can be directly entered through the tumor. Clinically, these patients present preoperatively with third cranial nerve paralysis and contralateral pyramidal involvement (Weber syndrome) that usually disappears quickly after lesion removal. Small tumors only cause diplopia.</p>
<p>在我们的系列中，中脑的前部有16个肿瘤。六个正在向III脑室生长，并通过纯净的神经内窥镜和超声吸引器进行手术。我们发现很少有文献报道单纯使用神经内镜方法切除脑干肿瘤。Miki等。在6例腹侧脑干表面病变中使用了神经内镜经第三脑室入路[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR45">45</a> ]，而在1例中使用了脑干肿瘤。</p>
<p>在我们系列的十名患者中，肿瘤向椎间盘水箱生长。这些肿瘤中有六种是外生性的，大的，并通过经典的翼状route肌途径打开了西尔维安裂缝并去除了病变。有时很难在年幼的儿童中广泛打开Sylvian裂痕，简单的精细操作会引起血管痉挛，因此经常使用罂粟碱。在四名患者中，肿瘤是内在的，并且通过动眼神经通路接近了脑干。在所有情况下，均采用额眶眶zy合方法。我们还可以使用佐野（Sano）在1980年描述的颞极通道[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR58">58</a>]，它提供了椎间窝的前外侧视图。这些是我们用于中脑前部，通过第三脑室或通过毛细血管运动空间进入的通路。Konovalov和Kadyrov [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR35">35</a> ]提出了通过脉络膜颞部进入这些位于中脑的前外侧病变的途径，尤其是在占优势的一侧以及当肿瘤扩展到周围水箱时。事实是这些病变在这种地形中非常罕见。在我们的系列研究中，只有7％被认为是外科手术的肿瘤位于中脑的前部。尽管Albright 1993 [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR2">2</a> ]报告说脑干肿瘤中只有7-8％位于中脑，但Yasargil的<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR64"> [64]</a>]系列167例脑干肿瘤中，有26例（占15.5％）位于中脑，是Albright报道的两倍[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR2">2</a> ]。Garzon等。[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR20">20</a> ]发现33.8％的脑干肿瘤位于中脑。在我们的207例外科手术病例中，有84例位于中脑（40.5％），但是如果考虑到所有由我们服务治疗的脑干肿瘤病例，则这一比率下降到27.7％。我们认为这是因为我们是神经外科的参考中心，而不是弥漫性桥脑肿瘤的转诊病例。</p>
<p>在1911年，克劳斯（Krause）描述的59例中脑中枢肿瘤患者通过ten下上小脑途径手术[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR36">36</a>]，其中位数为41，中位数为12。通过准中线进近时，我们使用了与中值进近相同的通路。唯一的区别是脑干可通过外侧中脑沟进入。六例患者的肿瘤不仅朝着第三脑室生长，而且还朝着第四脑室生长，他们通过联合方法进行了手术，即在下脑室上腓肠肌，然后跨第四脑室进行枕下cip骨小脑入路。所有患者均在头部弯曲的坐姿下进行手术。进行后颅窝开颅手术，打开硬脑膜以避免枕窦，后者通常在幼儿中使用。在所有情况下都删除了C1拱门。Yasargil [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR64">64</a>]主张通过不移走C1足弓并在垂直于横窦的下方2 cm处打开硬脑膜，从而避免小脑进一步暴露以避免可能的椎间盘突出，从而进入该区域。在我们的系列中，我们没有小脑疝。Vermian静脉是小脑腱膜与腱膜和横窦之间的桥接静脉，没有任何并发​​症[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR55">55</a> ]。必要时，我们还凝固了小脑中央静脉，没有任何临床影响。在两个病例中，患者出现症状性空气栓塞，通过中心线并在靠近横窦的硬脑膜切口顶部的静脉开口的识别中，通过血液抽吸消除了症状。</p>
<p>9例四原发性板状肿瘤患者接受了手术，其中8例通过枕下经深部途径，另外1例通过合并下in上小脑和枕下小脑部途径。在四例颅神经上方，有四例进入上丘脑，五下处于下丘脑。对于中脑中央或后部向第三脑室方向生长的肿瘤，我们采用了小脑后上肌下肌入路。对于生长到第四脑室的肿瘤，我们在四分之三位置采用经枕后入路。当病变长到第三和第四脑室时，我们采用了联合通路。</p>
<p>Ogata和Yonekawa [ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR47">47</a> ]提出了一条上，下，下小脑梗的皮下旁神经通路。他们证明有可能打开小脑中脑裂隙外侧的小脑中间花梗表面。</p>
<p>通往桥前部的方法最为困难。Bagahai等。[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR5">5</a> ]描述了在第五和第七颅神经的输出点之间的脑桥腹侧部分的安全进入区域。但是，该走廊非常狭窄，仅适用于该区域的活检或海绵状海绵状切除术。可以通过枕骨旁中位途径或少量途径达到这种通路。在通往前桥的其他通路中，第五个颅神经出现周围的区域是一个“安全”区域，可以向中线开1厘米宽1厘米。但是，应注意不要向前走，以免发生皮质脊髓束。</p>
<p>我们的11位患者前桥有肿瘤。前位和上位四个，前位和下位七个。通过额眶-关节入路进入了三个前部和上部肿瘤，进入病变点的是一个垂直切口，该切口位于中脑骨膜沟以下4毫米，与第三条神经的方向相同。在使用该途径手术的三名患者中，发病率没有增加。这种方法在文献中没有类似的描述，我们更喜欢称其为“上原始途径”，以区别于第五和第七颅神经之间的三叉神经途径。实际上，这个新的切入点位于锥体束内侧的第三和第五颅神经之间。腹桥的其他肿瘤采用乙状结肠前切除术治疗，</p>
<p>在后桥中有61个肿瘤，其中48个位于上桥骨，13个位于下桥骨。如Kyoshima等人提出的，通过上颌三角形接近上肿瘤。[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR39">39</a> ]，或者在外侧病例中，通过外侧沟局。在三例患者中，由于菱形窝中的肿瘤引起的畸变，通过刺激面神经来定位切入点极为困难。因此，切入点是一种优于面部胶原的界面通路，如Bricollo和Taruzzi所述[ <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR7">7</a>]。但是，两名患者的内侧纵筋膜受伤。通过面下三角手术治疗了13例脑桥下肿瘤。通过这种途径手术的八名患者出现了面瘫，其中五名是永久性的。我们认为，这条路线仅应保留给小型外生性肿瘤或海绵体瘤。由于该区域具有高密度的颅神经核，因此也应避免通过位于延髓纹下方的菱形窝进入。所有进入菱形窝的操作都是通过枕下途径进行的，并去除了C1弓和特洛韦勒方法，有时是双侧的，以避免打开小脑mis骨。病人的位置是腹侧卧位。</p>
<p>髓样肿瘤与脑桥肿瘤存在相同的技术难度。前枕骨通过枕下远侧颅骨切开术，切除C1弓和靠近椎动脉进入颅骨的齿状韧带部分。韧带的这一部分允许髓质进一步移动，从而有助于识别橄榄体并通过后橄榄沟进入脑干（或经橄榄石进入）。右侧的髓腔通入通常会产生术中高血压和心动过速，而左侧的通道会产生心动过缓。绝不能用诸如阿托品或降压药之类的药物来抑制这些自然警报，因为它们表明我们过于积极地操纵了脑干。这些是需要引起注意的间接生理警报。通常，这些植物性风暴在病变受牵拉时发生，应避免。相反，我们应该使用超声波抽吸器去除肿瘤，避免牵引。这些小的植物风暴不是中断程序的原因，因为它们在停止牵引和用温盐水灌溉后会立即停止。</p>
<p>位于枕骨后部的病变也可通过枕骨小门入路进行操作，延髓通过后内侧沟到达小肠下方中线。</p>
<p>脑干中有11个先前描述的“安全”进入区域。在本文中，我们描述了另一个区域，即“前上皮”，用于前桥和上桥脑损伤。该途径用于三例患者，未显示发病率。因此，这是一条合理的访问路线。但是，需要广泛的额中眼眶zy入入入来检查中脑足底沟和第三颅神经。</p>
<p>由神经外科医生来选择正确的途径以最小的发病率进行完整的病灶切除。但是，发病率仍然很高（在我们的系列中为22％）。脑干肿瘤术后脑积水一直是灾难性并发症，神经外科医生应始终意识到这种可能性。我们的一名患者死于脑积水。因此，在可能的情况下，我们会在术后头48小时内放置一个外部心室引流管。</p>
<p>脑干不允许牵引或凝结。因此，我们通常使用吸气少且尖端细腻的超声吸气器，仅在进行大量灌溉的情况下才进行双极电凝作为最后手段，因为热量可能会损坏脑干的脆弱结构。</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/" title="转到此页面的其他部分">去：</a></p>
<h2 id="结论-2">结论</h2>
<p>脑干手术是神经外科中最困难的手术之一，尤其是对于小儿神经外科医生，因为儿童时期脑干肿瘤比成人时期更为常见。尽管使用束线照相术的影像学已显着发展，但它们仍未显示脑干内部的核和神经通路。解剖解剖由Klingler的的技术，研究白纤维，帮助神经外科医生在规划的手术方法[三维建筑设计<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR1">1</a>，<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/#CR34">34</a>]。在脑干中有11个先前描述的“安全进入区”：牙周运动，外侧中脑沟，下颌入路，上颌上入路，三叉神经，上颌面，界面，下颌面，外侧沟限，唇周和后中沟。我们的三名患者使用了一个新的安全进入区，即“上原始区”，用于接近桥上和桥上病变。图  <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig22/">22</a>总结了接近安全区域的算法。也许在不久的将来，随着高分辨率7 Tesla MRI的改进，或另一种类型的成像能够显示出由于肿瘤的作用而导致的脑干结构中的精确偏差，再加上更有效的电生理监测系统，这类手术可能会变得更简单，发病率更低。当前，对脑干的内在/外在解剖学的更准确的了解与更先进的工具（如高分辨率显微镜和尖端较薄的超声吸气器）相关联，已使我们能够从任何患者中去除大量具有可接受的死亡率和发病率的脑干肿瘤在这个奇妙的大脑结构中的地形。</p>
<p><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/bin/381_2015_2799_Fig22_HTML.jpg" alt="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig22_HTML.jpg" title="包含图片，插图等的外部文件。对象名称为381_2015_2799_Fig22_HTML.jpg"></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/figure/Fig22/">图22</a></p>
<p>接近安全区的算法</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4564452/" title="转到此页面的其他部分">去：</a></p>
<h2 id="致谢">致谢</h2>
<p>作者要感谢Blanche Torres女士帮助我们撰写了这份手稿，并感谢StharMar de Vasconcelos Silva先生提供了艺术作品。</p>
<h3 id="利益冲突">利益冲突</h3>
<p>作者宣称他们没有竞争利益。</p>
<h3 id="资金和物质支持">资金和物质支持</h3>
<p>没有。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[颞下入路]]></title>
        <id>https://lizhenzhublog.github.io/HTML/post/1SM-ibZ3Z</id>
        <link href="https://lizhenzhublog.github.io/HTML/post/1SM-ibZ3Z">
        </link>
        <updated>2019-10-05T05:48:06.000Z</updated>
        <content type="html"><![CDATA[<p>这个技术是指颞下keyhole开颅经硬膜外入路显露颞骨上面。这种颞下入路的变型之目的是打开IAC，显露面神经、上前庭神经、耳蜗神经和下前庭神经。</p>
<p>https://v.qq.com/x/page/n0354yj00dq.html#</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810152908_29gfjyt5ia.jpg" alt="" title="1.webp.jpg"></p>
<p><strong>图示经颞下开颅显露内听道。在仔细去除内听道顶壁后，显露面神经、上前庭神经、耳蜗神经和下前庭神经</strong></p>
<p>在弓状隆起处仔细辨认岩浅大神经和上半规管后，整个内听道的走行就可准确的勾画出来，这样有利于避免损伤敏感脆弱的前庭耳蜗结构。按照William F. House和Ugo Fisch的方法标记“蓝线”。用小磨钻（磨除时注意要不断地持续冲水）部分去除弓状隆起的浅表骨质。弓状隆起的下方即为上半规管。“蓝线”和岩大神经共同勾画出内听道的走行。</p>
<p><strong><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810152923_km06oc7wk7.jpg" alt="" title="2.webp.jpg"></strong></p>
<p><strong>左侧。在辨认GSPN和蓝线（即上半规管）后，就可准确的勾画出IAC的走行。</strong></p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810152945_kp29xeatke.jpg" alt="" title="3.webp.jpg"></p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810152945_ljbwfgqr8x.jpg" alt="" title="4.webp.jpg"></p>
<p>位于IAC内并向CPA生长的小听神经瘤（直径&lt;5mm），可用这个手术入路切除之。当肿瘤完全位于内听道内时，尤为适合。这个手术入路的目的是：在完成肿瘤全切的同时，保护听力维持在术前水平以及正常的面神经功能。有时，前庭功能也能保留。</p>
<p>如上所述，颞下入路的优势在于可以提供显露内听道的途径。而如果将开颅的范围向前延伸，打开颞颅底硬脑膜后，就可显露鞍上和桥小脑结构。</p>
<p><strong>手术技术</strong></p>
<p><strong>1. 手术体位和术中监护</strong></p>
<p>全麻后，放置腰大池引流管。硬膜外操作前的最重要的步骤就是充分释放脑脊液，以降低颞叶的张力。除了放腰大池引流外，还有一种方法--在从硬膜外牵拉、抬高颞叶前，先在硬膜脑上切开一小口，释放脑脊液。</p>
<p>面神经肌电图是最基本的术中监测，有利于安全显露内听道的硬脑膜。通常，从解剖上比较容易识别面神经，而术中监测可确保在肿瘤切除过程中面神经能得以无损伤保护。</p>
<p>患者仰卧位，头部上抬高于胸骨平面，同侧肩部垫高；Mayfield头架固定，单钉置于额部，可避免其妨碍手术操作。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153010_r5u2lcc27i.jpg" alt="" title="5.webp.jpg"></p>
<p>Step 1：头部抬高，高于胸部，以利于颅内静脉回流，并可有效的减轻颈部结构压力。与颞下前、后入路相比，头部抬高的角度应更大，这样可更好的显露IAC。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153037_1kjct8vl9p.jpg" alt="" title="6.webp.jpg"></p>
<p>Step 2：随后，将头部向对侧旋转80°。这时，IAC的方向应是垂直的，这样方便解剖定位和手术操作。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153050_ek6m8xlgpy.jpg" alt="" title="7.webp.jpg"></p>
<p>Step 3：头部侧屈10°-15°，有利于依靠重力牵拉颞叶。与颞下前、后入路相比，这种硬膜外路径所需要的侧屈角度可小一些，方便IAC的显露。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153102_korsqejhhp.jpg" alt="" title="8.webp.jpg"></p>
<p>Step 4：与颞下前、后入路一样，头部后伸10°，这可使术者操作舒适。此外，轻微的后伸还可避免气道、喉部和颈部血管受到过度挤压。</p>
<p><strong>2. 解剖标记和定位</strong></p>
<p>这个手术入路需要掌握的关键解剖结构有：眶外侧缘、颧弓、关节结节、外耳道、乳突和乳突上嵴。注意：耳颞神经和颞浅动脉的走行。</p>
<p><strong><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153226_ugvf3v4r26.jpg" alt="" title="9.webp.jpg"></strong></p>
<p><strong>图示颞颧区关键解剖结构和开颅位置。骨窗中心应置于EAC水平，皮肤切口位于耳前、颞浅动脉后方。</strong></p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153247_wrx6tlfvho.jpg" alt="" title="10.webp.jpg"></p>
<p>标记关键解剖结构后，就可确定手术切口和开颅位置。骨窗的基底对应于乳突上嵴；骨窗的中心对应着EAC。骨窗面积约25x25mm，需充分显露IAC；直型手术切口长约5cm，位于耳前，避免损伤耳颞神经和颞浅动脉。</p>
<p><strong>3. 开颅</strong></p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153510_gat44q8xmw.jpg" alt="" title="11.webp.jpg"></p>
<p>Step 1：左侧。耳屏前直切口，分离颞浅动脉和耳颞神经，然后向前牵开并保护之。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153544_9p22clgi9m.jpg" alt="" title="12.webp.jpg"></p>
<p>Step 2：乳突牵开器牵开。”Y”型切开颞肌筋膜，显露颞肌。注意：将颞浅动脉向前方移位牵开。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153602_elxu1tkyy5.jpg" alt="" title="13.webp.jpg"></p>
<p>Step 3：如图所示牵开、固定筋膜，显露颞肌。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153622_hq8c2ufcyq.jpg" alt="" title="14.webp.jpg"></p>
<p>Step 4：钝性剥离子从下方乳突上嵴和颧弓处剥离颞肌，显露颞骨鳞部。颞肌后部通常较薄，因而没必要切开即可充分显露颞骨。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153650_jq0e9xjklp.jpg" alt="" title="15.webp.jpg"></p>
<p>Step 5：于乳突上嵴后部钻孔一个，即打开中颅窝。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153714_vhgh0mty4x.jpg" alt="" title="16.webp.jpg"></p>
<p>Step 6：适当扩大骨孔，铣刀先自后向前、与颧弓平行铣开颅骨。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153754_isct1fvbro.jpg" alt="" title="17.webp.jpg"></p>
<p>Step 7：再从骨孔处“C”型游离骨瓣，宽约25mm、高约25mm。这里要注意，骨瓣高度必须保证2.5cm，方可良好显露内听道。此操作要注意避免损伤硬脑膜。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153811_y8wujqr7e8.jpg" alt="" title="18.webp.jpg"></p>
<p>Step 8：如术前未放置腰大池引流，那么就需在硬脑膜上切一小口，打开脑皮层表面的蛛网膜下腔，释放脑脊液。如此，可最大程度的降低颞叶牵拉的力度。去除骨瓣后，小磨钻磨除骨窗下缘的内板（此部操作应注意保护好硬脑膜），这样可增加手术视角和操作自由度。如乳突气房开放，应严密封堵。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153827_wus7wl694d.jpg" alt="" title="19.webp.jpg"></p>
<p>Step 9：仔细剥离颅底硬脑膜，并牵开，显露中颅窝底。</p>
<p><strong>4. 硬膜外-硬膜下操作</strong></p>
<p><strong><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153856_okbip6rlck.jpg" alt="" title="20.webp.jpg"></strong></p>
<p>Step 1：左侧。新鲜尸体标本。牵开硬脑膜后，显露岩浅大神经（GSPN）。仔细游离GSPN，于其前缘可见MMA及棘孔。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153915_12362rxmg1.jpg" alt="" title="21.webp.jpg"></p>
<p>Step 2：进一步牵开硬脑膜，显露岩骨嵴和弓状隆起。用小磨钻部分磨除覆盖上半规管的薄层骨质，目的是为了精准定位。上半规管蓝线（结合岩大神经）可精确的界定内听道的走行。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810153934_h51607svob.jpg" alt="" title="22.webp.jpg"></p>
<p>Step 3：根据上述的解剖定位，小磨钻打开IAC。注意：蓝线、GSPN和磨钻方向之间的相互关系。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154000_g70xwiujfj.jpg" alt="" title="23.webp.jpg"></p>
<p>Step 4：显露IAC硬脑膜和后颅窝，显微椎板咬骨钳去除深部骨质。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154017_lbf0kr8be6.jpg" alt="" title="24.webp.jpg"></p>
<p>Step 5：打开硬脑膜即可见前庭上神经和面神经。注意观察AICA的环襻，背景亦可见脑干，颞下入路最大的优势就在于——可清楚的显露IAC及其内容物。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154035_hwsb2jh08x.jpg" alt="" title="25.webp.jpg"></p>
<p>Step 6：向前进一步磨除岩尖，即可显露脑干的外侧面。注意观察：外展神经穿行于Dorello管。特别需要注意的是：勿损伤耳蜗。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154054_r11m64blxo.jpg" alt="" title="26.webp.jpg"></p>
<p>Step 7：打开颞下硬脑膜，切开小脑幕，显露环池结构。注意观察：Dandy岩静脉，用显微剪刀分离滑车神经周围的蛛网膜。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154114_ybrllmhjfx.jpg" alt="" title="27.webp.jpg"></p>
<p>Step 8：继续向前分离，进入桥脑的腹外侧面。注意观察：滑车、三叉神经以及BA。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154139_cl5aid7yp6.jpg" alt="" title="28.webp.jpg"></p>
<p>Step 9：切除Dandy岩静脉后，可充分显露动眼、滑车和三叉神经。注意观察：BA主干以及SCA双干。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154157_a77ntvhir6.jpg" alt="" title="29.webp.jpg"></p>
<p>Step 10：观察BA顶端的SCA及P1段、动眼和滑车神经。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154216_b7btk5m4gt.jpg" alt="" title="30.webp.jpg"></p>
<p>Step 11：切除岩尖、分开小脑幕后，显露桥脑前外侧面。充分显露BA主干、从AICA到SCA、动眼神经、滑车神经、三叉神经以及外展神经。</p>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154235_uf5cgvtk1r.jpg" alt="" title="31.webp.jpg"></p>
<p>Step 12：再向后方探查，观察三叉、外展和面听神经之间的关系。</p>
<p><strong>5. 关颅</strong></p>
<p>完成颅内操作后，硬膜下生理盐水冲洗。此处硬脑膜水密缝合几乎不可能，但也需仔细缝合，有助于后颅窝硬脑膜重建。颞肌及筋膜的严密缝合可有效的避免术后脑脊液漏，并可封堵内听道骨缺损。部分病例还可于硬膜外使用腹部脂肪修补。钛片固定骨瓣。彻底止血后，间断缝合颞肌、筋膜，皮内连续缝合头皮。因切口较小，不必也不推荐放置引流管，以避免术后脑脊液漏。</p>
<p><strong>手术风险</strong></p>
<ul>
<li>
<p>术前计划不详细、手术体位摆放不合适均可影响术野的显露。</p>
</li>
<li>
<p>耳前神经血管损伤。</p>
</li>
<li>
<p>当乳突气房开放无法避免时，应严密封堵，以避免术后脑脊液鼻漏和脑膜炎。</p>
</li>
<li>
<p>开颅时损伤硬脑膜，尤其是老年人。这并不一定会造成严重后果，但有时会使硬膜外操作变得复杂。在完成颅内操作后，应间断或连续缝合硬脑膜。</p>
</li>
<li>
<p>脑压板牵拉颞叶可造成脑组织损伤。合适的手术体位，早期释放脑脊液（可通过打开皮层蛛网膜下腔或术前放置腰大池引流）可有效地避免此并发症。</p>
</li>
<li>
<p>硬膜外牵拉时可损伤岩浅大神经和岩浅小神经，通常不会产生严重神经功能障碍。</p>
</li>
<li>
<p>上半规管损伤可造成前庭功能障碍，出现暂时性恶心、呕吐。耳蜗损伤可造成术后同侧耳聋。</p>
</li>
<li>
<p>IAC内面神经损伤可导致术后面瘫。</p>
</li>
<li>
<p>中后颅窝神经血管损伤可造成术后相应神经功能障碍。</p>
</li>
<li>
<p>颅内止血不彻底可造成术后颅内血肿。</p>
</li>
<li>
<p>硬脑膜缝合不严密可造成术后脑脊液漏。乳突气房开放，术后可出现脑脊液鼻漏。</p>
</li>
<li>
<p>软组织止血不彻底可造成术后软组织血肿。</p>
</li>
</ul>
<p><strong>手术技巧</strong></p>
<ul>
<li>术前花时间做好计划、设计好手术体位。</li>
</ul>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154345_9eyda2as69.jpg" alt="" title="32.webp.jpg"></p>
<ul>
<li>头部旋转80°可良好显露IAC。</li>
</ul>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154415_fwwt12oct2.jpg" alt="" title="33.webp.jpg"></p>
<ul>
<li>
<p>与颞下前、颞下后入路对比，这种硬膜外入路需要侧屈的角度更小、抬高的角度更大。</p>
</li>
<li>
<p>开刀前需搞清楚以下内容：手术入路相关骨结构和神经血管结构；骨窗位置；皮肤切口。</p>
</li>
<li>
<p>耳前直切口，注意保护好颞浅动脉和耳颞神经。</p>
</li>
</ul>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154443_fa8t7bcan5.jpg" alt="" title="34.webp.jpg"></p>
<ul>
<li>“Y”型切开颞肌筋膜，如图所示牵开固定。其中，基底筋膜瓣（颧弓侧）还可用于硬膜修补。</li>
</ul>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154506_lh9hifh1r9.jpg" alt="" title="35.webp.jpg"></p>
<ul>
<li>绝大多数情况下，颞肌的剥离都可使用钝性剥离子完成，不需切开颞肌。</li>
</ul>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154534_a424s0l34i.jpg" alt="" title="36.webp.jpg"></p>
<ul>
<li>游离骨瓣步骤：1. 颅骨钻孔；2. 平行于乳突上嵴和颧弓铣开颞底颅骨；3. 半弧形游离骨瓣。</li>
</ul>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154555_2xc5m2tqc0.jpg" alt="" title="37.webp.jpg"></p>
<ul>
<li>骨窗高度至少2.5cm（从颧弓处测量），这样方可获得内听道的充分显露。</li>
</ul>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154623_hsxdy2nknl.jpg" alt="" title="38.webp.jpg"></p>
<ul>
<li>磨除骨窗颞底的内板，此步骤重要性在于增大手术视角和操作自由度。</li>
</ul>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154652_sx9njlqqvm.jpg" alt="" title="39.webp.jpg"></p>
<ul>
<li>如乳突气房开放不可避免，需仔细封堵。封堵材料可用骨蜡、筋膜瓣或颞肌。</li>
</ul>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154724_b5ndihay51.jpg" alt="" title="40.webp.jpg"></p>
<ul>
<li>为尽可能降低颞叶的牵拉力度，可在硬脑膜上切开一小口，打开皮层蛛网膜下腔。也可在术前放置腰大池引流。</li>
</ul>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154759_t16robdqgw.jpg" alt="" title="41.webp.jpg"></p>
<ul>
<li>
<p>使用“蓝线”技术，精确定位内听道走行。</p>
</li>
<li>
<p>可通过“打开颞下硬脑膜、切开小脑幕”，拓展IAC的硬膜外入路。磨除岩尖可进一步可扩大中后颅窝的显露。</p>
</li>
<li>
<p>硬脑膜尽可能水密缝合。或可使用肌肉瓣、腹部脂肪组织进行后颅窝硬脑膜的修补。</p>
</li>
<li>
<p>如术后发生脑脊液鼻漏，可放置腰大池引流。</p>
</li>
</ul>
<p><img src="http://www.medtion.com/uploads/1/image/public/201608/20160810154826_y1t083ruen.jpg" alt="" title="42.webp.jpg"></p>
<ul>
<li>
<p>骨孔处用钛片固定、封堵。</p>
</li>
<li>
<p>为避免术后脑脊液漏，不推荐放置引流管。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从一个py中运行另一个带参数的py]]></title>
        <id>https://lizhenzhublog.github.io/HTML/post/6F7PaKHq4</id>
        <link href="https://lizhenzhublog.github.io/HTML/post/6F7PaKHq4">
        </link>
        <updated>2019-07-08T12:15:16.000Z</updated>
        <content type="html"><![CDATA[<pre><code>import sys
import argparse
import getpass

def main(args):
    if args['username'] is None:
        print 'No user name specified. Login to WebCTRL needs a user name and password. Check all options for this command via -h'
        sys.exit(1)
    else:
        username = args['username']
    if args['password'] is None:
        password = getpass.getpass('No password specified via -p. Please enter your WebCTRL login password: ')
    else:
        password = args['password']
    if args['node'] is None:
        print 'No path to a node specified. Check all options for this command via -h'
        sys.exit(1)
    if args['url'] is None:
        print 'No URL given. Specify the URL to the WebCTRL server analogous to http://google.de'
        sys.exit(1)
    else:
        wsdlFile = args['url'] + '/_common/webservices/Eval?wsdl'

    # This doesn't belong to my original code. It's rather for demonstration:
    # Print the arguments and leave the script
    print 'Username: ' + args['username']
    print 'Node: ' + args['node']
    print 'URL: ' + args['url']


# The parser is only called if this script is called as a script/executable (via command line) but not when imported by another script
if __name__=='__main__':
    if len(sys.argv) &lt; 2:
        print &quot;You haven't specified any arguments. Use -h to get more details on how to use this command.&quot;
        sys.exit(1)
    parser = argparse.ArgumentParser()
    parser.add_argument('--username', '-u', type=str, default=None, help='Username for the login to the WebCTRL server')
    parser.add_argument('--password', '-p', type=str, default=None, help='Password for the login to the WebCTRL server')
    parser.add_argument('--node', '-n', type=str, default=None,
        help='Path to the point or node whose children you want to retrieve. Start querying at the lowest level with &quot;-n /trees/geographic&quot;')
    parser.add_argument('-url', type=str, default='https://webctrl.rz-berlin.mpg.de',
        help=&quot;URL of the WebCTRL server as e.g. http://google.de&quot;)
    args = parser.parse_args()

    # Convert the argparse.Namespace to a dictionary: vars(args)
    main(vars(args))
    sys.exit(0)
</code></pre>
<p>现在，有三种执行wc_query_test的方法，这就是我想要实现的目标：</p>
<p>1）从命令行调用wc_query_test.py：</p>
<p><code>~/PycharmProjects/webctrl$ python wc_query_test.py -u aawrg -p wgAWER -n YWERGAEWR</code></p>
<p>2）从命令行编译和调用wc_query_test：</p>
<p><code>~/PycharmProjects/webctrl$ pyinstaller --distpath dist/. wc_query_test.py
~/PycharmProjects/webctrl$ ./dist/wc_query_test/wc_query_test -u aawrg -p wgAWER -n YWERGAEWR</code></p>
<p>3）从另一个python脚本调用wc_query_test，该脚本进入模块类型用法的方向：</p>
<p><code>import wc_query_test
myDictonary = {'username':'wsdl', 'password':'aaaaaa', 'node':'/trees/geographic', 'url':'https://my.server.de'}
wc_query_test.main(myDictonary)</code></p>
<p>所有三个版本都会产生与预期相同的输出，例如：</p>
<p><code>~/PycharmProjects/webctrl$ ./dist/wc_query_test/wc_query_test -u aawrg -p wgAWER -n YWERGAEWR
Username: aawrg
Node: YWERGAEWR
URL: https://webctrl.rz-berlin.mpg.de</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[numpy_stl简介]]></title>
        <id>https://lizhenzhublog.github.io/HTML/post/5OyTRhe_F</id>
        <link href="https://lizhenzhublog.github.io/HTML/post/5OyTRhe_F">
        </link>
        <updated>2019-06-28T09:49:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="欢迎来到numpy-stl的文档">欢迎来到numpy-stl的文档！</h1>
<p>内容：</p>
<ul>
<li><a href="https://pythonhosted.org/numpy-stl/usage.html">numpy的-STL</a>
<ul>
<li><a href="https://pythonhosted.org/numpy-stl/usage.html#links">链接</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/usage.html#requirements-for-installing">安装要求：</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/usage.html#installation">安装：</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/usage.html#initial-usage">初次使用：</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/usage.html#contributing">贡献：</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/usage.html#quickstart">快速开始</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/usage.html#modifying-mesh-objects">修改Mesh对象</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/usage.html#extending-mesh-objects">扩展Mesh对象</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/usage.html#creating-mesh-objects-from-a-list-of-vertices-and-faces">从顶点和面的列表创建网格对象</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/usage.html#evaluating-mesh-properties-volume-center-of-gravity-inertia">评估网格属性（体积，重心，惯性）</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/usage.html#combining-multiple-stl-files">组合多个STL文件</a></li>
</ul>
</li>
<li><a href="https://pythonhosted.org/numpy-stl/tests.html">测试和例子</a>
<ul>
<li><a href="https://pythonhosted.org/numpy-stl/tests.html#tests-stl-corruption-module">tests.stl_corruption模块</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/tests.html#tests-test-commandline-module">tests.test_commandline模块</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/tests.html#tests-test-convert-module">tests.test_convert模块</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/tests.html#tests-test-mesh-module">tests.test_mesh模块</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/tests.html#tests-test-multiple-module">tests.test_multiple模块</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/tests.html#tests-test-rotate-module">tests.test_rotate模块</a></li>
</ul>
</li>
<li><a href="https://pythonhosted.org/numpy-stl/stl.html">stl包</a>
<ul>
<li><a href="https://pythonhosted.org/numpy-stl/stl.html#stl-mesh">stl.Mesh</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/stl.html#module-stl.main">stl.main模块</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/stl.html#module-stl.base">stl.base模块</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/stl.html#module-stl.mesh">stl.mesh模块</a></li>
<li><a href="https://pythonhosted.org/numpy-stl/stl.html#module-stl.stl">stl.stl模块</a></li>
</ul>
</li>
</ul>
<h1 id="指数和表">指数和表<a href="https://pythonhosted.org/numpy-stl/index.html#indices-and-tables" title="永久链接到这个标题">¶</a></h1>
<ul>
<li>
<p><a href="https://pythonhosted.org/numpy-stl/genindex.html">指数</a></p>
</li>
<li>
<p><a href="https://pythonhosted.org/numpy-stl/py-modindex.html">模块索引</a></p>
</li>
<li>
<p><a href="https://pythonhosted.org/numpy-stl/search.html">搜索页面</a></p>
</li>
<li>
<h1 id="numpy的-stl">numpy的-STL</h1>
<p>简单的库可以快速轻松地处理STL文件（以及一般的3D对象）。</p>
<p>由于所有操作都严重依赖于<cite>numpy，</cite>因此这是Python中最快的STL编辑库之一。</p>
<h2 id="链接">链接</h2>
<blockquote>
<ul>
<li>来源：<a href="https://github.com/WoLpH/numpy-stl">https</a>：<a href="https://github.com/WoLpH/numpy-stl">//github.com/WoLpH/numpy-stl</a></li>
<li>项目页面：<a href="https://pypi.python.org/pypi/numpy-stl">https</a>：<a href="https://pypi.python.org/pypi/numpy-stl">//pypi.python.org/pypi/numpy-stl</a></li>
<li>报告错误：<a href="https://github.com/WoLpH/numpy-stl/issues">https</a>：<a href="https://github.com/WoLpH/numpy-stl/issues">//github.com/WoLpH/numpy-stl/issues</a></li>
<li>文档：<a href="http://numpy-stl.readthedocs.org/en/latest/">http</a>：<a href="http://numpy-stl.readthedocs.org/en/latest/">//numpy-stl.readthedocs.org/en/latest/</a></li>
<li>我的博客：<a href="https://wol.ph/">https</a>：<a href="https://wol.ph/">//wol.ph/</a></li>
</ul>
</blockquote>
<h2 id="安装要求">安装要求：</h2>
<blockquote>
<ul>
<li><a href="http://numpy.org/">numpy</a>任何最新版本</li>
<li><a href="https://github.com/WoLpH/python-utils">python-utils</a> 1.6或更高版本</li>
</ul>
</blockquote>
<h2 id="安装">安装：</h2>
<p><cite>pip install numpy-stl</cite></p>
<h2 id="初次使用">初次使用：</h2>
<blockquote>
<ul>
<li><cite>stl2bin your_ascii_stl_file.stl new_binary_stl_file.stl</cite></li>
<li><cite>stl2ascii your_binary_stl_file.stl new_ascii_stl_file.stl</cite></li>
<li><cite>stl your_ascii_stl_file.stl new_binary_stl_file.stl</cite></li>
</ul>
</blockquote>
<h2 id="贡献">贡献：</h2>
<p>我们随时欢迎您的贡献。请查看入门指南：<a href="https://github.com/WoLpH/numpy-stl/blob/develop/CONTRIBUTING.rst">https</a>： <a href="https://github.com/WoLpH/numpy-stl/blob/develop/CONTRIBUTING.rst">//github.com/WoLpH/numpy-stl/blob/develop/CONTRIBUTING.rst</a></p>
<h2 id="快速入门">快速入门</h2>
</li>
<li>
<p>Quickstart
import numpy
from stl import mesh</p>
</li>
</ul>
<h1 id="using-an-existing-stl-file">Using an existing stl file:</h1>
<p>your_mesh = mesh.Mesh.from_file('some_file.stl')</p>
<h1 id="or-creating-a-new-mesh-make-sure-not-to-overwrite-the-mesh-import-by">Or creating a new mesh (make sure not to overwrite the <code>mesh</code> import by</h1>
<h1 id="naming-it-mesh">naming it <code>mesh</code>):</h1>
<p>VERTICE_COUNT = 100
data = numpy.zeros(VERTICE_COUNT, dtype=mesh.Mesh.dtype)
your_mesh = mesh.Mesh(data, remove_empty_areas=False)</p>
<h1 id="the-mesh-normals-calculated-automatically">The mesh normals (calculated automatically)</h1>
<p>your_mesh.normals</p>
<h1 id="the-mesh-vectors">The mesh vectors</h1>
<p>your_mesh.v0, your_mesh.v1, your_mesh.v2</p>
<h1 id="accessing-individual-points-concatenation-of-v0-v1-and-v2-in-triplets">Accessing individual points (concatenation of v0, v1 and v2 in triplets)</h1>
<p>assert (your_mesh.points[0][0:3] == your_mesh.v0[0]).all()
assert (your_mesh.points[0][3:6] == your_mesh.v1[0]).all()
assert (your_mesh.points[0][6:9] == your_mesh.v2[0]).all()
assert (your_mesh.points[1][0:3] == your_mesh.v0[1]).all()</p>
<p>your_mesh.save('new_stl_file.stl')
Plotting using matplotlib is equally easy:</p>
<p>from stl import mesh
from mpl_toolkits import mplot3d
from matplotlib import pyplot</p>
<h1 id="create-a-new-plot">Create a new plot</h1>
<p>figure = pyplot.figure()
axes = mplot3d.Axes3D(figure)</p>
<h1 id="load-the-stl-files-and-add-the-vectors-to-the-plot">Load the STL files and add the vectors to the plot</h1>
<p>your_mesh = mesh.Mesh.from_file('tests/stl_binary/HalfDonut.stl')
axes.add_collection3d(mplot3d.art3d.Poly3DCollection(your_mesh.vectors))</p>
<h1 id="auto-scale-to-the-mesh-size">Auto scale to the mesh size</h1>
<p>scale = your_mesh.points.flatten(-1)
axes.auto_scale_xyz(scale, scale, scale)</p>
<h1 id="show-the-plot-to-the-screen">Show the plot to the screen</h1>
<p>pyplot.show()
Modifying Mesh objects
from stl import mesh
import math
import numpy</p>
<h1 id="create-3-faces-of-a-cube">Create 3 faces of a cube</h1>
<p>data = numpy.zeros(6, dtype=mesh.Mesh.dtype)</p>
<h1 id="top-of-the-cube">Top of the cube</h1>
<p>data['vectors'][0] = numpy.array([[0, 1, 1],
[1, 0, 1],
[0, 0, 1]])
data['vectors'][1] = numpy.array([[1, 0, 1],
[0, 1, 1],
[1, 1, 1]])</p>
<h1 id="right-face">Right face</h1>
<p>data['vectors'][2] = numpy.array([[1, 0, 0],
[1, 0, 1],
[1, 1, 0]])
data['vectors'][3] = numpy.array([[1, 1, 1],
[1, 0, 1],
[1, 1, 0]])</p>
<h1 id="left-face">Left face</h1>
<p>data['vectors'][4] = numpy.array([[0, 0, 0],
[1, 0, 0],
[1, 0, 1]])
data['vectors'][5] = numpy.array([[0, 0, 0],
[0, 0, 1],
[1, 0, 1]])</p>
<h1 id="since-the-cube-faces-are-from-0-to-1-we-can-move-it-to-the-middle-by">Since the cube faces are from 0 to 1 we can move it to the middle by</h1>
<h1 id="substracting-5">substracting .5</h1>
<p>data['vectors'] -= .5</p>
<h1 id="generate-4-different-meshes-so-we-can-rotate-them-later">Generate 4 different meshes so we can rotate them later</h1>
<p>meshes = [mesh.Mesh(data.copy()) for _ in range(4)]</p>
<h1 id="rotate-90-degrees-over-the-y-axis">Rotate 90 degrees over the Y axis</h1>
<p>meshes[0].rotate([0.0, 0.5, 0.0], math.radians(90))</p>
<h1 id="translate-2-points-over-the-x-axis">Translate 2 points over the X axis</h1>
<p>meshes[1].x += 2</p>
<h1 id="rotate-90-degrees-over-the-x-axis">Rotate 90 degrees over the X axis</h1>
<p>meshes[2].rotate([0.5, 0.0, 0.0], math.radians(90))</p>
<h1 id="translate-2-points-over-the-x-and-y-points">Translate 2 points over the X and Y points</h1>
<p>meshes[2].x += 2
meshes[2].y += 2</p>
<h1 id="rotate-90-degrees-over-the-x-and-y-axis">Rotate 90 degrees over the X and Y axis</h1>
<p>meshes[3].rotate([0.5, 0.0, 0.0], math.radians(90))
meshes[3].rotate([0.0, 0.5, 0.0], math.radians(90))</p>
<h1 id="translate-2-points-over-the-y-axis">Translate 2 points over the Y axis</h1>
<p>meshes[3].y += 2</p>
<h1 id="optionally-render-the-rotated-cube-faces">Optionally render the rotated cube faces</h1>
<p>from matplotlib import pyplot
from mpl_toolkits import mplot3d</p>
<h1 id="create-a-new-plot-2">Create a new plot</h1>
<p>figure = pyplot.figure()
axes = mplot3d.Axes3D(figure)</p>
<h1 id="render-the-cube-faces">Render the cube faces</h1>
<p>for m in meshes:
axes.add_collection3d(mplot3d.art3d.Poly3DCollection(m.vectors))</p>
<h1 id="auto-scale-to-the-mesh-size-2">Auto scale to the mesh size</h1>
<p>scale = numpy.concatenate([m.points for m in meshes]).flatten(-1)
axes.auto_scale_xyz(scale, scale, scale)</p>
<h1 id="show-the-plot-to-the-screen-2">Show the plot to the screen</h1>
<p>pyplot.show()
Extending Mesh objects
from stl import mesh
import math
import numpy</p>
<h1 id="create-3-faces-of-a-cube-2">Create 3 faces of a cube</h1>
<p>data = numpy.zeros(6, dtype=mesh.Mesh.dtype)</p>
<h1 id="top-of-the-cube-2">Top of the cube</h1>
<p>data['vectors'][0] = numpy.array([[0, 1, 1],
[1, 0, 1],
[0, 0, 1]])
data['vectors'][1] = numpy.array([[1, 0, 1],
[0, 1, 1],
[1, 1, 1]])</p>
<h1 id="right-face-2">Right face</h1>
<p>data['vectors'][2] = numpy.array([[1, 0, 0],
[1, 0, 1],
[1, 1, 0]])
data['vectors'][3] = numpy.array([[1, 1, 1],
[1, 0, 1],
[1, 1, 0]])</p>
<h1 id="left-face-2">Left face</h1>
<p>data['vectors'][4] = numpy.array([[0, 0, 0],
[1, 0, 0],
[1, 0, 1]])
data['vectors'][5] = numpy.array([[0, 0, 0],
[0, 0, 1],
[1, 0, 1]])</p>
<h1 id="since-the-cube-faces-are-from-0-to-1-we-can-move-it-to-the-middle-by-2">Since the cube faces are from 0 to 1 we can move it to the middle by</h1>
<h1 id="substracting-5-2">substracting .5</h1>
<p>data['vectors'] -= .5</p>
<p>cube_back = mesh.Mesh(data.copy())
cube_front = mesh.Mesh(data.copy())</p>
<h1 id="rotate-90-degrees-over-the-x-axis-followed-by-the-y-axis-followed-by-the">Rotate 90 degrees over the X axis followed by the Y axis followed by the</h1>
<h1 id="x-axis">X axis</h1>
<p>cube_back.rotate([0.5, 0.0, 0.0], math.radians(90))
cube_back.rotate([0.0, 0.5, 0.0], math.radians(90))
cube_back.rotate([0.5, 0.0, 0.0], math.radians(90))</p>
<p>cube = mesh.Mesh(numpy.concatenate([
cube_back.data.copy(),
cube_front.data.copy(),
]))</p>
<h1 id="optionally-render-the-rotated-cube-faces-2">Optionally render the rotated cube faces</h1>
<p>from matplotlib import pyplot
from mpl_toolkits import mplot3d</p>
<h1 id="create-a-new-plot-3">Create a new plot</h1>
<p>figure = pyplot.figure()
axes = mplot3d.Axes3D(figure)</p>
<h1 id="render-the-cube">Render the cube</h1>
<p>axes.add_collection3d(mplot3d.art3d.Poly3DCollection(cube.vectors))</p>
<h1 id="auto-scale-to-the-mesh-size-3">Auto scale to the mesh size</h1>
<p>scale = cube_back.points.flatten(-1)
axes.auto_scale_xyz(scale, scale, scale)</p>
<h1 id="show-the-plot-to-the-screen-3">Show the plot to the screen</h1>
<p>pyplot.show()
Creating Mesh objects from a list of vertices and faces
import numpy as np
from stl import mesh</p>
<h1 id="define-the-8-vertices-of-the-cube">Define the 8 vertices of the cube</h1>
<p>vertices = np.array([<br>
[-1, -1, -1],
[+1, -1, -1],
[+1, +1, -1],
[-1, +1, -1],
[-1, -1, +1],
[+1, -1, +1],
[+1, +1, +1],
[-1, +1, +1]])</p>
<h1 id="define-the-12-triangles-composing-the-cube">Define the 12 triangles composing the cube</h1>
<p>faces = np.array([<br>
[0,3,1],
[1,3,2],
[0,4,7],
[0,7,3],
[4,5,6],
[4,6,7],
[5,1,2],
[5,2,6],
[2,3,6],
[3,7,6],
[0,1,5],
[0,5,4]])</p>
<h1 id="create-the-mesh">Create the mesh</h1>
<p>cube = mesh.Mesh(np.zeros(faces.shape[0], dtype=mesh.Mesh.dtype))
for i, f in enumerate(faces):
for j in range(3):
cube.vectors[i][j] = vertices[f[j],:]</p>
<h1 id="write-the-mesh-to-file-cubestl">Write the mesh to file &quot;cube.stl&quot;</h1>
<p>cube.save('cube.stl')
Evaluating Mesh properties (Volume, Center of gravity, Inertia)
import numpy as np
from stl import mesh</p>
<h1 id="using-an-existing-closed-stl-file">Using an existing closed stl file:</h1>
<p>your_mesh = mesh.Mesh.from_file('some_file.stl')</p>
<p>volume, cog, inertia = your_mesh.get_mass_properties()
print(&quot;Volume                                  = {0}&quot;.format(volume))
print(&quot;Position of the center of gravity (COG) = {0}&quot;.format(cog))
print(&quot;Inertia matrix at expressed at the COG  = {0}&quot;.format(inertia[0,:]))
print(&quot;                                          {0}&quot;.format(inertia[1,:]))
print(&quot;                                          {0}&quot;.format(inertia[2,:]))
Combining multiple STL files
import math
import stl
from stl import mesh
import numpy</p>
<h1 id="find-the-max-dimensions-so-we-can-know-the-bounding-box-getting-the-height">find the max dimensions, so we can know the bounding box, getting the height,</h1>
<h1 id="width-length-because-these-are-the-step-size">width, length (because these are the step size)...</h1>
<p>def find_mins_maxs(obj):
minx = maxx = miny = maxy = minz = maxz = None
for p in obj.points:
# p contains (x, y, z)
if minx is None:
minx = p[stl.Dimension.X]
maxx = p[stl.Dimension.X]
miny = p[stl.Dimension.Y]
maxy = p[stl.Dimension.Y]
minz = p[stl.Dimension.Z]
maxz = p[stl.Dimension.Z]
else:
maxx = max(p[stl.Dimension.X], maxx)
minx = min(p[stl.Dimension.X], minx)
maxy = max(p[stl.Dimension.Y], maxy)
miny = min(p[stl.Dimension.Y], miny)
maxz = max(p[stl.Dimension.Z], maxz)
minz = min(p[stl.Dimension.Z], minz)
return minx, maxx, miny, maxy, minz, maxz</p>
<p>def translate(_solid, step, padding, multiplier, axis):
if axis == 'x':
items = [0, 3, 6]
elif axis == 'y':
items = [1, 4, 7]
elif axis == 'z':
items = [2, 5, 8]
for p in _solid.points:
# point items are ((x, y, z), (x, y, z), (x, y, z))
for i in range(3):
p[items[i]] += (step * multiplier) + (padding * multiplier)</p>
<p>def copy_obj(obj, dims, num_rows, num_cols, num_layers):
w, l, h = dims
copies = []
for layer in range(num_layers):
for row in range(num_rows):
for col in range(num_cols):
# skip the position where original being copied is
if row == 0 and col == 0 and layer == 0:
continue
_copy = mesh.Mesh(obj.data.copy())
# pad the space between objects by 10% of the dimension being
# translated
if col != 0:
translate(_copy, w, w / 10., col, 'x')
if row != 0:
translate(_copy, l, l / 10., row, 'y')
if layer != 0:
translate(_copy, h, h / 10., layer, 'z')
copies.append(_copy)
return copies</p>
<h1 id="using-an-existing-stl-file-2">Using an existing stl file:</h1>
<p>main_body = mesh.Mesh.from_file('ball_and_socket_simplified_-_main_body.stl')</p>
<h1 id="rotate-along-y">rotate along Y</h1>
<p>main_body.rotate([0.0, 0.5, 0.0], math.radians(90))</p>
<p>minx, maxx, miny, maxy, minz, maxz = find_mins_maxs(main_body)
w1 = maxx - minx
l1 = maxy - miny
h1 = maxz - minz
copies = copy_obj(main_body, (w1, l1, h1), 2, 2, 1)</p>
<h1 id="i-wanted-to-add-another-related-stl-to-the-final-stl">I wanted to add another related STL to the final STL</h1>
<p>twist_lock = mesh.Mesh.from_file('ball_and_socket_simplified_-_twist_lock.stl')
minx, maxx, miny, maxy, minz, maxz = find_mins_maxs(twist_lock)
w2 = maxx - minx
l2 = maxy - miny
h2 = maxz - minz
translate(twist_lock, w1, w1 / 10., 3, 'x')
copies2 = copy_obj(twist_lock, (w2, l2, h2), 2, 2, 1)
combined = mesh.Mesh(numpy.concatenate([main_body.data, twist_lock.data] +
[copy.data for copy in copies] +
[copy.data for copy in copies2]))</p>
<p>combined.save('combined.stl', mode=stl.Mode.ASCII)  # save as ASCII</p>
<ul>
<li>
<h2 id="testsstl_corruption-module">tests.stl_corruption module</h2>
<p>from <strong>future</strong> import print_function
import pytest
import struct</p>
<p>from stl import mesh</p>
<p>_STL_FILE = '''
solid test.stl
facet normal -0.014565 0.073223 -0.002897
outer loop
vertex 0.399344 0.461940 1.044090
vertex 0.500000 0.500000 1.500000
vertex 0.576120 0.500000 1.117320
endloop
endfacet
endsolid test.stl
'''.lstrip()</p>
<p>def test_valid_ascii(tmpdir, speedups):
tmp_file = tmpdir.join('tmp.stl')
with tmp_file.open('w+') as fh:
fh.write(_STL_FILE)
fh.seek(0)
mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)</p>
<p>def test_ascii_with_missing_name(tmpdir, speedups):
tmp_file = tmpdir.join('tmp.stl')
with tmp_file.open('w+') as fh:
# Split the file into lines
lines = _STL_FILE.splitlines()</p>
<pre><code>    # Remove everything except solid
    lines[0] = lines[0].split()[0]

    # Join the lines to test files that start with solid without space
    fh.write('\n'.join(lines))
    fh.seek(0)
    mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)
</code></pre>
<p>def test_ascii_with_blank_lines(tmpdir, speedups):
_stl_file = '''
solid test.stl</p>
<p>facet normal -0.014565 0.073223 -0.002897</p>
<p>outer loop</p>
<p>vertex 0.399344 0.461940 1.044090
vertex 0.500000 0.500000 1.500000</p>
<p>vertex 0.576120 0.500000 1.117320</p>
<p>endloop</p>
<p>endfacet</p>
<p>endsolid test.stl
'''.lstrip()</p>
<pre><code>tmp_file = tmpdir.join('tmp.stl')
with tmp_file.open('w+') as fh:
    fh.write(_stl_file)
    fh.seek(0)
    mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)
</code></pre>
<p>def test_incomplete_ascii_file(tmpdir, speedups):
tmp_file = tmpdir.join('tmp.stl')
with tmp_file.open('w+') as fh:
fh.write('solid some_file.stl')
fh.seek(0)
with pytest.raises(AssertionError):
mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)</p>
<pre><code>for offset in (-20, 82, 100):
    with tmp_file.open('w+') as fh:
        fh.write(_STL_FILE[:-offset])
        fh.seek(0)
        with pytest.raises(AssertionError):
            mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)
</code></pre>
<p>def test_corrupt_ascii_file(tmpdir, speedups):
tmp_file = tmpdir.join('tmp.stl')
with tmp_file.open('w+') as fh:
fh.write(_STL_FILE)
fh.seek(40)
print('####\n' * 100, file=fh)
fh.seek(0)
with pytest.raises(AssertionError):
mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)</p>
<pre><code>with tmp_file.open('w+') as fh:
    fh.write(_STL_FILE)
    fh.seek(40)
    print(' ' * 100, file=fh)
    fh.seek(80)
    fh.write(struct.pack('&lt;i', 10).decode('utf-8'))
    fh.seek(0)
    with pytest.raises(AssertionError):
        mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)
</code></pre>
<p>def test_corrupt_binary_file(tmpdir, speedups):
tmp_file = tmpdir.join('tmp.stl')
with tmp_file.open('w+') as fh:
fh.write('#########\n' * 8)
fh.write('#\0\0\0')
fh.seek(0)
mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)</p>
<pre><code>with tmp_file.open('w+') as fh:
    fh.write('#########\n' * 9)
    fh.seek(0)
    with pytest.raises(AssertionError):
        mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)

with tmp_file.open('w+') as fh:
    fh.write('#########\n' * 8)
    fh.write('#\0\0\0')
    fh.seek(0)
    fh.write('solid test.stl')
    fh.seek(0)
    mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)
</code></pre>
<h2 id="teststest_commandline-module">tests.test_commandline module</h2>
<p>import sys</p>
<p>from stl import main</p>
<p>def test_main(ascii_file, binary_file, tmpdir, speedups):
original_argv = sys.argv[:]
args_pre = ['stl']
args_post = [str(tmpdir.join('output.stl'))]</p>
<pre><code>if not speedups:
    args_pre.append('-s')

try:
    sys.argv[:] = args_pre + [ascii_file] + args_post
    main.main()
    sys.argv[:] = args_pre + ['-r', ascii_file] + args_post
    main.main()
    sys.argv[:] = args_pre + ['-a', binary_file] + args_post
    main.main()
    sys.argv[:] = args_pre + ['-b', ascii_file] + args_post
    main.main()
finally:
    sys.argv[:] = original_argv
</code></pre>
<p>def test_args(ascii_file, tmpdir):
parser = main._get_parser('')</p>
<pre><code>def _get_name(*args):
    return main._get_name(parser.parse_args(list(map(str, args))))

assert _get_name('--name', 'foobar') == 'foobar'
assert _get_name('-', tmpdir.join('binary.stl')).endswith('binary.stl')
assert _get_name(ascii_file, '-').endswith('HalfDonut.stl')
assert _get_name('-', '-')
</code></pre>
<p>def test_ascii(binary_file, tmpdir, speedups):
original_argv = sys.argv[:]
try:
sys.argv[:] = [
'stl',
'-s' if not speedups else '',
binary_file,
str(tmpdir.join('ascii.stl')),
]
try:
main.to_ascii()
except SystemExit:
pass
finally:
sys.argv[:] = original_argv</p>
<p>def test_binary(ascii_file, tmpdir, speedups):
original_argv = sys.argv[:]
try:
sys.argv[:] = [
'stl',
'-s' if not speedups else '',
ascii_file,
str(tmpdir.join('binary.stl')),
]
try:
main.to_binary()
except SystemExit:
pass
finally:
sys.argv[:] = original_argv</p>
<h2 id="teststest_convert-module">tests.test_convert module</h2>
<h1 id="import-os">import os</h1>
<p>import pytest
import tempfile</p>
<p>from stl import stl</p>
<p>def <em>test_conversion(from</em>, to, mode, speedups):</p>
<pre><code>for name in from_.listdir():
    source_file = from_.join(name)
    expected_file = to.join(name)
    if not expected_file.exists():
        continue

    mesh = stl.StlMesh(source_file, speedups=speedups)
    with open(str(expected_file), 'rb') as expected_fh:
        expected = expected_fh.read()
        # For binary files, skip the header
        if mode is stl.BINARY:
            expected = expected[80:]

        with tempfile.TemporaryFile() as dest_fh:
            mesh.save(name, dest_fh, mode)
            # Go back to the beginning to read
            dest_fh.seek(0)
            dest = dest_fh.read()
            # For binary files, skip the header
            if mode is stl.BINARY:
                dest = dest[80:]

            assert dest.strip() == expected.strip()
</code></pre>
<p>def test_ascii_to_binary(ascii_path, binary_path, speedups):
_test_conversion(ascii_path, binary_path, mode=stl.BINARY,
speedups=speedups)</p>
<p>def test_binary_to_ascii(ascii_path, binary_path, speedups):
_test_conversion(binary_path, ascii_path, mode=stl.ASCII,
speedups=speedups)</p>
<p>def test_stl_mesh(ascii_file, tmpdir, speedups):
tmp_file = tmpdir.join('tmp.stl')</p>
<pre><code>mesh = stl.StlMesh(ascii_file, speedups=speedups)
with pytest.raises(ValueError):
    mesh.save(filename=str(tmp_file), mode='test')

mesh.save(str(tmp_file))
mesh.save(str(tmp_file), update_normals=False)
</code></pre>
<h2 id="teststest_mesh-module">tests.test_mesh module</h2>
<p>import numpy</p>
<p>from stl.mesh import Mesh
from stl.base import BaseMesh
from stl.base import RemoveDuplicates</p>
<p>def test_units_1d():
data = numpy.zeros(1, dtype=Mesh.dtype)
data['vectors'][0] = numpy.array([[0, 0, 0],
[1, 0, 0],
[2, 0, 0]])</p>
<pre><code>mesh = Mesh(data, remove_empty_areas=False)
mesh.update_units()

assert mesh.areas == 0
assert (mesh.normals == [0, 0, 0]).all()
assert (mesh.units == [0, 0, 0]).all()
</code></pre>
<p>def test_units_2d():
data = numpy.zeros(2, dtype=Mesh.dtype)
data['vectors'][0] = numpy.array([[0, 0, 0],
[1, 0, 0],
[0, 1, 0]])
data['vectors'][1] = numpy.array([[1, 0, 0],
[0, 1, 0],
[1, 1, 0]])</p>
<pre><code>mesh = Mesh(data, remove_empty_areas=False)
mesh.update_units()

assert (mesh.areas == [.5, .5]).all()
assert (mesh.normals == [[0, 0, 1.],
                         [0, 0, -1.]]).all()

assert (mesh.units == [[0, 0, 1],
                       [0, 0, -1]]).all()
</code></pre>
<p>def test_units_3d():
data = numpy.zeros(1, dtype=Mesh.dtype)
data['vectors'][0] = numpy.array([[0, 0, 0],
[1, 0, 0],
[0, 1, 1.]])</p>
<pre><code>mesh = Mesh(data, remove_empty_areas=False)
mesh.update_units()

assert (mesh.areas - 2 ** .5) &lt; 0.0001
assert (mesh.normals == [0, -1, 1]).all()

units = mesh.units[0]
assert units[0] == 0
# Due to floating point errors
assert (units[1] + .5 * 2 ** .5) &lt; 0.0001
assert (units[2] - .5 * 2 ** .5) &lt; 0.0001
</code></pre>
<p>def test_duplicate_polygons():
data = numpy.zeros(6, dtype=Mesh.dtype)
data['vectors'][0] = numpy.array([[1, 0, 0],
[0, 0, 0],
[0, 0, 0]])
data['vectors'][1] = numpy.array([[2, 0, 0],
[0, 0, 0],
[0, 0, 0]])
data['vectors'][2] = numpy.array([[0, 0, 0],
[0, 0, 0],
[0, 0, 0]])
data['vectors'][3] = numpy.array([[2, 0, 0],
[0, 0, 0],
[0, 0, 0]])
data['vectors'][4] = numpy.array([[1, 0, 0],
[0, 0, 0],
[0, 0, 0]])
data['vectors'][5] = numpy.array([[0, 0, 0],
[0, 0, 0],
[0, 0, 0]])</p>
<pre><code>mesh = Mesh(data)
assert mesh.data.size == 6

mesh = Mesh(data, remove_duplicate_polygons=0)
assert mesh.data.size == 6

mesh = Mesh(data, remove_duplicate_polygons=False)
assert mesh.data.size == 6

mesh = Mesh(data, remove_duplicate_polygons=None)
assert mesh.data.size == 6

mesh = Mesh(data, remove_duplicate_polygons=RemoveDuplicates.NONE)
assert mesh.data.size == 6

mesh = Mesh(data, remove_duplicate_polygons=RemoveDuplicates.SINGLE)
assert mesh.data.size == 3

mesh = Mesh(data, remove_duplicate_polygons=True)
assert mesh.data.size == 3

assert (mesh.vectors[0] == numpy.array([[1, 0, 0],
                                        [0, 0, 0],
                                        [0, 0, 0]])).all()
assert (mesh.vectors[1] == numpy.array([[2, 0, 0],
                                        [0, 0, 0],
                                        [0, 0, 0]])).all()
assert (mesh.vectors[2] == numpy.array([[0, 0, 0],
                                        [0, 0, 0],
                                        [0, 0, 0]])).all()

mesh = Mesh(data, remove_duplicate_polygons=RemoveDuplicates.ALL)
assert mesh.data.size == 3

assert (mesh.vectors[0] == numpy.array([[1, 0, 0],
                                        [0, 0, 0],
                                        [0, 0, 0]])).all()
assert (mesh.vectors[1] == numpy.array([[2, 0, 0],
                                        [0, 0, 0],
                                        [0, 0, 0]])).all()
assert (mesh.vectors[2] == numpy.array([[0, 0, 0],
                                        [0, 0, 0],
                                        [0, 0, 0]])).all()
</code></pre>
<p>def test_remove_all_duplicate_polygons():
data = numpy.zeros(5, dtype=Mesh.dtype)
data['vectors'][0] = numpy.array([[0, 0, 0],
[0, 0, 0],
[0, 0, 0]])
data['vectors'][1] = numpy.array([[1, 0, 0],
[0, 0, 0],
[0, 0, 0]])
data['vectors'][2] = numpy.array([[2, 0, 0],
[0, 0, 0],
[0, 0, 0]])
data['vectors'][3] = numpy.array([[3, 0, 0],
[0, 0, 0],
[0, 0, 0]])
data['vectors'][4] = numpy.array([[3, 0, 0],
[0, 0, 0],
[0, 0, 0]])</p>
<pre><code>mesh = Mesh(data, remove_duplicate_polygons=False)
assert mesh.data.size == 5
Mesh.remove_duplicate_polygons(mesh.data, RemoveDuplicates.NONE)

mesh = Mesh(data, remove_duplicate_polygons=RemoveDuplicates.ALL)
assert mesh.data.size == 3

assert (mesh.vectors[0] == numpy.array([[0, 0, 0],
                                        [0, 0, 0],
                                        [0, 0, 0]])).all()
assert (mesh.vectors[1] == numpy.array([[1, 0, 0],
                                        [0, 0, 0],
                                        [0, 0, 0]])).all()
assert (mesh.vectors[2] == numpy.array([[2, 0, 0],
                                        [0, 0, 0],
                                        [0, 0, 0]])).all()
</code></pre>
<p>def test_empty_areas():
data = numpy.zeros(3, dtype=Mesh.dtype)
data['vectors'][0] = numpy.array([[0, 0, 0],
[1, 0, 0],
[0, 1, 0]])
data['vectors'][1] = numpy.array([[1, 0, 0],
[0, 1, 0],
[1, 0, 0]])
data['vectors'][2] = numpy.array([[1, 0, 0],
[0, 1, 0],
[1, 0, 0]])</p>
<pre><code>mesh = Mesh(data, remove_empty_areas=False)
assert mesh.data.size == 3

mesh = Mesh(data, remove_empty_areas=True)
assert mesh.data.size == 1
</code></pre>
<p>def test_base_mesh():
data = numpy.zeros(10, dtype=BaseMesh.dtype)
mesh = BaseMesh(data, remove_empty_areas=False)
# Increment vector 0 item 0
mesh.v0[0] += 1
mesh.v1[0] += 2</p>
<pre><code># Check item 0 (contains v0, v1 and v2)
assert (mesh[0] == numpy.array(
    [1., 1., 1., 2., 2., 2., 0., 0., 0.], dtype=numpy.float32)
).all()
assert (mesh.vectors[0] == numpy.array([
        [1., 1., 1.],
        [2., 2., 2.],
        [0., 0., 0.]], dtype=numpy.float32)).all()
assert (mesh.v0[0] == numpy.array([1., 1., 1.], dtype=numpy.float32)).all()
assert (mesh.points[0] == numpy.array(
    [1., 1., 1., 2., 2., 2., 0., 0., 0.], dtype=numpy.float32)
).all()
assert (
    mesh.x[0] == numpy.array([1., 2., 0.], dtype=numpy.float32)).all()

mesh[0] = 3
assert (mesh[0] == numpy.array(
    [3., 3., 3., 3., 3., 3., 3., 3., 3.], dtype=numpy.float32)
).all()

assert len(mesh) == len(list(mesh))
assert (mesh.min_ &lt; mesh.max_).all()
mesh.update_normals()
assert mesh.units.sum() == 0.0
mesh.v0[:] = mesh.v1[:] = mesh.v2[:] = 0
assert mesh.points.sum() == 0.0
</code></pre>
<h2 id="teststest_multiple-module">tests.test_multiple module</h2>
<p>from stl import mesh
from stl.utils import b</p>
<p>_STL_FILE = b('''
solid test.stl
facet normal -0.014565 0.073223 -0.002897
outer loop
vertex 0.399344 0.461940 1.044090
vertex 0.500000 0.500000 1.500000
vertex 0.576120 0.500000 1.117320
endloop
endfacet
endsolid test.stl
'''.lstrip())</p>
<p>def test_single_stl(tmpdir, speedups):
tmp_file = tmpdir.join('tmp.stl')
with tmp_file.open('wb+') as fh:
fh.write(_STL_FILE)
fh.seek(0)
for m in mesh.Mesh.from_multi_file(
str(tmp_file), fh=fh, speedups=speedups):
pass</p>
<p>def test_multiple_stl(tmpdir, speedups):
tmp_file = tmpdir.join('tmp.stl')
with tmp_file.open('wb+') as fh:
for _ in range(10):
fh.write(_STL_FILE)
fh.seek(0)
for i, m in enumerate(mesh.Mesh.from_multi_file(
str(tmp_file), fh=fh, speedups=speedups)):
assert m.name == b'test.stl'</p>
<pre><code>    assert i == 9
</code></pre>
<p>def test_single_stl_file(tmpdir, speedups):
tmp_file = tmpdir.join('tmp.stl')
with tmp_file.open('wb+') as fh:
fh.write(_STL_FILE)
fh.seek(0)
for m in mesh.Mesh.from_multi_file(
str(tmp_file), speedups=speedups):
pass</p>
<p>def test_multiple_stl_file(tmpdir, speedups):
tmp_file = tmpdir.join('tmp.stl')
with tmp_file.open('wb+') as fh:
for _ in range(10):
fh.write(_STL_FILE)</p>
<pre><code>    fh.seek(0)
    for i, m in enumerate(mesh.Mesh.from_multi_file(
            str(tmp_file), speedups=speedups)):
        assert m.name == b'test.stl'

    assert i == 9
</code></pre>
<h2 id="teststest_rotate-module">tests.test_rotate module</h2>
<p>import math
import numpy</p>
<p>from stl.mesh import Mesh</p>
<p>def test_rotation():
# Create 6 faces of a cube
data = numpy.zeros(6, dtype=Mesh.dtype)</p>
<pre><code># Top of the cube
data['vectors'][0] = numpy.array([[0, 1, 1],
                                  [1, 0, 1],
                                  [0, 0, 1]])
data['vectors'][1] = numpy.array([[1, 0, 1],
                                  [0, 1, 1],
                                  [1, 1, 1]])
# Right face
data['vectors'][2] = numpy.array([[1, 0, 0],
                                  [1, 0, 1],
                                  [1, 1, 0]])
data['vectors'][3] = numpy.array([[1, 1, 1],
                                  [1, 0, 1],
                                  [1, 1, 0]])
# Left face
data['vectors'][4] = numpy.array([[0, 0, 0],
                                  [1, 0, 0],
                                  [1, 0, 1]])
data['vectors'][5] = numpy.array([[0, 0, 0],
                                  [0, 0, 1],
                                  [1, 0, 1]])

mesh = Mesh(data, remove_empty_areas=False)

# Since the cube faces are from 0 to 1 we can move it to the middle by
# substracting .5
data['vectors'] -= .5

# Rotate 90 degrees over the X axis followed by the Y axis followed by the
# X axis
mesh.rotate([0.5, 0.0, 0.0], math.radians(90))
mesh.rotate([0.0, 0.5, 0.0], math.radians(90))
mesh.rotate([0.5, 0.0, 0.0], math.radians(90))

# Since the cube faces are from 0 to 1 we can move it to the middle by
# substracting .5
data['vectors'] += .5

assert (mesh.vectors == numpy.array([
    [[1, 0, 0], [0, 1, 0], [0, 0, 0]],
    [[0, 1, 0], [1, 0, 0], [1, 1, 0]],
    [[0, 1, 1], [0, 1, 0], [1, 1, 1]],
    [[1, 1, 0], [0, 1, 0], [1, 1, 1]],
    [[0, 0, 1], [0, 1, 1], [0, 1, 0]],
    [[0, 0, 1], [0, 0, 0], [0, 1, 0]],
])).all()
</code></pre>
<p>def test_rotation_over_point():
# Create a single face
data = numpy.zeros(1, dtype=Mesh.dtype)</p>
<pre><code>data['vectors'][0] = numpy.array([[1, 0, 0],
                                  [0, 1, 0],
                                  [0, 0, 1]])

mesh = Mesh(data, remove_empty_areas=False)

mesh.rotate([1, 0, 0], math.radians(180), point=[1, 2, 3])
assert (mesh.vectors == numpy.array([[1, -4, -6],
                                     [0, -5, -6],
                                     [0, -4, -7]])).all()
</code></pre>
<p>def test_no_rotation():
# Create a single face
data = numpy.zeros(1, dtype=Mesh.dtype)</p>
<pre><code>data['vectors'][0] = numpy.array([[0, 1, 1],
                                  [1, 0, 1],
                                  [0, 0, 1]])

mesh = Mesh(data, remove_empty_areas=False)

# Rotate by 0 degrees
mesh.rotate([0.5, 0.0, 0.0], math.radians(0))
assert (mesh.vectors == numpy.array([
    [[0, 1, 1], [1, 0, 1], [0, 0, 1]]])).all()

# Use a zero rotation matrix
mesh.rotate([0.0, 0.0, 0.0], math.radians(90))
assert (mesh.vectors == numpy.array([
    [[0, 1, 1], [1, 0, 1], [0, 0, 1]]])).all()
</code></pre>
<p>def test_no_translation():
# Create a single face
data = numpy.zeros(1, dtype=Mesh.dtype)
data['vectors'][0] = numpy.array([[0, 1, 1],
[1, 0, 1],
[0, 0, 1]])</p>
<pre><code>mesh = Mesh(data, remove_empty_areas=False)
assert (mesh.vectors == numpy.array([
    [[0, 1, 1], [1, 0, 1], [0, 0, 1]]])).all()

# Translate mesh with a zero vector
mesh.translate([0.0, 0.0, 0.0])
assert (mesh.vectors == numpy.array([
    [[0, 1, 1], [1, 0, 1], [0, 0, 1]]])).all()
</code></pre>
<p>def test_translation():
# Create a single face
data = numpy.zeros(1, dtype=Mesh.dtype)
data['vectors'][0] = numpy.array([[0, 1, 1],
[1, 0, 1],
[0, 0, 1]])</p>
<pre><code>mesh = Mesh(data, remove_empty_areas=False)
assert (mesh.vectors == numpy.array([
    [[0, 1, 1], [1, 0, 1], [0, 0, 1]]])).all()

# Translate mesh with vector [1, 2, 3]
mesh.translate([1.0, 2.0, 3.0])
assert (mesh.vectors == numpy.array([
    [[1, 3, 4], [2, 2, 4], [1, 2, 4]]])).all()
</code></pre>
<p>def test_no_transformation():
# Create a single face
data = numpy.zeros(1, dtype=Mesh.dtype)
data['vectors'][0] = numpy.array([[0, 1, 1],
[1, 0, 1],
[0, 0, 1]])</p>
<pre><code>mesh = Mesh(data, remove_empty_areas=False)
assert (mesh.vectors == numpy.array([
    [[0, 1, 1], [1, 0, 1], [0, 0, 1]]])).all()

# Transform mesh with identity matrix
mesh.transform(numpy.eye(4))
assert (mesh.vectors == numpy.array([
    [[0, 1, 1], [1, 0, 1], [0, 0, 1]]])).all()
assert numpy.all(mesh.areas == 0.5)
</code></pre>
<p>def test_transformation():
# Create a single face
data = numpy.zeros(1, dtype=Mesh.dtype)
data['vectors'][0] = numpy.array([[0, 1, 1],
[1, 0, 1],
[0, 0, 1]])</p>
<pre><code>mesh = Mesh(data, remove_empty_areas=False)
assert (mesh.vectors == numpy.array([
    [[0, 1, 1], [1, 0, 1], [0, 0, 1]]])).all()

# Transform mesh with identity matrix
tr = numpy.zeros((4, 4))
tr[0:3, 0:3] = Mesh.rotation_matrix([0, 0, 1], 0.5 * numpy.pi)
tr[0:3, 3] = [1, 2, 3]
mesh.transform(tr)
assert (mesh.vectors == numpy.array([
    [[0, 2, 4], [1, 3, 4], [1, 2, 4]]])).all()
assert numpy.all(mesh.areas == 0.5)</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[matplotlib绘图注意]]></title>
        <id>https://lizhenzhublog.github.io/HTML/post/HOPBFrX0u</id>
        <link href="https://lizhenzhublog.github.io/HTML/post/HOPBFrX0u">
        </link>
        <updated>2019-06-26T11:59:40.000Z</updated>
        <content type="html"><![CDATA[<p>https://wizardforcel.gitbooks.io/matplotlib-user-guide/7.3.html
https://www.guofei.site</p>
<p>转载请注明出处：</p>
<p><a href="http://www.cnblogs.com/darkknightzh/p/6182474.html">http://www.cnblogs.com/darkknightzh/p/6182474.html</a></p>
<p>参考网址：</p>
<p><a href="http://matplotlib.org/examples/pylab_examples/ginput_demo.html">http://matplotlib.org/examples/pylab_examples/ginput_demo.html</a></p>
<p><a href="http://stackoverflow.com/questions/12760797/imshowimg-cmap-cm-gray-shows-a-white-for-128-value">http://stackoverflow.com/questions/12760797/imshowimg-cmap-cm-gray-shows-a-white-for-128-value</a></p>
<p>1. 获得鼠标点击位置——使用ginput函数：</p>
<p><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>import matplotlib.pyplot as plt
import numpy as np</p>
<p>x=range(1,10)
y=[2*v for v in x]
print(x, y)
plt.plot(x, y)
pos=plt.ginput(3)
print(pos)
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><img src="https://images2015.cnblogs.com/blog/682463/201612/682463-20161215111214808-689851759.png" alt=""></p>
<p>那三个红色的十字为鼠标点击的位置，显示如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/682463/201612/682463-20161215111244026-2011598343.png" alt=""></p>
<p>2. 显示灰度图像：</p>
<p>默认imshow显示的是彩色图像：</p>
<p><img src="https://images2015.cnblogs.com/blog/682463/201612/682463-20161215111345448-1894828896.png" alt=""></p>
<p>需要显示灰度图像时，可以使用plt.get_cmap：</p>
<p><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>import matplotlib.pyplot as plt
import Image</p>
<p>im = Image.open(&quot;th.jpg&quot;)
plt.imshow(im, cmap = plt.get_cmap(&quot;gray&quot;))
pos=plt.ginput(3)
print(pos)
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><img src="https://images2015.cnblogs.com/blog/682463/201612/682463-20161215111416542-1864257153.png" alt=""></p>
<p>可以使用vmin和vmax来达到和matlab的imshow中[]一样的效果，将小于vmin的量化成黑色，大于vmax的量化成白色：</p>
<p>plt.imshow(im, cmap = plt.get_cmap(&quot;gray&quot;), vmin = 100, vmax = 150)</p>
<p><img src="https://images2015.cnblogs.com/blog/682463/201612/682463-20161215111456901-1192492061.png" alt=""></p>
<p>那三个红色的十字为鼠标点击的位置，显示如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/682463/201612/682463-20161215111519261-443664761.png" alt=""></p>
<p>由上面可见，直接plot的话，左下角是坐标原点；使用imshow时，是左上角为坐标原点。对于图像来说，和图像的坐标一样，不用转换，可以直接使用</p>
<p>使用matplotlib交互绘图****
加载图片，点击左键选中图片上的点并绘出横轴纵轴垂线，确定后点击右键打印出当前坐标：</p>
<p>#!/usr/bin/python</p>
<h1 id="codingutf-8">coding:utf-8</h1>
<p>from matplotlib import pyplot as plt
import cv2</p>
<p>def on_press(event):
if event.button==1:
ax.scatter(event.xdata, event.ydata)
plt.plot([event.xdata, event.xdata], [event.ydata, 600])
plt.plot([event.xdata, 0], [event.ydata, event.ydata])
fig.canvas.draw()
elif event.button==3:
print(&quot;x,y=&quot;,event.xdata, event.ydata)
if <strong>name</strong> == &quot;<strong>main</strong>&quot;:
img = cv2.imread('01.png')
cv2.imshow(&quot;src&quot;, img)
fig = plt.figure()
fig.canvas.mpl_connect(&quot;button_press_event&quot;, on_press)
ax = fig.add_subplot(111)
ax.imshow(img)
plt.axis(&quot;off&quot;)
plt.show()</p>
<p>输出：
原图01.png：</p>
<p>点击左键选点，并绘出横轴纵轴垂线：</p>
<h2 id="点击右键输出当前点的坐标xy-50127130681818176-20148636363636365">点击右键输出当前点的坐标：
(‘x,y=’, 501.27130681818176, 201.48636363636365)</h2>
<p>作者：阿卡蒂奥
来源：CSDN
原文：https://blog.csdn.net/akadiao/article/details/79761790
版权声明：本文为博主原创文章，转载请附上博文链接！</p>
<p>这篇文章的目的出于实验的需要,我需要对图片上的部分区域做出涂抹标记,本来是选择用opencv做交互的，但在需要进行图像的输出以及鼠标时间添加时，opencv出现错误。</p>
<p>解决方案网上有很多，尝试以后依然bug，这里先做一个记录,有时间再来处理。错误报告如下:</p>
<p>OpenCV Error: Unspecified error (The function is not implemented. Rebuild the library with Windows, GTK+ 2.x or Carbon support. If you are on Ubuntu or Debian, install libgtk2.0-dev and pkg-config, then re-run cmake or configure script) in cvShowImage, file -------src-dir-------/opencv-2.4.10/modules/highgui/src/window.cpp, line 501
Traceback (most recent call last):
File &quot;test.py&quot;, line 20, in <module>
cv2.imshow('img',img)
cv2.error: -------src-dir-------/opencv-2.4.10/modules/highgui/src/window.cpp:501: error: (-2) The function is not implemented. Rebuild the library with Windows, GTK+ 2.x or Carbon support. If you are on Ubuntu or Debian, install libgtk2.0-dev and pkg-config, then re-run cmake or configure script in function cvShowImage</p>
<p>这里我们切换另一种解决方案，利用python的matplotlib库完成图像的输出以及鼠标事件的添加。</p>
<p>点击图片，在图像中鼠标对应位置画点：</p>
<h1 id="codingutf-8-2">coding=utf-8</h1>
<p>from matplotlib import pyplot as plt
import cv2</p>
<p>def on_press(event):
if event.inaxes == None:
print &quot;none&quot;
return
#在鼠标的当前位置绘制一个点
ax.scatter(event.xdata, event.ydata）
#更新画板
fig.canvas.draw()</p>
<p>if <strong>name</strong> == &quot;<strong>main</strong>&quot;:
fileN = r'./0107_1.3.6.1.4.1.14519.5.2.1.6279.6001.263660956768649083933159084365.bmp'
img = cv2.imread(fileN)
cv2.imshow('img',img)
fig = py.figure()
fig.canvas.mpl_connect(&quot;button_press_event&quot;, on_press)
ax = fig.add_subplot(121)
ax1 = fig.add_subplot(122)
ax.imshow(img)
ax1.imshow(img)
plt.axis(&quot;off&quot;)
plt.show()</p>
<p>先来简单解释一下代码的含义：</p>
<p>fig.canvas.mpl_connect(&quot;button_press_event&quot;, on_press)#在这个figure上加点击事件，点击后的情况在自己写的on_press()方法里
def on_press(event):
event.inaxes.figure.canvas.draw()#用于图片刷新
event.x#事件的坐标用于其他按钮点击和figure点击发生冲突时判断返回
event.xdata,event.ydata#鼠标点击的位置，与上面那个坐标表示形式不同</p>
<p>最后的输出结果入下图。我们得到了非常奇怪的结果，如果你自己亲自动手试的话体会应该会更有体会，两边的图像本来应该一样大，但在第一次绘制点的时候，左侧图像出现了闪动，然后尺寸的比例突然发生了变化。</p>
<p>是的，图像尺寸没有发生变化，但尺寸的比例的确变了，这里我们要做的就是关闭自动变化的尺度比例。</p>
<p>if <strong>name</strong> == &quot;<strong>main</strong>&quot;:
fileN = r'./0107_1.3.6.1.4.1.14519.5.2.1.6279.6001.263660956768649083933159084365.bmp'
img = cv2.imread(fileN)
cv2.imshow('img',img)
fig = py.figure()
fig.canvas.mpl_connect(&quot;button_press_event&quot;, on_press)
ax = fig.add_subplot(121)
ax1 = fig.add_subplot(122)
ax.imshow(img)
ax1.imshow(img)
#关闭自动尺度适配
ax.set_autoscale_on(False)
plt.axis(&quot;off&quot;)
plt.show()
当然，我们可以改变绘制标记的样式：</p>
<p>ax.scatter(x,y,c='k',s=25,alpha=1.0,marker='o')
#T:散点的颜色
#s：散点的大小
#alpha:是透明程度</p>
<p>现在我们能够在图像上进行标记了，但这样还不够，程序需要获取这些标记点。</p>
<p>实际上fig.canvas.mpl_connect(&quot;button_press_event&quot;, on_press)能够进行自定义的多参数传递，如果在每次绘制的时候将数据保存在外部传入的列表中，那么当画板被销毁时，我们就能获取到原来所有的绘制点。</p>
<p>这里介绍两种使用方法：</p>
<p>def on_key(event, arg1, arg2, arg3):
pass
canvas.mpl_connect('key_press_event', lambda event: on_key(event, plt1, plt2, plt3))</p>
<p>和</p>
<p>def on_key(event, args_list):
pass
fig.canvas.mpl_connect('key_press_event', lambda event: on_key(event, [plt1, plt2, plt3]))</p>
<p>这里需要注意的是scatter绘制的点，实际上并没有大小的概念，这个点实质是一个坐标。</p>
<p>如果需要绘制有实际面积的圆形的标记，可以使用matplotlib.patches.Circle</p>
<p>具体的使用如下：</p>
<p>from matplotlib.patches import Circle</p>
<h2 id="fig-pltfigureax-figadd_subplot111cir-circlexy-eventxdata-eventydatafacecolor-black-edgecolorblackradius10-alpha10axadd_patchcir">fig = plt.figure()
ax = fig.add_subplot(111)
cir = Circle(xy = (event.xdata, event.ydata),facecolor = 'black', edgecolor='black',radius=10, alpha=1.0)
ax.add_patch(cir)</h2>
]]></content>
    </entry>
</feed>